<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring5框架文档翻译--Core | Li buyan Blog</title><meta name="description" content="Spring5框架文档翻译--Core"><meta name="keywords" content="Spring, 文档, 翻译"><meta name="author" content="Li buyan"><meta name="copyright" content="Li buyan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2021/06/19/Spring5%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91--Core/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Spring5框架文档翻译--Core"><meta property="og:url" content="http://yoursite.com/2021/06/19/Spring5%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91--Core/"><meta property="og:site_name" content="Li buyan Blog"><meta property="og:description" content="Spring5框架文档翻译--Core"><meta property="og:image" content="https://backiee.com/static/wpdb/wallpapers/1000x563/031672.jpg"><meta property="article:published_time" content="2021-06-19T11:38:00.000Z"><meta property="article:modified_time" content="2021-06-19T11:39:39.547Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-06-19 19:39:39'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="Li buyan Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Core-Technologies-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">1.</span> <span class="toc-text">Core Technologies (核心技术)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-The-IoC-Container-IoC%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1. The IoC Container (IoC容器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans-Spring-IoC%E5%AE%B9%E5%99%A8%E5%92%8Cbean%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1. Introduction to the Spring IoC Container and Beans (Spring IoC容器和bean的介绍)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Container-Overview-%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2. Container Overview (容器概述)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-Instantiating-a-Container-%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.2. Instantiating a Container (实例化一个容器)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Composing-XML-based-Configuration-Metadata-%E7%BC%96%E5%86%99%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">Composing XML-based Configuration Metadata (编写基于XML的配置元数据)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#The-Groovy-Bean-Definition-DSL"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">The Groovy Bean Definition DSL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-Using-the-Container"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.3. Using the Container</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Bean-Overview-Bean%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3. Bean Overview (Bean概述)</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://backiee.com/static/wpdb/wallpapers/1000x563/031672.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Li buyan Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Spring5框架文档翻译--Core</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-19T11:38:00.000Z" title="发表于 2021-06-19 19:38:00">2021-06-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-19T11:39:39.547Z" title="更新于 2021-06-19 19:39:39">2021-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/%E7%BF%BB%E8%AF%91/">翻译</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Core-Technologies-核心技术"><a href="#Core-Technologies-核心技术" class="headerlink" title="Core Technologies (核心技术)"></a>Core Technologies (核心技术)</h1><blockquote>
<p>Version 5.3.8</p>
<p>[TOC]</p>
</blockquote>
<p>This part of the reference documentation covers all the technologies that are absolutely integral to the Spring Framework.</p>
<p>参考文档的这一部分涵盖了Spring框架中绝对不可或缺的所有技术。</p>
<p>Foremost amongst these is the Spring Framework’s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework’s IoC container is closely followed by comprehensive coverage of Spring’s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.</p>
<p>其中最重要的是Spring框架的控制反转(IoC)容器。在对Spring框架的IoC容器进行了全面的处理之后，紧接着全面介绍了Spring的面向方面编程(AOP)技术。Spring框架有自己的AOP框架，它在概念上很容易理解，并且成功地解决了Java企业编程中80%的AOP需求。</p>
<p>Coverage of Spring’s integration with AspectJ (currently the richest — in terms of features — and certainly most mature AOP implementation in the Java enterprise space) is also provided.</p>
<p>还介绍了Spring与AspectJ的集成(就特性而言，目前AspectJ是最丰富的，当然也是Java企业空间中最成熟的AOP实现)。</p>
<h2 id="1-The-IoC-Container-IoC容器"><a href="#1-The-IoC-Container-IoC容器" class="headerlink" title="1. The IoC Container (IoC容器)"></a>1. The IoC Container (IoC容器)</h2><p>This chapter covers Spring’s Inversion of Control (IoC) container.</p>
<p>本章介绍Spring的控制反转(IoC)容器。</p>
<h3 id="1-1-Introduction-to-the-Spring-IoC-Container-and-Beans-Spring-IoC容器和bean的介绍"><a href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans-Spring-IoC容器和bean的介绍" class="headerlink" title="1.1. Introduction to the Spring IoC Container and Beans (Spring IoC容器和bean的介绍)"></a>1.1. Introduction to the Spring IoC Container and Beans (Spring IoC容器和bean的介绍)</h3><p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle. IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</p>
<p>本章介绍了控制反转(IoC)原理的Spring框架实现。IoC也称为依赖项注入(DI)。在这个过程中，对象只能通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系(即它们使用的其他对象)。然后，容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过直接构造类或诸如Service Locator模式这样的机制来控制其依赖项的实例化或位置的逆过程(因此得名“控制反转”)。</p>
<p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. The <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object. <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a> is a sub-interface of <code>BeanFactory</code>. It adds:</p>
<ul>
<li>Easier integration with Spring’s AOP features</li>
<li>Message resource handling (for use in internationalization)</li>
<li>Event publication</li>
<li>Application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</li>
</ul>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是Spring框架的IoC容器的基础。<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a> 接口提供了能够管理任何类型对象的高级配置机制。<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a> 是 <code>BeanFactory</code> 的一个子接口。它补充了:</p>
<ul>
<li>更容易与Spring的AOP特性集成</li>
<li>消息资源处理(用于国际化)</li>
<li>事件发布</li>
<li>应用层特定的上下文，如在web应用程序中使用的 <code>WebApplicationContext</code></li>
</ul>
<p>In short, the <code>BeanFactory</code> provides the configuration framework and basic functionality, and the <code>ApplicationContext</code> adds more enterprise-specific functionality. The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code> and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the <code>BeanFactory</code> instead of the <code>ApplicationContext,</code> see <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanfactory">The <code>BeanFactory</code></a>.</p>
<p>简而言之，<code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 增加了更多特定于企业的功能。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个完整的超集，在本章描述Spring的IoC容器时专门使用。<br>有关使用 <code>BeanFactory </code> 而不是 <code>ApplicationContext</code> 的更多信息，请参见 <code>BeanFactory</code>。</p>
<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.</p>
<p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、组装和管理的对象。否则，bean只是应用程序中的众多对象之一。bean及其之间的依赖关系反映在容器使用的配置元数据中。</p>
<h3 id="1-2-Container-Overview-容器概述"><a href="#1-2-Container-Overview-容器概述" class="headerlink" title="1.2. Container Overview (容器概述)"></a>1.2. Container Overview (容器概述)</h3><p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It lets you express the objects that compose your application and the rich interdependencies between those objects.</p>
<p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装bean。容器通过读取配置元数据获得关于实例化、配置和组装哪些对象的指令。配置元数据用XML、Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p>
<p>Several implementations of the <code>ApplicationContext</code> interface are supplied with Spring. In stand-alone applications, it is common to create an instance of <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a> or <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.3.8/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a>. While XML has been the traditional format for defining configuration metadata, you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.</p>
<p>Spring提供了  <code>org.springframework.context.ApplicationContext</code> 接口的几个实现。在独立应用程序中，通常会创建 <code>ClassPathXmlApplicationContext</code> 或 <code>FileSystemXmlApplicationContext</code> 的实例。<br>虽然XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置以声明支持这些额外的元数据格式，从而指示容器使用Java注解或代码作为元数据格式。</p>
<p>In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the <code>web.xml</code> file of the application typically suffices (see <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>). If you use the <a target="_blank" rel="noopener" href="https://spring.io/tools">Spring Tools for Eclipse</a> (an Eclipse-powered development environment), you can easily create this boilerplate configuration with a few mouse clicks or keystrokes.</p>
<p>在大多数应用场景中，不需要显式的用户代码来实例化一个或多个 Spring IoC 容器实例。例如，在 Web 应用程序场景中，在应用程序的web.xml文件中简单的8行(大约)样板Web描述符XML就足够了（请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-create">Web 应用程序的便捷 ApplicationContext 实例化</a>）。如果您使用 <a target="_blank" rel="noopener" href="https://spring.io/tools">Spring Tools for Eclipse</a>（一个 Eclipse 驱动的开发环境），您可以通过点击几下鼠标或按键轻松创建这个样板配置。</p>
<p>The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the <code>ApplicationContext</code> is created and initialized, you have a fully configured and executable system or application.</p>
<p>下图高度概括展示了Spring是如何工作的。你的应用程序中的类通过配置元数据从而整合到一起，这样，在 <code>ApplicationContext</code> 创建并初始化之后，你就会有一个配置好的可执行的系统或应用程序。</p>
<p><img src="https://docs.spring.io/spring-framework/docs/current/reference/html/images/container-magic.png" alt="container magic"></p>
<p><strong>Figure 1. The Spring IoC container</strong></p>
<p>As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application.</p>
<p>如上图所示，Spring IoC容器使用配置元数据的形式。这些配置元数据表示作为应用程序开发人员，你如何告诉Spring容器实例化、配置和组装应用程序中的对象。</p>
<p>[^此配置元数据表示作为应用程序开发人员，你如何告诉Spring容器实例化、配置和组装应用程序中的对象。]: 这句话的意思应该是: 你可以通过这些配置来告诉Ioc容器去实例化、配置和组装应用程序中的对象</p>
<blockquote>
<p> XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written. These days, many developers choose <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">Java-based configuration</a> for their Spring applications.</p>
<p>基于XML的元数据并不是唯一允许的配置元数据形式。Spring IoC容器本身与配置元数据实际编写的格式完全分离。如今许多开发人员在Spring应用程序选择基于Java的配置。</p>
</blockquote>
<p>For information about using other forms of metadata with the Spring container, see:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 introduced support for annotation-based configuration metadata.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">Java-based configuration</a>: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>, and <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a> annotations.</li>
</ul>
<p>有关在 Spring 容器中使用其他形式的元数据的信息，请参阅：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config">基于注解的配置</a>：Spring 2.5 引入了对基于注解的配置元数据的支持。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">基于 Java 的配置</a>：从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多特性成为核心 Spring Framework 的一部分。因此，您可以使用 Java 而不是 XML 文件来定义应用程序类外部的 bean。要使用这些新功能，请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>， <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>， <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>，和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a>注释。</li>
</ul>
<p>Spring 配置包含至少一个并且通常不止一个容器必须管理的 bean 定义。基于 XML 的配置元数据将这些 bean 配置为<code>&lt;beans/&gt;</code> 这个最顶级元素中的 <code>&lt;bean/&gt;</code> 元素中, Java配置方式通常在 <code>@Configuration</code> 修饰的类中使用<code>@bean</code>注解的方式来进行配置。</p>
<p>These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts <code>Action</code> instances, infrastructure objects such as Hibernate <code>SessionFactories</code>, JMS <code>Queues</code>, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable">Using AspectJ to dependency-inject domain objects with Spring</a>.</p>
<p>The following example shows the basic structure of XML-based configuration metadata:</p>
<p>这些bean定义对应于组成应用程序的实际对象。通常，您需要定义服务层对象、数据访问层对象(DAOs)、表现层对象(如Struts Action实例)、基础结构对象(如Hibernate SessionFactories、JMS队列)等等。通常，不需要在容器中配置细粒度的域对象，因为创建和加载域对象通常是DAO层和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。请参阅 <a href="(https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-atconfigurable)">使用AspectJ使用Spring依赖注入域对象</a>。</p>
<p>下面的例子展示了基于XML的配置元数据的基本结构:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>The id attribute is a string that identifies the individual bean definition.</li>
<li>The class attribute defines the type of the bean and uses the fully qualified classname.</li>
</ul>
<p>The value of the <code>id</code> attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example. See <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies">Dependencies</a> for more information.</p>
<ol>
<li><code>id</code> 属性是一个字符串, 用来标识单个bean定义</li>
<li><code>class</code> 属性使用全类名的方式定义一个bean的类型。</li>
</ol>
<p>id属性的值引用协作对象。此示例中未显示用于引用协作对象的 XML。有关更多信息，请参见Dependencies。</p>
<h4 id="1-2-2-Instantiating-a-Container-实例化一个容器"><a href="#1-2-2-Instantiating-a-Container-实例化一个容器" class="headerlink" title="1.2.2. Instantiating a Container (实例化一个容器)"></a>1.2.2. Instantiating a Container (实例化一个容器)</h4><p>The location path or paths supplied to an <code>ApplicationContext</code> constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java <code>CLASSPATH</code>, and so on.</p>
<p>提供给 <code>ApplicationContext</code> 构造函数的一个或多个位置路径是资源字符串，允许容器从各种外部资源（例如本地文件系统、Java CLASSPATH等）加载配置元数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p> After you learn about Spring’s IoC container, you may want to know more about Spring’s <code>Resource</code> abstraction (as described in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources">Resources</a>), which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, <code>Resource</code> paths are used to construct applications contexts, as described in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx">Application Contexts and Resource Paths</a>.</p>
<p> 在了解了 Spring 的 IoC 容器之后，您可能想了解更多关于 Spring 的 <code>Resource</code>抽象（如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources">参考资料中所述</a>），它提供了一种从 URI 语法中定义的位置读取 InputStream 的便捷机制。特别是， <code>Resource</code>路径用于构造应用程序上下文，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources-app-ctx">应用程序上下文和资源路径中所述</a>。</p>
</blockquote>
<p>The following example shows the service layer objects <code>(services.xml)</code> configuration file:</p>
<p>以下示例显示了服务层对象<code>(services.xml)</code>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;petStore&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;itemDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>In the preceding example, the service layer consists of the <code>PetStoreServiceImpl</code> class and two data access objects of the types <code>JpaAccountDao</code> and <code>JpaItemDao</code> (based on the JPA Object-Relational Mapping standard). The <code>property name</code> element refers to the name of the JavaBean property, and the <code>ref</code> element refers to the name of another bean definition. This linkage between <code>id</code> and <code>ref</code> elements expresses the dependency between collaborating objects. For details of configuring an object’s dependencies, see <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies">Dependencies</a>.</p>
<p>在前面的示例中，服务层由 <code>PetStoreServiceImpl</code> 类和两个类型 <code>JpaAccountDao</code> 和 <code>JpaItemDao</code>（基于 JPA 对象-关系映射标准）的数据访问对象组成。该 <code>property name</code> 元素是指 JavaBean 属性的名称，以及 <code>ref</code> 元素指的是另一个bean定义的名称。(就是id名称)<code>id</code> 和 <code>ref</code> 元素之间的这种联系表达了协作对象之间的依赖关系。有关配置对象依赖项的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies">Dependencies</a>.</p>
<h5 id="Composing-XML-based-Configuration-Metadata-编写基于XML的配置元数据"><a href="#Composing-XML-based-Configuration-Metadata-编写基于XML的配置元数据" class="headerlink" title="Composing XML-based Configuration Metadata (编写基于XML的配置元数据)"></a>Composing XML-based Configuration Metadata (编写基于XML的配置元数据)</h5><p>It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture.</p>
<p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation">previous section</a>. Alternatively, use one or more occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or files. The following example shows how to do so:</p>
<p>让 bean 定义跨越多个 XML 文件会很有用。通常，每个单独的 XML 配置文件都代表您架构中的一个逻辑层或模块。</p>
<p>您可以使用应用程序上下文构造函数从所有这些 XML 片段加载 bean 定义。该构造函数采用多个 <code>Resource</code> 位置，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-instantiation">上一节</a>所示 。或者，使用一个或多个 <code>&lt;import/&gt;</code> 元素从另一个文件或多个文件加载 bean 定义。以下示例显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file. As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions, according to the Spring Schema.</p>
<p>在前面的例子中，外部bean定义是从这三个文件中加载： <code>services.xml</code>，<code>messageSource.xml</code>，和<code>themeSource.xml</code>。所有位置路径都相对于执行导入的定义文件(使用的是相对路径)，因此 <code>services.xml</code> 必须与执行导入的文件位于同一目录或类路径 (classpath) 位置，而 <code>messageSource.xml</code> 和 <code>themeSource.xml</code> 必须位于导入文件所在位置下方的 <code>resources</code> 位置。如您所见，前导斜杠(相对路径前的/)是被忽略的。但是，鉴于这些路径是相对的，最好根本不使用斜杠。根据 Spring Schema，被导入文件的内容，包括顶级元素<code>&lt;beans/&gt;</code>，必须是有效的 XML bean 定义。</p>
<blockquote>
<p> It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for <code>classpath:</code> URLs (for example, <code>classpath:../services.xml</code>), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p>
<p>You can always use fully qualified resource locations instead of relative paths: for example, <code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations — for example, through “${…}” placeholders that are resolved against JVM system properties at runtime.</p>
<p> 可以但不建议使用相对 “../” 路径引用父目录中的文件。这样做会为当前应用程序创建一个外部文件的依赖。特别是，不建议将此引用用于<code>classpath:</code>URL（例如，<code>classpath:../services.xml</code>）, 在这些URL中, 在解析时会选择“最近的” classpath根路径，然后查看其父目录。类路径配置更改可能会导致选择其他不正确的目录。</p>
<p>您始终可以使用绝对资源路径而不是相对路径：例如，<code>file:C:/config/services.xml</code>或<code>classpath:/config/services.xml</code>。但是，请意识到, 你正在将应用程序的配置与特定的绝对路径耦合。通常最好为这样的绝对路径保留一个间接地址——例如，使用“${… }”占位符, 在运行时根据 JVM 系统属性解析它。</p>
</blockquote>
<p>The namespace itself provides the import directive feature. Further configuration features beyond plain bean definitions are available in a selection of XML namespaces provided by Spring — for example, the <code>context</code> and <code>util</code> namespaces.</p>
<p>命名空间本身提供了 <code>import</code> 指令功能。除了普通bean定义之外，Spring提供的XML名称空间中还提供了更多的配置特性——例如，<code>context</code> 和 <code>util</code> 命名空间。</p>
<h5 id="The-Groovy-Bean-Definition-DSL"><a href="#The-Groovy-Bean-Definition-DSL" class="headerlink" title="The Groovy Bean Definition DSL"></a>The Groovy Bean Definition DSL</h5><p>As a further example for externalized configuration metadata, bean definitions can also be expressed in Spring’s Groovy Bean Definition DSL, as known from the Grails framework. Typically, such configuration live in a “.groovy” file with the structure shown in the following example:</p>
<p>作为外部化配置元数据的另一个示例，Bean定义也可以在Spring的Groovy Bean定义DSL中表达，这从Grails框架中可以知道。通常，此类配置位于一个 “.groovy”文件中，其结构如下例所示：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">beans &#123;  </span><br><span class="line"> dataSource(BasicDataSource) &#123;  </span><br><span class="line"> driverClassName = <span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span>  </span><br><span class="line"> url = <span class="string">&quot;jdbc:hsqldb:mem:grailsDB&quot;</span>  </span><br><span class="line"> username = <span class="string">&quot;sa&quot;</span>  </span><br><span class="line"> password = <span class="string">&quot;&quot;</span>  </span><br><span class="line"> settings = \[<span class="attr">mynew:</span><span class="string">&quot;setting&quot;</span>\]  </span><br><span class="line"> &#125;  </span><br><span class="line"> sessionFactory(SessionFactory) &#123;  </span><br><span class="line"> dataSource = dataSource  </span><br><span class="line"> &#125;  </span><br><span class="line"> myService(MyService) &#123;  </span><br><span class="line"> nestedBean = &#123; AnotherBean bean -&gt;  </span><br><span class="line"> dataSource = dataSource  </span><br><span class="line"> &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This configuration style is largely equivalent to XML bean definitions and even supports Spring’s XML configuration namespaces. It also allows for importing XML bean definition files through an <code>importBeans</code> directive.</p>
<p>这种配置风格在很大程度上等同于XML bean定义，甚至支持Spring的XML配置命名空间。它还允许通过<code>importBeans</code> 指令导入XML bean定义文件。</p>
<h4 id="1-2-3-Using-the-Container"><a href="#1-2-3-Using-the-Container" class="headerlink" title="1.2.3. Using the Container"></a>1.2.3. Using the Container</h4><p>The <code>ApplicationContext</code> is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method <code>T getBean(String name, Class&lt;T&gt; requiredType)</code>, you can retrieve instances of your beans.</p>
<p>The <code>ApplicationContext</code> lets you read bean definitions and access them, as the following example shows:</p>
<p><code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用 方法 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，您可以检索 bean 的实例。</p>
<p>将 <code>ApplicationContext</code> 允许你读bean定义和访问它们，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line">PetStoreService service = context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<p>With Groovy configuration, bootstrapping looks very similar. It has a different context implementation class which is Groovy-aware (but also understands XML bean definitions). The following example shows Groovy configuration:</p>
<p>对于Groovy配置来说，它的引导方式看起来和我们之前接触的其他同类引导非常相似。它有一个与众不同且专为Groovy而设计的上下文实现类（该类同样也可以识别XML中的bean定义）。Groovy配置示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>The most flexible variant is <code>GenericApplicationContext</code> in combination with reader delegates — for example, with <code>XmlBeanDefinitionReader</code> for XML files, as the following example shows:</p>
<p>最灵活的变体是 <code>GenericApplicationContext</code> 与 reader 委托结合使用——例如，XML文件使用<code>XmlBeanDefinitionReader</code>，如下例所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>You can also use the <code>GroovyBeanDefinitionReader</code> for Groovy files, as the following example shows:</p>
<p>针对 <code>Groovy</code> 文件也可以使用 <code>GroovyBeanDefinitionReader</code> ，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>You can mix and match such reader delegates on the same <code>ApplicationContext</code>, reading bean definitions from diverse configuration sources.</p>
<p>You can then use <code>getBean</code> to retrieve instances of your beans. The <code>ApplicationContext</code> interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the <code>getBean()</code> method at all and thus have no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).</p>
<p>你可以在相同的 <code>ApplicationContext</code> 上混合匹配 <code>reader</code> 委托 ，从不同的配置源读取bean的定义。</p>
<p>然后您可以使用它 <code>getBean</code> 来检索 bean 的实例。该<code>ApplicationContext</code> 接口有一些其他方法来检索 bean，但理想情况下，您的应用程序代码永远不应该使用它们。实际上，您的应用程序代码根本不应该调用该 <code>getBean()</code>方法，因此完全不依赖于 Spring API。例如，Spring 与 Web 框架的集成为各种 Web 框架组件（例如控制器和 JSF 管理的 bean）提供了依赖注入，让您可以通过元数据（例如 <code>@Autowired</code> 注解）声明对特定 bean 的依赖。</p>
<h3 id="1-3-Bean-Overview-Bean概述"><a href="#1-3-Bean-Overview-Bean概述" class="headerlink" title="1.3. Bean Overview (Bean概述)"></a>1.3. Bean Overview (Bean概述)</h3><p>A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container (for example, in the form of XML <code>&lt;bean/&gt;</code> definitions).</p>
<p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code> objects, which contain (among other information) the following metadata:</p>
<ul>
<li>A package-qualified class name: typically, the actual implementation class of the bean being defined.</li>
<li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).</li>
<li>References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies.</li>
<li>Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.</li>
</ul>
<p>一个 Spring IoC 容器管理一个或多个 bean。这些 bean 是使用您提供给容器的配置元数据创建的（例如，以 XML<code>&lt;bean/&gt;</code>定义的形式 ）。</p>
<p>在容器本身内，这些 bean 定义 表示为<code>BeanDefinition</code> 对象，其中包含（除其他信息外）以下元数据：</p>
<ul>
<li>包限定的类名：通常是定义的 bean 的实际实现类。</li>
<li>Bean 行为配置元素，它说明 Bean 在容器中的行为方式（范围、生命周期回调等）</li>
<li>引用 bean 执行其工作所需的其他 bean 。这些引用也称为协作者或依赖项。</li>
<li>在新创建的对象中设置的其他配置设置——例如，管理连接池的bean中要使用的连接池的大小限制或可用连接数。</li>
</ul>
<p>This metadata translates to a set of properties that make up each bean definition. The following table describes these properties:</p>
<p>此元数据转换为组成每个 bean 定义 的一组属性。下表描述了这些属性：</p>
<table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Explained in…</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class">Instantiating Beans</a></td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname">Naming Beans</a></td>
</tr>
<tr>
<td align="left">Scope</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes">Bean Scopes</a></td>
</tr>
<tr>
<td align="left">Constructor arguments</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators">Dependency Injection</a></td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators">Dependency Injection</a></td>
</tr>
<tr>
<td align="left">Autowiring mode</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire">Autowiring Collaborators</a></td>
</tr>
<tr>
<td align="left">Lazy initialization mode</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td align="left">Initialization method</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></td>
</tr>
<tr>
<td align="left">Destruction method</td>
<td align="left"><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></td>
</tr>
</tbody></table>
<p>In addition to bean definitions that contain information on how to create a specific bean, the <code>ApplicationContext</code> implementations also permit the registration of existing objects that are created outside the container (by users). This is done by accessing the ApplicationContext’s BeanFactory through the <code>getBeanFactory()</code> method, which returns the BeanFactory <code>DefaultListableBeanFactory</code> implementation. <code>DefaultListableBeanFactory</code> supports this registration through the <code>registerSingleton(..)</code> and <code>registerBeanDefinition(..)</code> methods. However, typical applications work solely with beans defined through regular bean definition metadata.</p>
<p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext </code>实现还允许注册在容器外创建的现有对象。这是通过<code>getBeanFactory()</code> 方法访问 ApplicationContext 的 BeanFactory 来完成的, 该方法返回BeanFactory 的实现类 <code>DefaultListableBeanFactory</code>。<code>DefaultListableBeanFactory</code> 通过<code>registerSingleton(..)</code>和 <code>registerBeanDefinition(..)</code> 方法支持这种注册方式。但是，典型的应用程序仅使用通过常规 bean 定义的元数据定义的 bean。</p>
<blockquote>
<p>Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to the factory) is not officially supported and may lead to concurrent access exceptions, inconsistent state in the bean container, or both.</p>
<p>Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤中正确地对它们进行推理。虽然在某种程度上支持覆盖现有的元数据和现有的单例实例，但是在运行时注册新bean(与对工厂的实时访问同时进行)并没有得到官方支持，并且可能导致并发访问异常、bean容器中的不一致状态，或者两者都有。</p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">libuyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2021/06/19/Spring5%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91--Core/">http://yoursite.com/2021/06/19/Spring5%E6%A1%86%E6%9E%B6%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91--Core/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Li buyan Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a><a class="post-meta__tags" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a></div><div class="post_share"><div class="social-share" data-image="https://backiee.com/static/wpdb/wallpapers/1000x563/031672.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/06/14/Hexo%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%94%B9%E5%B8%96%E5%AD%90title%E5%90%8E404%E9%97%AE%E9%A2%98/"><img class="next-cover" data-lazy-src="https://backiee.com/static/wpdb/wallpapers/1000x563/147982.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo分类页面以及修改帖子title后404问题</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Li buyan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to Li buyan Blog!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>