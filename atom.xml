<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Li buyan Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-14T10:35:03.090Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Li buyan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux配置Mysql</title>
    <link href="http://yoursite.com/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/"/>
    <id>http://yoursite.com/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/</id>
    <published>2021-06-14T10:28:00.000Z</published>
    <updated>2021-06-14T10:35:03.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux卸载Mysql（完全卸载）"><a href="#Linux卸载Mysql（完全卸载）" class="headerlink" title="Linux卸载Mysql（完全卸载）"></a>Linux卸载Mysql（完全卸载）</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//rpm包安装方式卸载</span><br><span class="line">查包名：rpm -qa|grep -i mysql</span><br><span class="line">删除命令：rpm -e –nodeps 包名</span><br><span class="line"></span><br><span class="line">//yum安装方式下载</span><br><span class="line">1.查看已安装的mysql</span><br><span class="line">命令：rpm -qa | grep -i mysql</span><br><span class="line">2.卸载mysql</span><br><span class="line">命令：yum remove mysql-community-server-5.6.36-2.el7.x86<span class="emphasis">_64</span></span><br><span class="line"><span class="emphasis">查看mysql的其它依赖：rpm -qa | grep -i mysql</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">//卸载依赖</span></span><br><span class="line"><span class="emphasis">yum remove mysql-libs</span></span><br><span class="line"><span class="emphasis">yum remove mysql-server</span></span><br><span class="line"><span class="emphasis">yum remove perl-DBD-MySQL</span></span><br><span class="line"><span class="emphasis">yum remove mysql</span></span><br></pre></td></tr></table></figure><h1 id="linux安装mysql"><a href="#linux安装mysql" class="headerlink" title="linux安装mysql"></a>linux安装mysql</h1><p><strong>1、查看系统版本</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@test107vm14 rpm-gpg]# lsb_release -a</span><br><span class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release 7.3.1611 (Core) </span><br><span class="line">Release:    7.3.1611</span><br><span class="line">Codename:   Core</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><p><strong>2、下载mysql安装包</strong></p><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>选择想要下载的mysql版本和对应的系统版本</p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/20180822183850434.png" alt="img"><br><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/20180822183945885.png" alt="这里写图片描述"></p><p>下载MySQL-5.6.41-1.el7.x86_64.rpm-bundle.tar，我下载的mysql5.6版本，下载新版本类似，找到对应的rpm-bundle.tar安装包下载即可！<br><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/20180822184037200.png" alt="这里写图片描述"></p><p><strong>3、检查是否已经存在mysql，若存在卸载，避免安装时产生一些错误！</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br></pre></td></tr></table></figure><p>若存在，使用rpm -e packname –nodeps命令删除安装包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which mysql</span><br></pre></td></tr></table></figure><p>查看mysql配置信息，删除对应的配置文件等信息！</p><p>删除mysql用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel mysql</span><br></pre></td></tr></table></figure><p><strong>4、上传安装包</strong></p><p>将下载的安装包上传到相应的目录，我上传至/usr/local/mysql 目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;mysql1</span><br></pre></td></tr></table></figure><p>上传安装包</p><p><strong>5、解压缩安装包</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf MySQL-5.6.41-1.el7.x86_64.rpm-bundle.tar1</span><br></pre></td></tr></table></figure><p>解压后，得到如下文件<br><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/20180822185330984.png" alt="这里写图片描述"></p><p><strong>6、创建mysql用户和组</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd -g 1000 mysql</span><br><span class="line">useradd mysql -g mysql -p mysql</span><br></pre></td></tr></table></figure><p><strong>7、安装mysql</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-server-5.6.41-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>提示错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_641</span><br></pre></td></tr></table></figure><p>与mariadb冲突，删除mariadb即可！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e mariadb-libs-1:5.5.56-2.el7.x86_64 --nodeps1</span><br></pre></td></tr></table></figure><p>然后重新执行上面的安装命令！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-client-5.6.41-1.el7.x86_64.rpm1</span><br><span class="line">rpm -ivh MySQL-devel-5.6.41-1.el7.x86_64.rpm1</span><br><span class="line">rpm -ivh MySQL-shared-5.6.41-1.el7.x86_64.rpm1</span><br></pre></td></tr></table></figure><p>安装这四个即可，至此安装完成！</p><p><strong>8、启动mysql</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysql start1</span><br></pre></td></tr></table></figure><p>启动成功后，可查看是否成功监听3306端口</p><p><strong>9、使用随机密码登录mysql</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name .mysql_secret1</span><br></pre></td></tr></table></figure><p>查找生成的随机密码路径，查看此文件，获取随机密码</p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/20180822190602213.png" alt="这里写图片描述"></p><p>使用随机默认密码登录mysql</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p1</span><br></pre></td></tr></table></figure><p><strong>10、修改密码</strong></p><p>登陆成功后，修改密码，否则无法选择数据库进行操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD&#x3D;password(&#39;password&#39;);1</span><br><span class="line">FLUSH PRIVILEGES;1</span><br></pre></td></tr></table></figure><p>至此，便可以进行mysql操作了；</p><h1 id="Centos7-安装MySQL-5-7"><a href="#Centos7-安装MySQL-5-7" class="headerlink" title="Centos7 安装MySQL 5.7"></a><a href="https://www.cnblogs.com/zsh-blogs/p/11497720.html">Centos7 安装MySQL 5.7</a></h1><p>在CentOS中默认安装有MariaDB，这个是MySQL的分支，但为了需要，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。</p><h3 id="1-下载并安装MySQL官方的-Yum-Repository"><a href="#1-下载并安装MySQL官方的-Yum-Repository" class="headerlink" title="1 下载并安装MySQL官方的 Yum Repository"></a>1 下载并安装MySQL官方的 Yum Repository</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -i -c http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p>使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p>之后就开始安装MySQL服务器。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><p>这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb。</p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910152003346-124172716.png" alt="img"></p><p>至此MySQL就安装完成了，然后是对MySQL的一些设置。</p><h3 id="2-MySQL数据库设置"><a href="#2-MySQL数据库设置" class="headerlink" title="2 MySQL数据库设置"></a>2 MySQL数据库设置</h3><p> 首先启动MySQL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start  mysqld.service</span><br></pre></td></tr></table></figure><p>查看MySQL运行状态，运行状态如图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910152057991-1891324736.png" alt="img"></p><p> 此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910152125152-1298938276.png" alt="img"></p><p>如下命令进入数据库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>输入初始密码（是上面图片最后面的 no;e!5&gt;&gt;alfg），此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;</span><br></pre></td></tr></table></figure><p>其中‘new password’替换成你要设置的密码，注意:密码设置必须要大小写字母数字和特殊符号（,/‘;:等）,不然不能配置成功</p><p>如果要修改为root这样的弱密码，需要进行以下配置：</p><p>查看密码策略</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%password%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910152304822-756480013.png" alt="img"></p><p> 修改密码策略<br>vi /etc/my.cnf<br>添加validate_password_policy配置</p><p>选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加validate_password_policy配置</span><br><span class="line">validate_password_policy&#x3D;0</span><br><span class="line">#关闭密码策略</span><br><span class="line">validate_password &#x3D; off</span><br></pre></td></tr></table></figure><p>重启mysql服务使配置生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>然后就可以修改为弱密码啦</p><h1 id="CentOS7使用yum安装MySQL8-0"><a href="#CentOS7使用yum安装MySQL8-0" class="headerlink" title="CentOS7使用yum安装MySQL8.0"></a>CentOS7使用yum安装MySQL8.0</h1><p>1、yum仓库下载MySQL：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum localinstall https:&#x2F;&#x2F;repo.mysql.com&#x2F;&#x2F;mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">&#x2F;&#x2F;这里的地址可以进入 https:&#x2F;&#x2F;repo.mysql.com&#x2F;中去寻找自己需要的版本</span><br></pre></td></tr></table></figure><p>2、yum安装MySQL：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure><p>3、启动MySQL服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysqld start</span><br></pre></td></tr></table></figure><p>4、检查MySQL服务状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysqld status</span><br></pre></td></tr></table></figure><p>5、查看初始密码（如无内容直接跳过）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure><p>6、本地MySQL客户端登录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>7、输入密码为第5步查出的，如果没有，直接回车，然后输入命令 </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><p>8、修改root登录密码：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注意：开始遇到问题是不输入密码或输错密码都能连接MySQL server，后来在修改允许阿里CentOS7允许远程操作MySQL数据库时，</p><p>才发现需要去调整 /etc/my.cnf文件，注释掉skip-grant-tables，重启MySQL服务（sudo service mysqld restart），quit退出连接，重新连接就需要输入密码了</p><p>后期如果忘记密码，可以通过skip-grant-tables配置跳过输入密码登录MySQL，执行7、8步进行修改，如果‘root’@’localhost’变为‘root’@’%’，那么alter语句中的也要修改</p><p>9、配置MySQL允许外部访问：</p><p>1）首先设置阿里云安全组规则入方向，支持MySQL端口3306可访问（协议类型下拉菜单中有MySQL端口）</p><p>2）服务端登录MySQL，use mysql;</p><p>然后在mysql中执行以下语句, 可查看用户及对应允许访问主机</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> =<span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>允许任何外部可访问；再执行上一步查看命令，可比较结果</p><h3 id="3-mysql开启远程访问权限的设置"><a href="#3-mysql开启远程访问权限的设置" class="headerlink" title="3. mysql开启远程访问权限的设置"></a>3. mysql开启远程访问权限的设置</h3><p><strong>MySql-Server 出于安全方面考虑默认只允许本机(localhost, 127.0.0.1)来连接访问.</strong></p><p>所以必须给root修改可以远程访问的权限</p><p><strong>1.在连接服务器后,操作mysql系统数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"><span class="keyword">use</span> mysql；</span><br></pre></td></tr></table></figure><p><strong>2.查询用户列表</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">User</span>,authentication_string,Host <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>3.新增用户权限</strong></p><ol><li><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@’%’ IDENTIFIED BY ‘123456’  </p><p>这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址</p></li><li><p>flush privileges;     </p><p>这一步一定要做，不然无法成功！ 这句表示从mysql数据库的grant表中重新加载权限数据</p><p>因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p></li></ol><p><strong>4.删除用户及其权限</strong></p><p>delete from user where Host=’%’;</p><h4 id="3-1-或者也可新创建一个远程登陆的用户"><a href="#3-1-或者也可新创建一个远程登陆的用户" class="headerlink" title="3.1 或者也可新创建一个远程登陆的用户"></a>3.1 或者也可新创建一个远程登陆的用户</h4><p>示例账号为user、密码为123456。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create user <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>4、赋予用户user全部权限，并允许远程主机使用user账号访问MySQL，并使配置生效。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/up-9387f15c6abd83f911df75aa5f940e05ab7.png" alt="img"></p><p>5、查看用户。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select user,host from mysql.user; </span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/up-09a4791176475fff72019ae8f7eae7d77d3.png" alt="img"></p><h3 id="4-为firewalld添加开放端口"><a href="#4-为firewalld添加开放端口" class="headerlink" title="4 为firewalld添加开放端口"></a>4 为firewalld添加开放端口</h3><p>添加mysql端口3306</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p>如果提示 : <a href>FirewallD is not running</a> 查看 <strong>centos出现“FirewallD is not running”怎么办</strong></p><p>然后再重新载入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910152800260-2144918960.png" alt="img"></p><h3 id="5-修改mysql的字符编码（不修改会产生中文乱码问题）"><a href="#5-修改mysql的字符编码（不修改会产生中文乱码问题）" class="headerlink" title="5 修改mysql的字符编码（不修改会产生中文乱码问题）"></a>5 修改mysql的字符编码（不修改会产生中文乱码问题）</h3><p>显示原来编码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%character%&#39;;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910152946939-1117644087.png" alt="img"></p><p>修改/etc/my.cnf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br></pre></td></tr></table></figure><p>重启数据库</p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1201066-20190910153030577-1953443392.png" alt="img"></p><h1 id="mysql忘记密码"><a href="#mysql忘记密码" class="headerlink" title="mysql忘记密码:"></a>mysql忘记密码:</h1><p><strong>1. 检查<code>mysql</code>服务是否启动，如果启动，关闭<code>mysql</code>服务</strong></p><p>运行命令：<code>ps -ef | grep -i mysql</code></p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1411470-20190929173649786-1102739601.png" alt="img"></p><p> 如果开着就运行关闭的命令：service mysqld stop</p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1411470-20190929173858703-2071558955.png" alt="img"></p><p> <strong>2.修改mysql的配置文件my.conf</strong></p><p>一般在/etc目录下，运行命令：vi /etc/my.cnf，编辑文件</p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1411470-20190930100829664-491241917.png" alt="img"></p><p> 在文件的<code>[mysqld]标签下添加一句：skip-grant-tables</code></p><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/1411470-20190930161834995-303636370.png" alt="img"></p><p>然后wq!保存退出。</p><p> <strong>3.重启数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令：service mysqld restart</span><br></pre></td></tr></table></figure><p> <strong>5.进入到mysql数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令：mysql -u root </span><br></pre></td></tr></table></figure><p> <strong>6.进入到mysql数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令：mysql -u root </span><br></pre></td></tr></table></figure><p> <strong>7.修改密码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行语句：use mysql;</span><br><span class="line">继续运行语句：update mysql.user set authentication_string&#x3D;password(&#39;root_password&#39;) where user&#x3D;&#39;root&#39;;    </span><br><span class="line">root_password替换成你想要的密码</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p> <strong>8.把步骤2加的东西删除掉，在重启服务器，就可以使用刚才修改的密码登录进服务器了。</strong></p><p> <code>mysql -u root -p</code></p><p>到这一步已经全部结束。</p><h1 id="You-must-reset-your-password-using-ALTER-USER-statement-before-executing-this-statement"><a href="#You-must-reset-your-password-using-ALTER-USER-statement-before-executing-this-statement" class="headerlink" title="You must reset your password using ALTER USER statement before executing this statement"></a>You must reset your password using ALTER USER statement before executing this statement</h1><p>alter user user() identified by “root”;</p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h3 id="1、设置安全选项："><a href="#1、设置安全选项：" class="headerlink" title="1、设置安全选项："></a>1、设置安全选项：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><h3 id="2、关闭MySQL"><a href="#2、关闭MySQL" class="headerlink" title="2、关闭MySQL"></a>2、关闭MySQL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld </span><br><span class="line">service mysql stop;</span><br></pre></td></tr></table></figure><h3 id="3、重启MySQL"><a href="#3、重启MySQL" class="headerlink" title="3、重启MySQL"></a>3、重启MySQL</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld </span><br><span class="line">serivce restart mysql</span><br></pre></td></tr></table></figure><h3 id="4、查看MySQL运行状态"><a href="#4、查看MySQL运行状态" class="headerlink" title="4、查看MySQL运行状态"></a>4、查看MySQL运行状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld </span><br><span class="line">service mysql status</span><br></pre></td></tr></table></figure><h3 id="5、设置开机启动"><a href="#5、设置开机启动" class="headerlink" title="5、设置开机启动"></a>5、设置开机启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld </span><br></pre></td></tr></table></figure><h3 id="6、关闭开机启动"><a href="#6、关闭开机启动" class="headerlink" title="6、关闭开机启动"></a>6、关闭开机启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable mysqld </span><br></pre></td></tr></table></figure><h3 id="7、配置默认编码为utf8："><a href="#7、配置默认编码为utf8：" class="headerlink" title="7、配置默认编码为utf8："></a>7、配置默认编码为utf8：</h3><p>vi /etc/my.cnf #添加 [mysqld] character_set_server=utf8 init_connect=’SET NAMES utf8’</p><p>其他默认配置文件路径： </p><p>配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid</p><h3 id="8、查看版本"><a href="#8、查看版本" class="headerlink" title="8、查看版本"></a>8、查看版本</h3><p>select version();</p><h1 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h1><h2 id="centos出现“FirewallD-is-not-running”怎么办"><a href="#centos出现“FirewallD-is-not-running”怎么办" class="headerlink" title="centos出现“FirewallD is not running”怎么办"></a>centos出现“FirewallD is not running”怎么办</h2><p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。</p><ol><li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running，如下图所示。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=1"><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/7dd98d1001e939013391d96372ec54e737d196df.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=2"><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/55e736d12f2eb93882fe2eafdc628535e4dd6fdf-1623661285721.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=3"><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/e61190ef76c6a7efec9afc7bf4faaf51f3de662a.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=4"><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/503d269759ee3d6d9f44d3964a166d224e4adee9.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>5</p><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=5"><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/2e2eb9389b504fc2cecce458ecdde71191ef6ddf.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>6</p><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=6"><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/42166d224f4a20a4969c689a99529822730ed0e9.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p><p>END</p></li></ol><h2 id="报错2058-：连接-mysql-8-0-11-解决方法登录你的-mysql-数据库，然后-执行这条SQL："><a href="#报错2058-：连接-mysql-8-0-11-解决方法登录你的-mysql-数据库，然后-执行这条SQL：" class="headerlink" title="报错2058 ：连接 mysql 8.0.11 解决方法登录你的 mysql 数据库，然后 执行这条SQL："></a>报错2058 ：连接 mysql 8.0.11 解决方法登录你的 mysql 数据库，然后 执行这条SQL：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>#password 是你自己设置的root密码</p><p>localhost是允许登陆的主机, 允许所有则设置为 <code>%</code></p><h2 id="报错2003-无法远程连接"><a href="#报错2003-无法远程连接" class="headerlink" title="报错2003: 无法远程连接"></a>报错2003: 无法远程连接</h2><h4 id="ERROR-2003-HY000-Can’t-connect-to-MySQL-server-on-‘192-168-0-19’-111"><a href="#ERROR-2003-HY000-Can’t-connect-to-MySQL-server-on-‘192-168-0-19’-111" class="headerlink" title="ERROR 2003 (HY000): Can’t connect to MySQL server on ‘192.168.0.19’ (111)"></a>ERROR 2003 (HY000): Can’t connect to MySQL server on ‘192.168.0.19’ (111)</h4><p>个 原因就是Mysql<a href="http://www.111com.net/list-55/">数据库</a>的默认配置文件my.cnf（<a href="http://www.111com.net/list-156/">linux</a>下）中的bind-address默认为127.0.0.1，所以就算你创建了可以 remote访问的用户，你也不能使用mysql -h命令进行访问，若访问就会出现上出问题，因为此时Mysql只接受localhost，所以需要把bind-address屏蔽掉。</p><p>my.cnf一般在 /etc/mysql 下面，如果不在使用locate my.cnf查找，修改前的my.cnf配置文件为：</p><p>首先寻找my.cnf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis my.cnf</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/image-20210614172441001.png" alt="image-20210614172441001"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</span><br></pre></td></tr></table></figure><p>修改前的my.cnf配置文件代码<br>#<br># Instead of skip-networking the default is now to listen only on<br># localhost which is more compatible and is not less secure.<br>bind-address = 127.0.0.1<br>#<br># Instead of skip-networking the default is now to listen only on<br># localhost which is more compatible and is not less secure.<br>bind-address = 127.0.0.1<br>我们需要做的就是注释掉这个bind-address代码</p><p>如果上面还不能解决可能是防火强的问题了</p><p>首先关闭防火墙, 再尝试远程连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>如果还是不行的话</p><p>登录数据库</p><p>修改登录权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;登录用户名&#39;@&#39;允许登录的主机&#39; &#39;登录密码&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>eg. 如果想让任何主机都能通过 root 账户登录数据库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;  WITH GRANT OPTION;  &#x2F;&#x2F; ‘%’ 表示任意主机</span><br></pre></td></tr></table></figure><p>刷新权限表，使以上操作立即生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>千万不要忘了刷新权限</p>          </div><p>查看用户权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select user,host from mysql.user;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/image-20210614173013190.png" alt="image-20210614173013190"></p><p>查看远程登陆的user及host是否在表中</p><p>如果还是不行的话</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;port&#39;;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/Linux%E9%85%8D%E7%BD%AEMysql/image-20210614173201324.png" alt="image-20210614173201324"></p><p>查看value是否为3306, 如果不是的话, 查看my.cnf, 并将其修改为3306(或你需要的端口号)</p><p>如果my.cnf中是3306, 那么注释掉my.cnf中的 <code>skip-grant-tables</code></p><p>再次尝试远程登陆</p><div class="note warning">            <p>一定要确认, 输入的ip地址, 用户及密码是正确的!!!</p>          </div>]]></content>
    
    <summary type="html">
    
      Linux安装和配置Mysql的方式和注意事项
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Linux/Mysql/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git相关问题</title>
    <link href="http://yoursite.com/2021/05/27/Git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/05/27/Git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-27T10:01:00.000Z</published>
    <updated>2021-05-28T08:31:05.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将项目上传到仓库"><a href="#将项目上传到仓库" class="headerlink" title="将项目上传到仓库"></a>将项目上传到仓库</h1><ol><li><p>首先在码云上新建一个项目</p><pre><code>--&gt;复制码云新建项目的地址路径（https或ssh）。</code></pre></li><li><p>本地新建一个文件夹</p><pre><code>--&gt;点击新建文件夹，鼠标右键选择使用git bash打开</code></pre></li><li><p>git bash操作：</p><pre><code>   git init(初始化文件生成.git文件)    --&gt;回车--&gt;git remote add origin 码云项目地址    --&gt;回车--&gt;git pull origin master (将码云上的仓库pull到本地文件夹)    --&gt;添加编写代码。    --&gt; git push origin master </code></pre><h1 id="完全地覆盖本地的代码"><a href="#完全地覆盖本地的代码" class="headerlink" title="完全地覆盖本地的代码"></a>完全地覆盖本地的代码</h1></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">git reset --hard origin&#x2F;master</span><br></pre></td></tr></table></figure><h1 id="Git回退到指定节点的版本"><a href="#Git回退到指定节点的版本" class="headerlink" title="Git回退到指定节点的版本"></a>Git回退到指定节点的版本</h1><ol><li>获取某个历史版本的id（即change-id，每个版本唯一）</li></ol><p>方法1：使用git log命令查看所有的历史版本，输入q便可退出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>方法2：使用gitk图形化界面查看节点信息。（在安装 Git 的同时，你也装好了它提供的可视化工具，gitk 和 git-gui。）</p><p> —&gt;假设查到历史版本的id是124bb0f757e661ef12cdbe99a805c156297d1f11</p><ol start="2"><li>本地恢复到该节点状态</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 124bb0f757e661ef12cdbe99a805c156297d1f11</span><br></pre></td></tr></table></figure><ol start="3"><li>强推到远程分支</li></ol><p>此时如果分支较远或者改动较多，使用git push origin可能会报错失败，此时可使用强推</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -f -u origin master</span><br></pre></td></tr></table></figure><div class="note default">            <p>注：当远端设置了分支保护，则首先要将其取消，再强推；<br>强推之后，之前的版本被覆盖了，无法再查看到。</p>          </div><pre><code>git clone 远程指定分支git clone -b &lt;指定分支名&gt; &lt;远程仓库地址&gt;</code></pre><h1 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .   //添加到文件到缓冲区</span><br><span class="line">git commit -m &quot;xx&quot;   //提交</span><br><span class="line">git push origin master   //推送远程服务器</span><br></pre></td></tr></table></figure><h1 id="Git代理"><a href="#Git代理" class="headerlink" title="Git代理"></a>Git代理</h1><p>设置http https全局代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:10808</span><br><span class="line">git config --global https.proxy 127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>非全局代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:10808</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>取消http代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>查看代理信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy #查看git的http代理配置</span><br><span class="line">git config --global https.proxy #查看git的https代理配置</span><br><span class="line">git config --global -l #查看git的所有配置</span><br></pre></td></tr></table></figure><p>设置socks5代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:10808</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:10808</span><br></pre></td></tr></table></figure><h1 id="ssh和http相互切换"><a href="#ssh和http相互切换" class="headerlink" title="ssh和http相互切换"></a>ssh和http相互切换</h1><p>方法一：使用 <code>git remote set-url [本地分支] [url] </code>来进行更改。<br>1、查看当前地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https:&#x2F;&#x2F;github.com&#x2F;lyuxiaomin&#x2F;dubbo.git (fetch)</span><br><span class="line">origin  https:&#x2F;&#x2F;github.com&#x2F;lyuxiaomin&#x2F;dubbo.git (push)</span><br></pre></td></tr></table></figure><p>2、修改地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin git@github.com:lyuxiaomin&#x2F;dubbo.git</span><br></pre></td></tr></table></figure><p>3、查看修改后地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:lyuxiaomin&#x2F;dubbo.git (fetch)</span><br><span class="line">origin  git@github.com:lyuxiaomin&#x2F;dubbo.git (push)</span><br></pre></td></tr></table></figure><p>修改 .git/conf 文件,如下图：</p><p><img src="https://pic.imgdb.cn/item/60b0a98b08f74bc159dbe50f.jpg"></p><h1 id="可能遇到的一些问题"><a href="#可能遇到的一些问题" class="headerlink" title="可能遇到的一些问题"></a>可能遇到的一些问题</h1><h2 id="error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="error: Your local changes to the following files would be overwritten by merge:"></a>error: Your local changes to the following files would be overwritten by merge:</h2><p>方法1：如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull origin master</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>方法2、如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或者</span><br><span class="line">git reset --hard origin&#x2F;master</span><br></pre></td></tr></table></figure><h2 id="Git-Push-提示不支持具有-Socks5-方案的代理"><a href="#Git-Push-提示不支持具有-Socks5-方案的代理" class="headerlink" title="Git Push 提示不支持具有 Socks5 方案的代理"></a>Git Push 提示不支持具有 Socks5 方案的代理</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>使用 Git Push 提交代码到远程服务器时提示了一个错误</p><p><code>fatal: NotSupportedException encountered.</code></p><p><code>ServicePointManager</code> 不支持具有 <code>socks5</code> 方案的代理。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>然而之后还是正常提交成功了，实际上问题是：</p><ul><li>配置了本地的 <code>socks5</code> 的代理（Shadowsocks 之类的代理软件）</li><li>配置了远程服务器 Git 服务端的 SSH</li><li>本地提交代码到远程服务器时使用的是 http/https 协议</li></ul><p>这三者只要有一个不满足就不会出现这个错误了</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>取消远程的 SSH (不推荐)</li></ol><p>在下面的页面中删除你的 SSH Keys 即可</p><p><a href="https://github.com/settings/keys">GitHub</a></p><p><a href="https://bitbucket.org/account/user/your_username/ssh-keys/">Bitbucket</a></p><ol start="2"><li>提交内容到远程 Git 服务器时选择 SSH 协议</li></ol><p>设置远程仓库为 SSH 协议</p>]]></content>
    
    <summary type="html">
    
      在使用git过程中遇到的一些问题及解决办法
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL设置自增初始值和步长遇到的问题</title>
    <link href="http://yoursite.com/2021/04/16/MySQL%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%88%9D%E5%A7%8B%E5%80%BC%E5%92%8C%E6%AD%A5%E9%95%BF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2021/04/16/MySQL%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%88%9D%E5%A7%8B%E5%80%BC%E5%92%8C%E6%AD%A5%E9%95%BF%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-16T15:17:00.000Z</published>
    <updated>2021-04-17T03:17:38.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置自增初始值和步长"><a href="#设置自增初始值和步长" class="headerlink" title="设置自增初始值和步长"></a>设置自增初始值和步长</h1><p>通过：<code>SHOW VARIABLES LIKE &#39;auto_inc%&#39;;</code> 查看当前数据库的自增长设置。</p><p><img src="https://img.imgdb.cn/item/6079ab6d8322e6675ce16767.jpg"></p><p><code>auto_increment_increment</code>这是自增长的步长。</p><p><code>auto_increment_offset</code>这是自增长开始的值。</p><p>现在想要更改test表的id增长开始值和增长的步长,可以使用如下方法：</p><p><code>SET @@auto_increment_increment=3;</code> – 将自增长步长设置为3</p><p><code>SET @@auto_increment_offset=4;</code> – 将自增长开始值设置为4</p><p>但是这样设置的话, Mysql重启之后, 设置会消失, 所以我们需要在配置文件中修改</p><p>Mysql的配置文件, my.ini或者my.cnf</p><p>查找配置文件: <code>whereis my.cnf</code></p><p>或者:查看Mysql默认读取my.cnf的目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令</span><br><span class="line">mysql --help|grep &#x27;my.cnf&#x27;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><p>/etc/my.cnf, /etc/mysql/my.cnf, /usr/local/etc/my.cnf, ~/.my.cnf 这些就是mysql默认会搜寻my.cnf的目录，顺序排前的优先。</p><p>启动时没有使用配置文件<br>如果没有设置使用指定目录my.cnf文件及默认读取目录没有my.cnf文件，表示mysql启动时并没有加载配置文件，而是使用默认配置。</p><p>如果需要修改配置，可以在mysql默认读取的目录中，创建一个my.cnf文件(例如:/etc/my.cnf)，把需要修改的配置内容写入，重启mysql后即可生效.</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>查看一下结果，看是不是我们期望的值：</p><p><img src="https://img-blog.csdn.net/20180416095715384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1d4UTkyMjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>通过结果可以看到：从第二行开始，确实符合我们的设置。</p><p>但是：id是从3开始的，这与我们的设置并不一样，我们设置的为从4开始，怎么回事？怎么解决？</p><p>其实auto_increment在使用时，会对初始值与添加了auto_increment语法的列中的值进行比较，当 auto_increment的当前值(此处值是2)小于 添加了该语法的列的值时，auto_increment会拿当前值2 根据步长(2)递增，知道auto_increment的当前值大于添加了该语法的列(id)的值时，才会将最终的这个值作为初始插入数据的值。</p><p>auto_increment 在插入数据时，真正一开始可以插入表中的值得计算公式：</p><p>假设 a 为 表中id列的最大值, b为auto_increment的初始值，c 为步长，则auto_increment真正的初始值为：</p><p>auto_increment_real  =  int( a/b) * c + c  ;</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>研究了很久，翻看 MySQL 官网文档，都说，自增ID分别是 1、2、3 和 2 、 4 、 6 ，并没有对此情况做明确说明。<br>直到我看到 这位<a href="http://stackoverflow.com/questions/35766521/mysql-master-master-replication-causing-missing-autoincrement-values/35786634#35786634">大神的回答</a>。其实id的计算： <code>INT(current_value / increment) x increment + offset</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下：</p><ol><li>AUTO_INCREMENT 所在的列，必须为整数型数据列</li><li>AUTO_INCREMENT 所在的列，不能为空</li><li>AUTO_INCREMENT 所在的列，必须有唯一索引</li><li>AUTO_INCREMENT 所在的列，值必须大于0</li><li>AUTO_INCREMENT 所在的列，最大值，受其数据类型及是否为 无符号(Unsigned) 限制，若使用的为 TINYINT(4) 且 为无符号的，则最大值为 255，若继续插入数据，则该列的值保持最大值不变，</li><li>AUTO_INCREMENT 所在的列，若向其中插入的值，大于所在表当前的 AUTO_INCREMENT 值，则会更新表 AUTO_INCREMENT 值至 current_max_value - (current_max_value - auto_increment_offset) % auto_increment_increment + auto_increment_increment ，即该列的下一个序列值</li></ol>]]></content>
    
    <summary type="html">
    
      设置自增初始值和步长, 以及自增步长不符合预期和自增不连续的原因
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>国内镜像源</title>
    <link href="http://yoursite.com/2021/04/11/%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <id>http://yoursite.com/2021/04/11/%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</id>
    <published>2021-04-11T10:00:00.000Z</published>
    <updated>2021-04-11T09:48:51.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="国内镜像源"><a href="#国内镜像源" class="headerlink" title="国内镜像源"></a>国内镜像源</h1><p>推荐使用：阿里云 <a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/</a></p><h2 id="一、站点版"><a href="#一、站点版" class="headerlink" title="一、站点版"></a>一、站点版</h2><h3 id="（一）、企业站"><a href="#（一）、企业站" class="headerlink" title="（一）、企业站"></a>（一）、企业站</h3><p>1.搜狐：<a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a><br>2.网易：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a><br>3.阿里云：<a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/</a><br>4.腾讯：<a href="http://android-mirror.bugly.qq.com:8080/%EF%BC%88%E4%BB%85%E9%92%88%E5%AF%B9APP%E5%BC%80%E5%8F%91%E7%9A%84%E8%BD%AF%E4%BB%B6%EF%BC%8C%E9%99%90%E6%B5%81%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89">http://android-mirror.bugly.qq.com:8080/（仅针对APP开发的软件，限流，不推荐）</a></p><h3 id="（二）、教育站"><a href="#（二）、教育站" class="headerlink" title="（二）、教育站"></a>（二）、教育站</h3><p>1.上海交通大学：<a href="http://ftp.sjtu.edu.cn/html/resources.xml%EF%BC%88%E9%83%A8%E5%88%86%E7%A7%BB%E5%8A%A8%E8%BF%90%E8%90%A5%E5%95%86%E5%87%BA%E5%8F%A3%E7%8A%B6%E5%86%B5%E4%B8%8D%E4%BD%B3%EF%BC%8C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%EF%BC%89">http://ftp.sjtu.edu.cn/html/resources.xml（部分移动运营商出口状况不佳，无法访问）</a><br>2.华中科技大学：<a href="http://mirror.hust.edu.cn/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A4.83T%EF%BC%89">http://mirror.hust.edu.cn/（当前已用容量估计：4.83T）</a><br>3.清华大学：<a href="http://mirrors.tuna.tsinghua.edu.cn/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A9.8T%EF%BC%89">http://mirrors.tuna.tsinghua.edu.cn/（当前已用容量估计：9.8T）</a><br>4.北京理工大学：<a href="http://mirror.bit.edu.cn/web/">http://mirror.bit.edu.cn/web/</a><br>5.兰州大学：<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a><br>6.中国科技大学：<a href="http://mirrors.ustc.edu.cn/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A21.32T%EF%BC%89">http://mirrors.ustc.edu.cn/（当前已用容量估计：21.32T）</a><br>7.大连东软信息学院：<a href="http://mirrors.neusoft.edu.cn/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A2.5T%EF%BC%89">http://mirrors.neusoft.edu.cn/（当前已用容量估计：2.5T）</a><br>8.东北大学：<a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a><br>9.大连理工大学：<a href="http://mirror.dlut.edu.cn/">http://mirror.dlut.edu.cn/</a><br>10.哈尔滨工业大学：<a href="http://run.hit.edu.cn/html/%EF%BC%88%E9%83%A8%E5%88%86%E8%81%94%E9%80%9A%E8%BF%90%E8%90%A5%E5%95%86%E5%87%BA%E5%8F%A3%E7%8A%B6%E5%86%B5%E4%B8%8D%E4%BD%B3%EF%BC%8C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%EF%BC%89">http://run.hit.edu.cn/html/（部分联通运营商出口状况不佳，无法访问）</a><br>11.北京交通大学：<a href="http://mirror.bjtu.edu.cn/cn/">http://mirror.bjtu.edu.cn/cn/</a><br>12.天津大学：<a href="http://mirror.tju.edu.cn/">http://mirror.tju.edu.cn</a>（无法访问，ping超时）<br>13.中国地质大学：<a href="http://mirrors.cug.edu.cn/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A2.3T%EF%BC%89">http://mirrors.cug.edu.cn/（当前已用容量估计：2.3T）</a><br>14.浙江大学：<a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a><br>15.厦门大学：<a href="http://mirrors.xmu.edu.cn/">http://mirrors.xmu.edu.cn/</a><br>16.中山大学：<a href="http://mirror.sysu.edu.cn/">http://mirror.sysu.edu.cn/</a><br>17.重庆大学：<a href="http://mirrors.cqu.edu.cn/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A3.93T%EF%BC%89">http://mirrors.cqu.edu.cn/（当前已用容量估计：3.93T）</a><br>18.北京化工大学：<a href="http://ubuntu.buct.edu.cn/%EF%BC%88Android">http://ubuntu.buct.edu.cn/（Android</a> SDK镜像仅供校内使用，当前已用容量估计：1.72T）<br>19.南阳理工学院：<a href="http://mirror.nyist.edu.cn/">http://mirror.nyist.edu.cn/</a><br>20.中国科学院：<a href="http://www.opencas.org/mirrors/">http://www.opencas.org/mirrors/</a><br>21.电子科技大学：<a href="http://ubuntu.uestc.edu.cn/%EF%BC%88%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%EF%BC%8Cping%E8%B6%85%E6%97%B6%EF%BC%89">http://ubuntu.uestc.edu.cn/（无法访问，ping超时）</a><br>22.电子科技大学星辰工作室：<a href="http://mirrors.stuhome.net/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A1.08T%EF%BC%89">http://mirrors.stuhome.net/（当前已用容量估计：1.08T）</a><br>23.西北农林科技大学：<a href="http://mirrors.nwsuaf.edu.cn/%EF%BC%88%E5%8F%AA%E5%81%9ACentOS%E9%95%9C%E5%83%8F%EF%BC%8C%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A140GB%EF%BC%89">http://mirrors.nwsuaf.edu.cn/（只做CentOS镜像，当前已用容量估计：140GB）</a></p><h3 id="（三）、其他"><a href="#（三）、其他" class="headerlink" title="（三）、其他"></a>（三）、其他</h3><p>1.首都在线科技股份有限公司（英文名Capital Online Data Service）：<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a><br>2.中国电信天翼云：<a href="http://mirrors.ctyun.cn/">http://mirrors.ctyun.cn/</a><br><a href="http://3.noc.im/">3.noc.im</a>：<a href="http://mirrors.noc.im/%EF%BC%88%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A3.74T%EF%BC%89">http://mirrors.noc.im/（当前已用容量估计：3.74T）</a><br>4.常州贝特康姆软件技术有限公司：<a href="http://centos.bitcomm.cn/%EF%BC%88%E5%8F%AA%E5%81%9ACentOS%E9%95%9C%E5%83%8F%EF%BC%8C%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A140GB%EF%BC%89">http://centos.bitcomm.cn/（只做CentOS镜像，当前已用容量估计：140GB）</a><br>5.公云PubYun（母公司为贝特康姆）：<a href="http://mirrors.pubyun.com/">http://mirrors.pubyun.com/</a><br>6.Linux运维派：<a href="http://mirrors.skyshe.cn/%EF%BC%88%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E7%95%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%A8%A1%E6%9D%BF%EF%BC%8C%E9%A6%96%E9%A1%B5%E7%BB%B4%E6%8A%A4%EF%BC%8C%E5%86%85%E5%AE%B9%E5%8F%AF%E8%AE%BF%E9%97%AE%EF%BC%89">http://mirrors.skyshe.cn/（使用阿里云服务器，界面使用浙江大学的模板，首页维护，内容可访问）</a><br>7.中国互联网络信息中心：<a href="http://mirrors.cnnic.cn/%EF%BC%88%E5%8F%AA%E5%81%9AApache%E9%95%9C%E5%83%8F%EF%BC%8C%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A120GB%EF%BC%89">http://mirrors.cnnic.cn/（只做Apache镜像，当前已用容量估计：120GB）</a><br>8.Fayea工作室：<a href="http://apache.fayea.com/%EF%BC%88%E5%8F%AA%E5%81%9AApache%E9%95%9C%E5%83%8F%EF%BC%8C%E5%BD%93%E5%89%8D%E5%B7%B2%E7%94%A8%E5%AE%B9%E9%87%8F%E4%BC%B0%E8%AE%A1%EF%BC%9A120GB%EF%BC%89">http://apache.fayea.com/（只做Apache镜像，当前已用容量估计：120GB）</a></p><h2 id="二、软件版"><a href="#二、软件版" class="headerlink" title="二、软件版"></a>二、软件版</h2><h3 id="（一）、操作系统类"><a href="#（一）、操作系统类" class="headerlink" title="（一）、操作系统类"></a>（一）、操作系统类</h3><h4 id="1-Ubuntu"><a href="#1-Ubuntu" class="headerlink" title="1.Ubuntu"></a>1.Ubuntu</h4><p>阿里云：<a href="http://mirrors.aliyun.com/ubuntu-releases/">http://mirrors.aliyun.com/ubuntu-releases/</a><br>网易：<a href="http://mirrors.163.com/ubuntu-releases/">http://mirrors.163.com/ubuntu-releases/</a><br>搜狐：<a href="http://mirrors.sohu.com/ubuntu-releases/%EF%BC%88%E6%90%9C%E7%8B%90%E5%9C%A812%E5%B9%B4%E4%B9%8B%E5%90%8E%E4%BC%BC%E4%B9%8E%E4%B8%8D%E5%90%8C%E6%AD%A5%E4%BA%86%EF%BC%89">http://mirrors.sohu.com/ubuntu-releases/（搜狐在12年之后似乎不同步了）</a><br>首都在线科技股份有限公司：<a href="http://mirrors.yun-idc.com/ubuntu-releases/">http://mirrors.yun-idc.com/ubuntu-releases/</a></p><h4 id="2-centos"><a href="#2-centos" class="headerlink" title="2.centos"></a>2.centos</h4><p>网易：<a href="http://mirrors.163.com/centos/">http://mirrors.163.com/centos/</a><br>搜狐：<a href="http://mirrors.sohu.com/centos/">http://mirrors.sohu.com/centos/</a><br>阿里云：<a href="http://mirrors.aliyun.com/centos/">http://mirrors.aliyun.com/centos/</a></p><h3 id="（二）、服务器类"><a href="#（二）、服务器类" class="headerlink" title="（二）、服务器类"></a>（二）、服务器类</h3><p>1.tomcat、Apache<br>中国互联网络信息中心：<a href="http://mirrors.cnnic.cn/apache/">http://mirrors.cnnic.cn/apache/</a><br>华中科技大学：<a href="http://mirrors.hust.edu.cn/apache/">http://mirrors.hust.edu.cn/apache/</a><br>北京理工大学：<a href="http://mirror.bit.edu.cn/apache/">http://mirror.bit.edu.cn/apache/</a></p><p>2.MySQL<br>北京理工大学：<a href="http://mirror.bit.edu.cn/mysql/Downloads/">http://mirror.bit.edu.cn/mysql/Downloads/</a><br>中国电信天翼云：<a href="http://mirrors.ctyun.cn/Mysql/">http://mirrors.ctyun.cn/Mysql/</a></p><p>3.PostgreSQL<br>浙江大学：<a href="http://mirrors.zju.edu.cn/postgresql/">http://mirrors.zju.edu.cn/postgresql/</a></p><p>4.MariaDB<br>中国电信天翼云：<a href="http://mirrors.ctyun.cn/MariaDB/">http://mirrors.ctyun.cn/MariaDB/</a></p><p>5.VideoLAN<br>大连东软信息学院：<a href="http://mirrors.neusoft.edu.cn/videolan/">http://mirrors.neusoft.edu.cn/videolan/</a><br>中国科技大学：<a href="http://mirrors.ustc.edu.cn/videolan-ftp/">http://mirrors.ustc.edu.cn/videolan-ftp/</a></p><h3 id="（三）、开发工具类"><a href="#（三）、开发工具类" class="headerlink" title="（三）、开发工具类"></a>（三）、开发工具类</h3><p>1.eclipse<br>中国科技大学：<a href="http://mirrors.ustc.edu.cn/eclipse/">http://mirrors.ustc.edu.cn/eclipse/</a><br>中国科学院：<a href="http://mirrors.opencas.cn/eclipse/">http://mirrors.opencas.cn/eclipse/</a><br>东北大学：<a href="http://ftp.neu.edu.cn/mirrors/eclipse/%EF%BC%8Chttp://mirror.neu.edu.cn/eclipse/">http://ftp.neu.edu.cn/mirrors/eclipse/，http://mirror.neu.edu.cn/eclipse/</a></p><p>2.安卓SDK<br>中国科学院：<a href="http://mirrors.opencas.ac.cn/android/repository/">http://mirrors.opencas.ac.cn/android/repository/</a><br>南洋理工学院：<a href="http://mirror.nyist.edu.cn/android/repository/">http://mirror.nyist.edu.cn/android/repository/</a><br>中国科学院：<a href="http://mirrors.opencas.cn/android/repository/">http://mirrors.opencas.cn/android/repository/</a><br>腾讯：<a href="http://android-mirror.bugly.qq.com:8080/android/repository/%EF%BC%88%E9%99%90%E6%B5%81%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89">http://android-mirror.bugly.qq.com:8080/android/repository/（限流，不推荐）</a><br>大连东软信息学院：<a href="http://mirrors.neusoft.edu.cn/android/repository/%EF%BC%88%E5%90%8C%E6%AD%A5%E6%95%88%E6%9E%9C%E4%B8%8D%E5%A6%82%E4%B8%AD%E7%A7%91%E9%99%A2%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89">http://mirrors.neusoft.edu.cn/android/repository/（同步效果不如中科院的镜像，不推荐）</a></p><p>3.Xcode<br>腾讯：<a href="http://android-mirror.bugly.qq.com:8080/Xcode/%EF%BC%88%E4%BB%8E7.2%E4%B9%8B%E5%90%8E%E4%B8%8D%E5%86%8D%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%BB%BA%E8%AE%AE%E7%9B%B4%E6%8E%A5%E4%BB%8E%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%EF%BC%89">http://android-mirror.bugly.qq.com:8080/Xcode/（从7.2之后不再更新，建议直接从官网下载）</a></p><h2 id="三、官方镜像列表状态地址"><a href="#三、官方镜像列表状态地址" class="headerlink" title="三、官方镜像列表状态地址"></a>三、官方镜像列表状态地址</h2><p>CentOS：<a href="http://mirror-status.centos.org/#cn">http://mirror-status.centos.org/#cn</a><br>Archlinux：<a href="https://www.archlinux.org/mirrors/status/">https://www.archlinux.org/mirrors/status/</a><br>Ubuntu：<a href="https://launchpad.net/ubuntu/+cdmirrors">https://launchpad.net/ubuntu/+cdmirrors</a><br>Debian：<a href="http://mirror.debian.org/status.html">http://mirror.debian.org/status.html</a><br>Fedora Linux/Fedora EPEL：<a href="https://admin.fedoraproject.org/mirrormanager/mirrors">https://admin.fedoraproject.org/mirrormanager/mirrors</a><br>Apache：<a href="http://www.apache.org/mirrors/#cn">http://www.apache.org/mirrors/#cn</a></p><p>Cygwin：<a href="https://www.cygwin.com/mirrors.html">https://www.cygwin.com/mirrors.html</a></p><p>本文来源：各大开源软件、发行版镜像页面。<br>请注意这是一个总结，如果您自己搭建了一个小型开源镜像，这里并没有。以下列出的是包含大量不同镜像的站点。<br>具体配置中，我建议您使用大企业的镜像。大学的镜像有的只是内部使用，而且未必速度快的像您所期待的那样。同时，我建议您使用某些加速插 件，比如RHEL系列的yum-plugin-fastestmirror，apt-fast，axel，netselect-apt，apt-spy等 等。<br>如果您是教育网用户，若果本校没有源，请选择清华大学源来进行配置。毕竟教育网骨干在此。</p><h3 id="1-企业贡献："><a href="#1-企业贡献：" class="headerlink" title="1.企业贡献："></a>1.企业贡献：</h3><p>搜狐开源镜像站：<a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a><br>网易开源镜像站：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a></p><h3 id="2-大学教学："><a href="#2-大学教学：" class="headerlink" title="2.大学教学："></a>2.大学教学：</h3><p>北京理工大学：<br><a href="http://mirror.bit.edu.cn/">http://mirror.bit.edu.cn</a> (IPv4 only)<br><a href="http://mirror.bit6.edu.cn/">http://mirror.bit6.edu.cn</a> (IPv6 only)<br>北京交通大学：<br><a href="http://mirror.bjtu.edu.cn/">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br><a href="http://mirror6.bjtu.edu.cn/">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br><a href="http://debian.bjtu.edu.cn/">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)<br>兰州大学：<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a><br>厦门大学：<a href="http://mirrors.xmu.edu.cn/">http://mirrors.xmu.edu.cn/</a><br>上海交通大学：<br><a href="http://ftp.sjtu.edu.cn/">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br><a href="http://ftp6.sjtu.edu.cn/">http://ftp6.sjtu.edu.cn</a> (IPv6 only)<br>清华大学：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)<br>天津大学：<a href="http://mirror.tju.edu.cn/">http://mirror.tju.edu.cn/</a><br>中国科学技术大学：<br><a href="http://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors4.ustc.edu.cn/">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/">http://mirrors6.ustc.edu.cn/</a><br>西南大学：<a href="http://linux.swu.edu.cn/swudownload/Distributions/">http://linux.swu.edu.cn/swudownload/Distributions/</a><br>东北大学：<br><a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a> (IPv4 only)<br><a href="http://mirror.neu6.edu.cn/">http://mirror.neu6.edu.cn/</a> (IPv6 only)<br>电子科技大学：<a href="http://ubuntu.uestc.edu.cn/">http://ubuntu.uestc.edu.cn/</a><br>青岛大学：<a href="http://mirror.qdu.edu.cn/">http://mirror.qdu.edu.cn/</a><br>重庆大学：<a href="http://mirrors.cqu.edu.cn/">http://mirrors.cqu.edu.cn</a></p><p>编者：为给开发者们提供方便，我们收集了国内的开源站点，如果有错漏缺失之处，欢迎在文章下的评论中指出，我们会保持资料的更新！</p><h3 id="公司类"><a href="#公司类" class="headerlink" title="公司类"></a>公司类</h3><p>搜狐开源镜像站：<a href="http://mirrors.sohu.com/">http://mirrors.sohu.com/</a><br>网易开源镜像站：<a href="http://mirrors.163.com/">http://mirrors.163.com/</a><br>开源中国：<a href="http://mirrors.oschina.net/">http://mirrors.oschina.net/</a><br>首都在线科技股份有限公司：<a href="http://mirrors.yun-idc.com/">http://mirrors.yun-idc.com/</a><br>阿里云开源镜像：<a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com/</a><br>LUPA：<a href="http://mirror.lupaworld.com/">http://mirror.lupaworld.com/</a><br>常州贝特康姆软件技术有限公司(原cn99）：<a href="http://centos.bitcomm.cn/">http://centos.bitcomm.cn/</a><br>大学类<br>中山大学镜像：<a href="http://mirror.sysu.edu.cn/">http://mirror.sysu.edu.cn/</a><br>山东理工大学：<a href="http://mirrors.sdutlinux.org/">http://mirrors.sdutlinux.org/</a><br>哈尔滨工业大学：<a href="http://run.hit.edu.cn/">http://run.hit.edu.cn/</a><br>中国地质大学：<a href="http://cugbteam.org/">http://cugbteam.org/</a><br>大连理工大学：<a href="http://mirror.dlut.edu.cn/">http://mirror.dlut.edu.cn/</a><br>西南林业大学 <a href="http://cs3.swfu.edu.cn/cs3guide.html">http://cs3.swfu.edu.cn/cs3guide.html</a><br>北京化工大学（仅教育网可以访问），包含 CentOS 镜像：<a href="http://ubuntu.buct.edu.cn/">http://ubuntu.buct.edu.cn/</a><br>天津大学：<a href="http://mirror.tju.edu.cn/">http://mirror.tju.edu.cn/</a><br>西南大学：<a href="http://linux.swu.edu.cn/swudownload/Distributions/">http://linux.swu.edu.cn/swudownload/Distributions/</a><br>青岛大学：<a href="http://mirror.qdu.edu.cn/">http://mirror.qdu.edu.cn/</a><br>南京师范大学：<a href="http://mirrors.njnu.edu.cn/">http://mirrors.njnu.edu.cn/</a><br>大连东软信息学院： <a href="http://mirrors.neusoft.edu.cn/">http://mirrors.neusoft.edu.cn/</a><br>浙江大学：<a href="http://mirrors.zju.edu.cn/">http://mirrors.zju.edu.cn/</a><br>兰州大学：<a href="http://mirror.lzu.edu.cn/">http://mirror.lzu.edu.cn/</a><br>厦门大学：<a href="http://mirrors.xmu.edu.cn/">http://mirrors.xmu.edu.cn/</a><br>北京理工大学：<br><a href="http://mirror.bit.edu.cn/">http://mirror.bit.edu.cn</a> (IPv4 only)<br><a href="http://mirror.bit6.edu.cn/">http://mirror.bit6.edu.cn</a> (IPv6 only)<br>北京交通大学：<br><a href="http://mirror.bjtu.edu.cn/">http://mirror.bjtu.edu.cn</a> (IPv4 only)<br><a href="http://mirror6.bjtu.edu.cn/">http://mirror6.bjtu.edu.cn</a> (IPv6 only)<br><a href="http://debian.bjtu.edu.cn/">http://debian.bjtu.edu.cn</a> (IPv4+IPv6)<br>上海交通大学：<br><a href="http://ftp.sjtu.edu.cn/">http://ftp.sjtu.edu.cn/</a> (IPv4 only)<br><a href="http://ftp6.sjtu.edu.cn/">http://ftp6.sjtu.edu.cn</a> (IPv6 only)<br>清华大学：<br><a href="http://mirrors.tuna.tsinghua.edu.cn/">http://mirrors.tuna.tsinghua.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors.6.tuna.tsinghua.edu.cn/">http://mirrors.6.tuna.tsinghua.edu.cn/</a> (IPv6 only)<br><a href="http://mirrors.4.tuna.tsinghua.edu.cn/">http://mirrors.4.tuna.tsinghua.edu.cn/</a> (IPv4 only)<br>中国科学技术大学：<br><a href="http://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a> (IPv4+IPv6)<br><a href="http://mirrors4.ustc.edu.cn/">http://mirrors4.ustc.edu.cn/</a><br><a href="http://mirrors6.ustc.edu.cn/">http://mirrors6.ustc.edu.cn/</a><br>东北大学：<br><a href="http://mirror.neu.edu.cn/">http://mirror.neu.edu.cn/</a> (IPv4 only)<br><a href="http://mirror.neu6.edu.cn/">http://mirror.neu6.edu.cn/</a> (IPv6 only)<br>华中科技大学：<br><a href="http://mirrors.hust.edu.cn/">http://mirrors.hust.edu.cn/</a><br><a href="http://mirrors.hustunique.com/">http://mirrors.hustunique.com/</a><br>电子科技大学：<a href="http://ubuntu.uestc.edu.cn/">http://ubuntu.uestc.edu.cn/</a><br>电子科大凝聚工作室(Raspbian单一系统镜像) <a href="http://raspbian.cnssuestc.org/">http://raspbian.cnssuestc.org/</a><br>电子科大星辰工作室(少数小众发布版镜像) <a href="http://mirrors.stuhome.net/">http://mirrors.stuhome.net/</a><br>PyPi 镜像<br>豆瓣：<a href="http://pypi.douban.com/">http://pypi.douban.com/</a><br>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a><br>中山大学：<a href="http://mirror.sysu.edu.cn/pypi/">http://mirror.sysu.edu.cn/pypi/</a><br>V2EX：<a href="http://pypi.v2ex.com/simple/">http://pypi.v2ex.com/simple/</a><br>RubyGems 镜像<br>中山大学：<a href="http://mirror.sysu.edu.cn/rubygems/">http://mirror.sysu.edu.cn/rubygems/</a><br>山东理工大学：<a href="http://ruby.sdutlinux.org/">http://ruby.sdutlinux.org/</a><br>淘宝网：<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a><br>npm 镜像<br>cnpm：<a href="http://npm.taobao.org/">http://npm.taobao.org/</a></p>]]></content>
    
    <summary type="html">
    
      国内镜像源
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下安装maven</title>
    <link href="http://yoursite.com/2021/04/11/Linux%E4%B8%8B%E5%AE%89%E8%A3%85maven/"/>
    <id>http://yoursite.com/2021/04/11/Linux%E4%B8%8B%E5%AE%89%E8%A3%85maven/</id>
    <published>2021-04-11T09:43:00.000Z</published>
    <updated>2021-04-11T09:45:08.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下安装maven"><a href="#Linux下安装maven" class="headerlink" title="Linux下安装maven"></a>Linux下安装maven</h1><p><strong>阅读目录</strong></p><ul><li>1.准备工作</li><li>2.安装maven</li><li>3.配置maven私有库</li></ul><hr><p>Maven（mvn）是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具（百度百科）</p><p>简单理解为一个打包工具，其他的打包工具比如gradle也很火，常用于与jenkins等代码发布平台的联合代码发布</p><p>本文主要介绍linux下的maven的安装方法</p><p>============ 完美的分割线 =============</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>1）maven的安装运行以来Java环境，需要预先安装，具体Java安装方法可以参考我的另一篇博文：</p><p><a href="https://www.cnblogs.com/tssc/p/9691329.html">linux下yum安装jdk1.8（rpm包）和tomcat-8.5</a></p><p>2）maven软件包下载地址：</p><p><em><a href="https://mirrors.cnnic.cn/apache/maven/">https://mirrors.cnnic.cn/apache/maven/</a></em></p><p>3）本教程适用于以下系统环境<br>CentOS6.9_x64<br>CentOS7.5_x64</p><h2 id="2-安装maven"><a href="#2-安装maven" class="headerlink" title="2.安装maven"></a>2.安装maven</h2><p>1）下载软件包</p><p># 20180921最新安装包版本3.5.4，下载二进制包，解压即可使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;server&#x2F;tools</span><br><span class="line">cd &#x2F;server&#x2F;tools&#x2F;</span><br><span class="line">wget https:&#x2F;&#x2F;mirrors.cnnic.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.5.4&#x2F;binaries&#x2F;apache-maven-3.5.4-bin.tar.gz --no-check-certificate</span><br></pre></td></tr></table></figure><p>2）解压安装maven软件包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xf apache-maven-3.5.4-bin.tar.gz </span><br><span class="line">mv apache-maven-3.5.4 &#x2F;usr&#x2F;local&#x2F;maven</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;maven&#x2F;bin&#x2F;mvn  &#x2F;usr&#x2F;bin&#x2F;mvn　　　　# 与jenkins联合使用时，jenkins会到&#x2F;usr&#x2F;bin&#x2F;下找mvn命令，如果没有回报错</span><br><span class="line">ll &#x2F;usr&#x2F;local&#x2F;maven&#x2F;</span><br><span class="line">ll &#x2F;usr&#x2F;bin&#x2F;mvn</span><br></pre></td></tr></table></figure><p>3）配置环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot; &quot;&gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">echo &quot;# Made for mvn env by zhaoshuai on $(date +%F)&quot;&gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">echo &#39;export MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven&#39;&gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">echo &#39;export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH&#39;&gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line">tail -4 &#x2F;etc&#x2F;profile</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>4）查看安装的mvn版本号</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which mvn</span><br><span class="line">mvn -version</span><br></pre></td></tr></table></figure><p>最后可以看到以下结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@CentOS75 conf]# which mvn　　　　　　# 查看mvn工具的位置&#x2F;usr&#x2F;local&#x2F;maven&#x2F;bin&#x2F;mvn</span><br><span class="line">[root@CentOS75 conf]# mvn -version　　　　# 查看maven版本</span><br><span class="line">Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)</span><br><span class="line">Maven home: &#x2F;usr&#x2F;local&#x2F;maven</span><br><span class="line">Java version: 1.8.0_181, vendor: Oracle Corporation, runtime: &#x2F;usr&#x2F;java&#x2F;jdk1.8.0_181-amd64&#x2F;jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;3.10.0-862.11.6.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure><p>至此maven安装完成，可以使用mvn工具打包代码。</p><p>在首次使用mvn工具时会到maven.apache.org下载相关依赖包，不过速度较慢，<br>一般我们会设置私有库，比如使用nexus安装私有库提供依赖包，这部分需要和开发人员合作进行配置，本文暂略</p><h2 id="3-配置maven私有库"><a href="#3-配置maven私有库" class="headerlink" title="3.配置maven私有库"></a>3.配置maven私有库</h2><p># 编辑maven配置文件修改私有库的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;maven&#x2F;conf&#x2F;</span><br><span class="line">cp settings.xml settings.xml.ori</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;maven&#x2F;conf&#x2F;settings.xml</span><br><span class="line">--------- setting标签里设置本地仓库的存储位置 ----------</span><br><span class="line">  &lt;localRepository&gt;&#x2F;usr&#x2F;local&#x2F;maven&#x2F;mavenlib&lt;&#x2F;localRepository&gt;        </span><br><span class="line">---------- mirror标签里配置Maven 镜像地址 --------------</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;nexus&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">      &lt;name&gt;mynexus&lt;&#x2F;name&gt;</span><br><span class="line">      &lt;url&gt;http:&#x2F;&#x2F;192.168.1.9:18081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">    &lt;&#x2F;mirror&gt;</span><br><span class="line">------------------- 配置私服地址  ---------------------</span><br><span class="line">     &lt;profile&gt;</span><br><span class="line">       &lt;id&gt;nexus&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;repositories&gt;</span><br><span class="line">         &lt;repository&gt;</span><br><span class="line">           &lt;id&gt;nexus&lt;&#x2F;id&gt;</span><br><span class="line">                &lt;name&gt;Nexus&lt;&#x2F;name&gt;</span><br><span class="line">           &lt;url&gt;http:&#x2F;&#x2F;192.168.1.9:18081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">           &lt;releases&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt;</span><br><span class="line">           &lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt;</span><br><span class="line">         &lt;&#x2F;repository&gt;</span><br><span class="line">       &lt;&#x2F;repositories&gt;</span><br><span class="line">       &lt;pluginRepositories&gt;</span><br><span class="line">         &lt;pluginRepository&gt;</span><br><span class="line">           &lt;id&gt;nexus&lt;&#x2F;id&gt;</span><br><span class="line">             &lt;name&gt;Nexus&lt;&#x2F;name&gt;</span><br><span class="line">             &lt;url&gt;http:&#x2F;&#x2F;192.168.1.9:18081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">             &lt;releases&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt;</span><br><span class="line">             &lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt;</span><br><span class="line">         &lt;&#x2F;pluginRepository&gt;</span><br><span class="line">       &lt;&#x2F;pluginRepositories&gt;</span><br><span class="line">     &lt;&#x2F;profile&gt;</span><br><span class="line">------------------------------------------------</span><br></pre></td></tr></table></figure><p>代码里面有很多东西是需要拉去依赖包，这些依赖包就存放在本地的私有仓库里(Nexus)</p>]]></content>
    
    <summary type="html">
    
      Linux下安装maven
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置语法详解</title>
    <link href="http://yoursite.com/2021/01/11/Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/01/11/Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-01-11T11:57:00.000Z</published>
    <updated>2021-01-14T12:11:07.065Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jasonhzy.github.io/2016/08/25/nginx-alias-root/">https://jasonhzy.github.io/2016/08/25/nginx-alias-root/</a></p><p><a href="http://blog.csdn.net/21aspnet/article/details/6583335">http://blog.csdn.net/21aspnet/article/details/6583335</a></p><p>nginx指定文件路径有两种方式root和alias，root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。</p><h1 id="最基本的区别"><a href="#最基本的区别" class="headerlink" title="最基本的区别"></a>最基本的区别</h1><p><strong>alias 指定的目录是准确的，给location指定一个目录。</strong><br><strong>root 指定目录的上级目录，并且该上级目录要含有locatoin指定名称的同名目录</strong>。<br>以root方式设置资源路径：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法: root path;</span><br><span class="line">配置块: http、server、location、if</span><br></pre></td></tr></table></figure><p>以alias 方式设置资源路径</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">语法: alias path;</span><br><span class="line">配置块: location</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> /img/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /var/www/image/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#若按照上述配置的话，则访问/img/目录里面的文件时，ningx会自动去/var/www/image/目录找文件</span></span><br><span class="line"><span class="attribute">location</span> /img/ &#123;</span><br><span class="line">    <span class="attribute">root</span> /var/www/image;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#若按照这种配置的话，则访问/img/目录下的文件时，nginx会去/var/www/image/img/目录下找文件</span></span><br></pre></td></tr></table></figure><p>注意： </p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.使用alias时，目录名后面一定要加”/“。</span><br><span class="line">2.使用alias标签的目录块中不能使用rewrite的break。</span><br><span class="line">3.alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</span><br><span class="line">4.alias只能位于location块中</span><br></pre></td></tr></table></figure><p>nginx貌似没有虚拟目录的说法，因为它本来就是完完全全根据目录来设计并工作的。</p><p>如果非要给nginx安上一个虚拟目录的说法，那就只有alias标签比较“像”，干脆来说说alias标签和root标签的区别吧。</p><p>最基本的区别：alias指定的目录是准确的，root是指定目录的上级目录，并且该上级目录要含有location指定名称的同名目录。另外，根据前文所述，使用alias标签的目录块中不能使用rewrite的break。</p><p>所以使用nginx设置root时要注意一个问题，就是如果该root设置的前端目录不是根目录，那么在写root的绝对地址时，要把前端目录的部分省略掉。<br>我们用设置虚拟目录指向的alias来和root比较一下就非常明显了</p><p>location /abc/ {   alias /home/html/abc/; }  </p><p>在这段配置下，<a href="http://test/abc/a.html">http://test/abc/a.html</a> 就指定的是 /home/html/abc/a.html。这段配置亦可改成</p><p>location /abc/ {   root /home/html/;}  </p><p>可以看到，使用root设置目录的绝对路径时，少了/abc,也就是说，使用root来设置前端非根目录时，nginx会组合root和location的路径,即 /home/html/abc/。</p><p><strong>另外，使用alias时目录名后面一定要加“/”</strong></p><p>nginx的安装配置三部曲：点击即可查看</p><p><a href="https://blog.csdn.net/qq_33862644/article/details/80146508">1、安装和配置文件的基础配置，ctrl+f搜索nginx</a></p><p><a href="https://blog.csdn.net/qq_33862644/article/details/79337348">2、nginx文档如何查看 + 常用的配置方式（伪静态，反向代理，动静分离，防盗链，图片缓存，gzip图片压缩）</a></p><p><a href="https://blog.csdn.net/qq_33862644/article/details/79361487">3、高级配置-》负载均衡</a></p><p>-——————–</p><p><strong>server_name _; #不启用域名</strong></p><h1 id="指令-热启动"><a href="#指令-热启动" class="headerlink" title="指令-热启动"></a>指令-热启动</h1><p>Nginx重新读取配置的命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="看文档的方法"><a href="#看文档的方法" class="headerlink" title="看文档的方法"></a>看文档的方法</h2><p>gzip压缩文件模块的使用：</p><p><img src="https://img-blog.csdn.net/20180430173716479?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>参考：nginx官方文档-》<strong>Modules reference-》</strong><a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">ngx_http_gzip_module</a></p><p><img src="https://img-blog.csdn.net/20180430173202408?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h1 id="nginx配置文件语法详解"><a href="#nginx配置文件语法详解" class="headerlink" title="nginx配置文件语法详解"></a>nginx配置文件语法详解</h1><p>语法规则： <code>location [=|~|~*|^~] /uri/ &#123; … &#125;</code></p><ul><li><code>=</code> 开头表示精确匹配</li><li><code>^~</code> 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。以xx开头</li><li><code>~</code> 开头表示区分大小写的正则匹配           以xx结尾</li><li><code>~*</code> 开头表示不区分大小写的正则匹配        以xx结尾</li><li><code>!~</code>和<code>!~*</code>分别为区分大小写不匹配及不区分大小写不匹配 的正则</li><li><code>/</code> 通用匹配，任何请求都会匹配到。</li></ul><p>多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：</p><p><img src="https://img-blog.csdn.net/20180219195126400?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzM4NjI2NDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>首先精确匹配 =-》其次以xx开头匹配^~-》然后是按文件中顺序的正则匹配-》最后是交给 / 通用匹配。</p><p>当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p><p>例子，有如下匹配规则：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">   <span class="comment">#规则A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> = /login &#123;</span><br><span class="line">   <span class="comment">#规则B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /static/ &#123;</span><br><span class="line">   <span class="comment">#规则C</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.(gif|jpg|png|js|css)$</span> &#123;</span><br><span class="line">   <span class="comment">#规则D，注意：是根据括号内的大小写进行匹配。括号内全是小写，只匹配小写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.png$</span> &#123;</span><br><span class="line">   <span class="comment">#规则E</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> !<span class="regexp">~ \.xhtml$</span> &#123;</span><br><span class="line">   <span class="comment">#规则F</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> !<span class="regexp">~* \.xhtml$</span> &#123;</span><br><span class="line">   <span class="comment">#规则G</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="comment">#规则H</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么产生的效果如下：</p><p>访问根目录/， 比如<a href="http://localhost/">http://localhost/</a> 将匹配规则A</p><p>访问 <a href="http://localhost/login">http://localhost/login</a> 将匹配规则B，<a href="http://localhost/register">http://localhost/register</a> 则匹配规则H</p><p>访问 <a href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则C</p><p>访问 <a href="http://localhost/a.gif">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用， 而 <a href="http://localhost/static/c.png">http://localhost/static/c.png</a> 则优先匹配到 规则C</p><p>访问 <a href="http://localhost/a.PNG">http://localhost/a.PNG</a> 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</p><p>访问 <a href="http://localhost/a.xhtml">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，</p><p><a href="http://localhost/a.XHTML%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99G%EF%BC%8C%EF%BC%88%E5%9B%A0%E4%B8%BA!%EF%BC%89%E3%80%82%E8%A7%84%E5%88%99F%EF%BC%8C%E8%A7%84%E5%88%99G%E5%B1%9E%E4%BA%8E%E6%8E%92%E9%99%A4%E6%B3%95%EF%BC%8C%E7%AC%A6%E5%90%88%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E4%B9%9F%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%83%B3%E6%83%B3%E7%9C%8B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E3%80%82">http://localhost/a.XHTML不会匹配规则G，（因为!）。规则F，规则G属于排除法，符合匹配规则也不会匹配到，所以想想看实际应用中哪里会用到。</a></p><p>访问 <a href="http://localhost/category/id/1111">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</p><p>所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span></span><br><span class="line"><span class="comment">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span></span><br><span class="line"><span class="comment"># 第一个必选规则</span></span><br><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat:8080/index</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span></span><br><span class="line"><span class="comment"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span></span><br><span class="line">location ^~ /static/ &#123;                              //以xx开头</span><br><span class="line">    <span class="attribute">root</span> /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;     //以xx结尾</span><br><span class="line">    <span class="attribute">root</span> /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span></span><br><span class="line"><span class="comment">#非静态文件请求就默认是动态请求，自己根据实际把握</span></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://tomcat:8080/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx的其他配置信息介绍</strong></p><p>三、ReWrite语法</p><p><code>last</code> – 基本上都用这个Flag。<br><code>break</code> – 中止Rewirte，不在继续匹配<br><code>redirect</code> – 返回临时重定向的HTTP状态302<br><code>permanent</code> – 返回永久重定向的HTTP状态301</p><p>1、下面是可以用来判断的表达式：</p><p><code>-f</code>和<code>!-f</code>用来判断是否存在文件<br><code>-d</code>和<code>!-d</code>用来判断是否存在目录<br><code>-e</code>和<code>!-e</code>用来判断是否存在文件或目录<br><code>-x</code>和<code>!-x</code>用来判断文件是否可执行</p><p>2、下面是可以用作判断的全局变量</p><p>例：<a href="http://localhost:88/test1/test2/test.php">http://localhost:88/test1/test2/test.php</a></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">$host：localhost</span></span><br><span class="line"><span class="attr">$server_port：88</span></span><br><span class="line"><span class="meta">$request_uri：http</span>:<span class="string">//localhost:88/test1/test2/test.php</span></span><br><span class="line"><span class="attr">$document_uri：/test1/test2/test.php</span></span><br><span class="line"><span class="meta">$document_root：D</span>:<span class="string">\nginx/html</span></span><br><span class="line"><span class="meta">$request_filename：D</span>:<span class="string">\nginx/html/test1/test2/test.php</span></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><p>附：一些可用的全局变量</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$args</span><br><span class="line">$content_length</span><br><span class="line">$content_type</span><br><span class="line">$document_root</span><br><span class="line">$document_uri</span><br><span class="line">$host</span><br><span class="line">$http_user_agent</span><br><span class="line">$http_cookie</span><br><span class="line">$limit_rate</span><br><span class="line">$request_body_file</span><br><span class="line">$request_method</span><br><span class="line">$remote_addr</span><br><span class="line">$remote_port</span><br><span class="line">$remote_user</span><br><span class="line">$request_filename</span><br><span class="line">$request_uri</span><br><span class="line">$query</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="一些常用的配置"><a href="#一些常用的配置" class="headerlink" title="一些常用的配置"></a>一些常用的配置</h2><p>1、普通的（静态的）http服务器</p><p>这样如果访问<a href="http://localhost/">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;                                                         </span><br><span class="line">    <span class="attribute">server_name</span>  localhost;                                               </span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1024M</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> / &#123;                </span><br><span class="line">           root   e:wwwroot;            //思路：通过/将所有的请求，转发给root处理</span><br><span class="line">           <span class="attribute">index</span>  index.html;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、反向代理</p><p>localhost的时候，就相当于访问localhost:8080了</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;                                                         </span><br><span class="line">    <span class="attribute">server_name</span>  localhost;                                               </span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">1024M</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;   </span><br><span class="line">        proxy_set_header Host $host:$server_port;    //思路：通过/，将所有的请求，转发给第3方处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然服务器可以直接HTTP访问，为什么要在中间加上一个反向代理，不是多此一举吗？反向代理有什么作用？</p><p>负载均衡、虚拟主机等，都基于反向代理实现，当然反向代理的功能也不仅仅是这些。</p><p>3、Redirect（重定向）语法</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> start.igrow.cn;</span><br><span class="line">    <span class="attribute">index</span> index.html index.php;</span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$http_host</span> !<span class="regexp">~ &quot;^star\.igrow\.cn$&quot;</span> &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)</span> http://star.igrow.cn<span class="variable">$1</span> <span class="literal">redirect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、防盗链</p><p><img src="https://img-blog.csdn.net/20180430183342452?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|png|bmp)$</span> &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> <span class="regexp">*.ttlsa.com</span> server_names ~\.google\. ~\.baidu\.;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">        <span class="comment">#rewrite ^/ http://www.ttlsa.com/403.jpg;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、根据文件类型设置过期时间</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(js|css|jpg|jpeg|gif|png|swf)$</span> &#123;</span><br><span class="line">    if (-f $request_filename) &#123;     //只能是文件，因为这用-f判断了</span><br><span class="line">        <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、设置图片缓存（过期）时间</p><p><img src="https://img-blog.csdn.net/2018043017361175?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://img-blog.csdn.net/2018043017365450?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="https://img-blog.csdn.net/20180430172208766?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>7、禁止访问某个目录</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(txt|doc)<span class="variable">$&#123;</span></span></span><br><span class="line"><span class="regexp"><span class="variable">    root /data/www/wwwroot/linuxtone/test;  #所有用户都禁止访问这个目录</span></span></span><br><span class="line"><span class="regexp"><span class="variable">    deny all;</span></span></span><br><span class="line"><span class="regexp"><span class="variable">&#125;</span></span></span><br></pre></td></tr></table></figure><p>8、隐藏版本号的作用</p><p>通过你所用的版本，找其漏洞，进行攻击你</p><p>在http中添加该配置：server_tokens off;</p><p><img src="https://img-blog.csdn.net/20180430174525349?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>9、配置https</p><p><img src="https://img-blog.csdn.net/20180520125654199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzODYyNjQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>1、去阿里云/腾讯云申请免费的</p><p>2、下载证书</p><p>3、证书放到/usr/local/nginx目录下（就是和conf同级，nginx.conf默认的配置文件的上一级）</p><p>4、在vhost目录下加入配置文件</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"> <span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line"> <span class="attribute">server_name</span> lampol.edu0532.cn; <span class="comment">#改域名</span></span><br><span class="line"> <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"> <span class="attribute">root</span> /home/www/xcxtp5/public; <span class="comment">#改项目路径</span></span><br><span class="line"> <span class="attribute">ssl_certificate</span> ../certbo/<span class="number">1523694051089</span>.pem;    <span class="comment">#改证书路径</span></span><br><span class="line"> <span class="attribute">ssl_certificate_key</span> ../certbo/<span class="number">1523694051089</span>.key; <span class="comment">#改私钥路径</span></span><br><span class="line"> <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line"> <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line"> <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"> <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm index.php;</span><br><span class="line">            <span class="attribute">autoindex</span>  <span class="literal">on</span>;</span><br><span class="line">            <span class="comment"># 伪静态配置  </span></span><br><span class="line">            <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">                <span class="attribute">rewrite</span> <span class="regexp"> ^(.*)$</span>  /index.php?s=<span class="variable">$1</span>  <span class="literal">last</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">            <span class="attribute">include</span>        fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10、动静分离</p><p>思路：动、静态的文件，请求时匹配不同的目录</p><p>当访问gif,jpeg时 直接访问<code>e:wwwroot;</code>,正则自行配置</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;  </span><br><span class="line">  <span class="attribute">server_name</span>  localhost;  </span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;  </span><br><span class="line">      <span class="attribute">root</span>   e:wwwroot;  </span><br><span class="line">      <span class="attribute">index</span>  index.html;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 所有静态请求都由nginx处理，存放目录为html  </span></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ .(gif|jpg|jpeg|png|bmp|swf|css|js)$</span> &#123;  </span><br><span class="line">      <span class="attribute">root</span>    e:wwwroot;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment"># 所有动态请求都转发给tomcat处理  </span></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ .(jsp|do)$</span> &#123;  </span><br><span class="line">      <span class="attribute">proxy_pass</span>  http://test;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;  </span><br><span class="line">  <span class="attribute">location</span> = /50x.html &#123;  </span><br><span class="line">      <span class="attribute">root</span>   e:wwwroot;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>参考：nginx官方文档-》<strong>Modules reference-》<a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">ngx_http_upstream_module</a></strong></p><p><a href="https://blog.csdn.net/qq_33862644/article/details/79361487">请点击参考我这篇博客</a></p>]]></content>
    
    <summary type="html">
    
      Nginx配置语法详解
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Linux/Nginx/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>配置多版本JDK</title>
    <link href="http://yoursite.com/2020/12/19/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%89%88%E6%9C%ACJDK/"/>
    <id>http://yoursite.com/2020/12/19/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%89%88%E6%9C%ACJDK/</id>
    <published>2020-12-19T08:17:00.000Z</published>
    <updated>2020-12-19T08:17:49.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置多版本JDK"><a href="#配置多版本JDK" class="headerlink" title="配置多版本JDK"></a>配置多版本JDK</h1><p><img src="/2020/12/19/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%89%88%E6%9C%ACJDK/Users\13470\AppData\Roaming\Typora\typora-user-images\image-20201219161301343.png" alt="image-20201219161301343"></p><p>安装完多个版本的jdk之后, 会在系统环境变量–path下, 出现这两个目录</p><p>目录里存放着</p><p><img src="/2020/12/19/%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%89%88%E6%9C%ACJDK/Users\13470\AppData\Roaming\Typora\typora-user-images\image-20201219161410482.png" alt="image-20201219161410482"></p><p>现在最新的jdk1.8u221安装直接生成了path：C:\Program Files (x86)\Common Files\Oracle\Java\javapath 不用删除原来的jdk12或11，</p><p>要记住这两个目录分别存放这哪个版本的jdk, 如果要实现2个jdk的切换，直接把另外一个jdk的path上移动到首个就行了</p><p><strong>原因：由于在WINDOWS\System32环境变量中的优先级高于JAVA_HOME设置的环境变量优先级，故如果只修改环境变量\</strong>JAVA_HOME，jdk的版本并不会切换。****</p>]]></content>
    
    <summary type="html">
    
      配置多版本JDK
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Linux保存git密码</title>
    <link href="http://yoursite.com/2020/12/09/%E8%BD%AC%E8%BD%BD-Linux%E4%BF%9D%E5%AD%98git%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2020/12/09/%E8%BD%AC%E8%BD%BD-Linux%E4%BF%9D%E5%AD%98git%E5%AF%86%E7%A0%81/</id>
    <published>2020-12-09T01:55:00.000Z</published>
    <updated>2021-04-11T09:42:17.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux保存git密码"><a href="#Linux保存git密码" class="headerlink" title="Linux保存git密码"></a>Linux保存git密码</h1><p>Linux下命令行使用git，每次操作都要输入用户名和密码很麻烦，可以通过配置保存用户名和密码。</p><p>进入到git项目的根目录下，打开<code>.git</code>目录下的<code>config</code>文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注意 .git必须在项目所在的.git目录下</span><br><span class="line">cd .git</span><br><span class="line">vim config</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential]</span><br><span class="line">        helper &#x3D; store</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>:wq</code>保存退出<br><img src="https://img-blog.csdnimg.cn/20190305221643696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行上述操作之后，进行git操作时输入一次用户名和密码即可保存下来，以后不再需要重复输入。</p>]]></content>
    
    <summary type="html">
    
      Linux保存git密码
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Git" scheme="http://yoursite.com/categories/Linux/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>转载–Nginx基本功能及其原理</title>
    <link href="http://yoursite.com/2020/12/07/%E8%BD%AC%E8%BD%BD%E2%80%93Nginx%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/12/07/%E8%BD%AC%E8%BD%BD%E2%80%93Nginx%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-07T02:50:00.000Z</published>
    <updated>2020-12-09T14:41:58.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转载–Nginx基本功能及其原理"><a href="#转载–Nginx基本功能及其原理" class="headerlink" title="转载–Nginx基本功能及其原理"></a>转载–Nginx基本功能及其原理</h1><h2 id="一、什么是正向代理和反向代理："><a href="#一、什么是正向代理和反向代理：" class="headerlink" title="一、什么是正向代理和反向代理："></a><strong>一、什么是正向代理和反向代理：</strong></h2><p>A同学在大众创业的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是<strong>代理</strong>，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。</p><p>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com/">http://www.google.com</a> 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求<a href="http://google.com/">google.com</a>，代理把请求返回的相应结构再返回给我。</p><p><img src="https://upload-images.jianshu.io/upload_images/15076797-bde7a6ba208db6d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/355/format/webp" alt="img"></p><p>图1.1： 正向代理示意图</p><p>大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理。客户不知道真正提供服务人的是谁。反向代理隐藏了真实的服务端，当我们请求<a href="http://ww.baidu.com/">ww.baidu.com</a> 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，<a href="http://www.baidu.com/">www.baidu.com</a> 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。<strong>Nginx就是性能非常好的反向代理服务器，用来做负载均衡。</strong></p><p>两者的区别在于代理的对象不一样：  正向代理是为客户端代理，反向代理是为服务端代理。</p><p><img src="https://upload-images.jianshu.io/upload_images/15076797-836fda4f21d1575b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/263/format/webp" alt="img"></p><p>图1.2： 反向代理示意图</p><p>nginx能实现负载均衡，什么是负载均衡呢？就是我的项目部署在不同的服务器上，但是通过统一的域名进入，nginx则对请求进行分发，减轻了服务器的压力。</p><p>在上面这两种情况下，nginx服务器的作用都只是作为分发服务器，真正的内容，我们可以放在其他的服务器上，这样来，还能起到一层安全隔壁的作用，nginx作为隔离层。</p><p>其次，nginx还能解决跨域的问题。</p><h2 id="二、Nginx配置文件的整体结构"><a href="#二、Nginx配置文件的整体结构" class="headerlink" title="二、Nginx配置文件的整体结构"></a><strong>二、Nginx配置文件的整体结构</strong></h2><p><img src="https://upload-images.jianshu.io/upload_images/15076797-4c76f4a450116a67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/426/format/webp" alt="img"></p><p>图2.1： nginx配置文件的整体结构</p><h3 id="1-从图中可以看出主要包含以下几大部分内容："><a href="#1-从图中可以看出主要包含以下几大部分内容：" class="headerlink" title="1. 从图中可以看出主要包含以下几大部分内容："></a>1. 从图中可以看出主要包含以下几大部分内容：</h3><ul><li><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3></li></ul><p>该部分配置主要影响Nginx全局，通常包括下面几个部分：</p><p>配置运行Nginx服务器用户（组）<br> worker process数<br> Nginx进程PID存放路径<br> 错误日志的存放路径<br> 配置文件的引入</p><ul><li><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3></li></ul><p>该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：</p><p>设置网络连接的序列化<br> 是否允许同时接收多个网络连接<br> 事件驱动模型的选择<br> 最大连接数的配置</p><ul><li><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3></li></ul><p>定义MIMI-Type<br> 自定义服务日志<br> 允许sendfile方式传输文件<br> 连接超时时间<br> 单连接请求数上限</p><ul><li><h3 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h3></li></ul><p>配置网络监听<br> 基于名称的虚拟主机配置<br> 基于IP的虚拟主机配置</p><ul><li><h3 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h3></li></ul><p>location配置<br> 请求根目录配置<br> 更改location的URI<br> 网站默认首页配置</p><h3 id="2-一份配置清单例析"><a href="#2-一份配置清单例析" class="headerlink" title="2. 一份配置清单例析"></a>2. 一份配置清单例析</h3><p>按照前面文章，给出一份简要的清单配置举例：</p><p><img src="https://upload-images.jianshu.io/upload_images/15076797-31fe6a33fd2fcaf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/615/format/webp" alt="img"></p><p>图2.1：nginx配置举例</p><h3 id="3-配置运行Nginx服务器用户（组）"><a href="#3-配置运行Nginx服务器用户（组）" class="headerlink" title="3. 配置运行Nginx服务器用户（组）"></a>3. 配置运行Nginx服务器用户（组）</h3><p>指令格式：user user [group];</p><p>user：指定可以运行Nginx服务器的用户</p><p>group：可选项，可以运行Nginx服务器的用户组</p><p>如果user指令不配置或者配置为 user nobody nobody ，则默认所有用户都可以启动Nginx进程</p><h3 id="4-worker-process数配置"><a href="#4-worker-process数配置" class="headerlink" title="4. worker_process数配置"></a>4. worker_process数配置</h3><p>Nginx服务器实现并发处理服务的关键，指令格式：worker_processes number | auto;</p><p>number：Nginx进程最多可以产生的worker process数</p><p>auto：Nginx进程将自动检测</p><p>按照上文中的配置清单的实验，我们给worker_processes配置的数目是：3，启动Nginx服务器后，我们可以后台看一下主机上的Nginx进程情况：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux | grep nginx</span><br></pre></td></tr></table></figure><p>很明显，理解 worker_processes 这个指令的含义就很容易了</p><p><img src="https://upload-images.jianshu.io/upload_images/15076797-039c8d1ac24d23d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/645/format/webp" alt="img"></p><p>图2.2：查看nginx进程情况</p><h3 id="5-Nginx进程PID存放路径"><a href="#5-Nginx进程PID存放路径" class="headerlink" title="5. Nginx进程PID存放路径"></a>5. Nginx进程PID存放路径</h3><p>Nginx进程是作为系统守护进程在运行，需要在某文件中保存当前运行程序的主进程号，Nginx支持该保存文件路径的自定义</p><p>指令格式：pid file;</p><p>file：指定存放路径和文件名称</p><p>如果不指定默认置于路径 logs/nginx.pid</p><h3 id="6-错误日志的存放路径"><a href="#6-错误日志的存放路径" class="headerlink" title="6. 错误日志的存放路径"></a>6. 错误日志的存放路径</h3><p>指定格式：error_log file | stderr;</p><p>file：日志输出到某个文件file</p><p>stderr：日志输出到标准错误输出</p><h3 id="7-配置文件的引入"><a href="#7-配置文件的引入" class="headerlink" title="7. 配置文件的引入"></a><strong>7. 配置文件的引入</strong></h3><p>指令格式：include file;</p><p>该指令主要用于将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中</p><h3 id="8-设置网络连接的序列化"><a href="#8-设置网络连接的序列化" class="headerlink" title="8. 设置网络连接的序列化"></a><strong>8. 设置网络连接的序列化</strong></h3><p>指令格式：accept_mutex on | off;</p><p>该指令默认为on状态，表示会对多个Nginx进程接收连接进行序列化，防止多个进程对连接的争抢。</p><p>说到该指令，首先得阐述一下什么是所谓的”惊群问题”，可以参考 <a href="https://en.wikipedia.org/wiki/Thundering_herd_problem">WIKI百科的解释</a>。就Nginx的场景来解释的话大致的意思就是：当一个新网络连接来到时，多个worker进程会被同时唤醒，但仅仅只有一个进程可以真正获得连接并处理之。如果每次唤醒的进程数目过多的话，其实是会影响一部分性能的。</p><p>所以在这里，如果accept_mutex on，那么多个worker将是以串行方式来处理，其中有一个worker会被唤醒；反之若accept_mutex off，那么所有的worker都会被唤醒，不过只有一个worker能获取新连接，其它的worker会重新进入休眠状态</p><p>这个值的开关与否其实是要和具体场景挂钩的。</p><h3 id="9-是否允许同时接收多个网络连接"><a href="#9-是否允许同时接收多个网络连接" class="headerlink" title="9. 是否允许同时接收多个网络连接"></a><strong>9. 是否允许同时接收多个网络连接</strong></h3><p>指令格式：multi_accept on | off;</p><p>该指令默认为off状态，意指每个worker process 一次只能接收一个新到达的网络连接。若想让每个Nginx的worker process都有能力同时接收多个网络连接，则需要开启此配置</p><h3 id="10-事件驱动模型的选择"><a href="#10-事件驱动模型的选择" class="headerlink" title="10. 事件驱动模型的选择"></a><strong>10. 事件驱动模型的选择</strong></h3><p>指令格式：use model;</p><p>model模型可选择项包括：select、poll、kqueue、epoll、rtsig等……</p><h3 id="11-最大连接数的配置"><a href="#11-最大连接数的配置" class="headerlink" title="11. 最大连接数的配置"></a><strong>11. 最大连接数的配置</strong></h3><p>指令格式：worker_connections number;</p><p>number默认值为512，表示允许每一个worker process可以同时开启的最大连接数</p><h3 id="12-定义MIME-Type"><a href="#12-定义MIME-Type" class="headerlink" title="12. 定义MIME-Type"></a><strong>12. 定义MIME-Type</strong></h3><p>指令格式：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">include mime.types;default_type mime-<span class="class"><span class="keyword">type</span>;</span></span><br></pre></td></tr></table></figure><p>MIME-Type指的是网络资源的媒体类型，也即前端请求的资源类型</p><p>include指令将mime.types文件包含进来</p><p>cat mime.types 来查看mime.types文件内容，我们发现其就是一个types结构，里面包含了各种浏览器能够识别的MIME类型以及对应类型的文件后缀名字，如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/15076797-a982a324d2da3bf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/591/format/webp" alt="img"></p><h3 id="13-自定义服务日志"><a href="#13-自定义服务日志" class="headerlink" title="13. 自定义服务日志"></a><strong>13. 自定义服务日志</strong></h3><p>指令格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">access_log</span> <span class="selector-tag">path</span> <span class="selector-attr">[format]</span>;</span><br></pre></td></tr></table></figure><p>path：自定义服务日志的路径 + 名称</p><p>format：可选项，自定义服务日志的字符串格式。其也可以使用 log_format 定义的格式</p><h3 id="14-允许sendfile方式传输文件"><a href="#14-允许sendfile方式传输文件" class="headerlink" title="14. 允许sendfile方式传输文件"></a><strong>14. 允许sendfile方式传输文件</strong></h3><p>指令格式：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sendfile <span class="keyword">on</span> | off;sendfile_max_chunk size;</span><br></pre></td></tr></table></figure><p>前者用于开启或关闭使用sendfile()传输文件，默认off</p><p>后者指令若size&gt;0，则Nginx进程的每个worker process每次调用sendfile()传输的数据了最大不能超出此值；若size=0则表示不限制。默认值为0</p><h3 id="15-连接超时时间配置"><a href="#15-连接超时时间配置" class="headerlink" title="15. 连接超时时间配置"></a><strong>15. 连接超时时间配置</strong></h3><p>指令格式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">keepalive_timeout</span> <span class="selector-tag">timeout</span> <span class="selector-attr">[header_timeout]</span>;</span><br></pre></td></tr></table></figure><p>timeout 表示server端对连接的保持时间，默认75秒</p><p>header_timeout 为可选项，表示在应答报文头部的 Keep-Alive 域设置超时时间：”Keep-Alive : timeout = header_timeout”</p><h3 id="16-单连接请求数上限"><a href="#16-单连接请求数上限" class="headerlink" title="16. 单连接请求数上限"></a><strong>16. 单连接请求数上限</strong></h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepalive_requests number;</span><br></pre></td></tr></table></figure><p>该指令用于限制用户通过某一个连接向Nginx服务器发起请求的次数</p><h3 id="17-配置网络监听"><a href="#17-配置网络监听" class="headerlink" title="17. 配置网络监听"></a><strong>17. 配置网络监听</strong></h3><p>指令格式：</p><p>第一种：配置监听的IP地址：listen IP[:PORT];</p><p>第二种：配置监听的端口：listen PORT;</p><p>实际举例：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">listen</span> 192<span class="selector-class">.168</span><span class="selector-class">.31</span><span class="selector-class">.177</span><span class="selector-pseudo">:8080</span>;   # 监听具体<span class="selector-tag">IP</span>和具体端口上的连接</span><br><span class="line"><span class="selector-tag">listen</span> 192<span class="selector-class">.168</span><span class="selector-class">.31</span><span class="selector-class">.177</span>;   # 监听<span class="selector-tag">IP</span>上所有端口上的连接</span><br><span class="line"><span class="selector-tag">listen</span> 8080;     # 监听具体端口上的所有<span class="selector-tag">IP</span>的连接</span><br></pre></td></tr></table></figure><h3 id="18-基于名称和IP的虚拟主机配置"><a href="#18-基于名称和IP的虚拟主机配置" class="headerlink" title="18. 基于名称和IP的虚拟主机配置"></a><strong>18. 基于名称和IP的虚拟主机配置</strong></h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name name1 name2 ...</span><br></pre></td></tr></table></figure><p>name可以有多个并列名称，而且此处的name支持正则表达式书写</p><p>实际举例：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">server_name ~^www\d+\.myserver\.com$</span><br></pre></td></tr></table></figure><p>此时表示该虚拟主机可以接收类似域名 <a href="http://www1.myserver.com/">www1.myserver.com</a> 等的请求而拒绝 <a href="http://www.myserver.com/">www.myserver.com</a> 的域名请求，所以说用正则表达式可以实现更精准的控制</p><p>至于基于IP的虚拟主机配置比较简单，不再太赘述：</p><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name IP地址</span><br></pre></td></tr></table></figure><h3 id="19-location配置"><a href="#19-location配置" class="headerlink" title="19. location配置"></a><strong>19. location配置</strong></h3><p>指令格式为：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">location [ = <span class="params">| ~ |</span> ~* <span class="params">| ^~ ] uri &#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>这里的<code>uri</code>分为标准uri和正则uri，两者的唯一区别是uri中是否包含正则表达式(<strong>URI</strong>，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。而<strong>URL</strong>是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。)</p><p>uri前面的方括号中的内容是可选项，解释如下：</p><p><code>&quot;=&quot;</code>：用于标准uri前，要求请求字符串与uri严格匹配，一旦匹配成功则停止</p><p><code>&quot;~&quot;</code>：用于正则uri前，并且区分大小写</p><p><code>&quot;~*&quot;</code>：用于正则uri前，但不区分大小写</p><p><code>&quot;^~&quot;</code>：用于标准uri前，要求Nginx找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配</p><h3 id="20-请求根目录配置"><a href="#20-请求根目录配置" class="headerlink" title="20. 请求根目录配置"></a><strong>20. 请求根目录配置</strong></h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root path;</span><br></pre></td></tr></table></figure><p>path：Nginx接收到请求以后查找资源的根目录路径</p><p>当然，还可以通过alias指令来更改location接收到的URI请求路径，指令为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> path; <span class="comment"># path为修改后的根路径</span></span><br></pre></td></tr></table></figure><h3 id="21-设置网站的默认首页"><a href="#21-设置网站的默认首页" class="headerlink" title="21. 设置网站的默认首页"></a><strong>21. 设置网站的默认首页</strong></h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index file ......</span><br></pre></td></tr></table></figure><p><code>file</code>可以包含多个用空格隔开的文件名，首先找到哪个页面，就使用哪个页面响应请求</p><p>其实Nginx的配置真的是很简单，对于新手们来说其实最大的问题就是Nginx所有的配置都是基于配置文件和各个模块语法的，这些看着给人的感觉好复杂的样子，其实理解了各个模块的意义和基本语法后就变的尤为简单了！</p><h2 id="三、Nginx配置SSL及HTTP跳转到HTTPS"><a href="#三、Nginx配置SSL及HTTP跳转到HTTPS" class="headerlink" title="三、Nginx配置SSL及HTTP跳转到HTTPS"></a><strong>三、Nginx配置SSL及HTTP跳转到HTTPS</strong></h2><p>随着微信小程序和appstore对ssl安全的需求，越来越多的网站和app需要支持SSL功能，需要开启https的方式来打开网站或传输数据。</p><p>ssl证书网上可以找到收费和免费的申请，nginx配置如下：</p><p>Nginx配置SSL并把Http跳转到Https，需要修改Nginx.conf配置文件：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是http请求默认访问80端口，此时return强行301重定向到https://www.joyitsai.com</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  listen <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">  server_name www.joyitsai.com;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//www.joyitsai.com$request_uri;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 把http重定向到https使用了nginx的重定向命令，之前老版本的nginx可能使用了以下类似的格式：</span></span><br><span class="line">  <span class="comment"># rewrite ^/(.*)$ http://www.joyitsai.com/$1 permanent;</span></span><br><span class="line">  <span class="comment"># 或者：</span></span><br><span class="line">  <span class="comment"># rewrite ^ http://www.joyitsai.com$request_uri? permanent;</span></span><br><span class="line">  <span class="comment"># 现在nginx新版本已经换了种写法，上面这些已经不再推荐。现在网上可能还有很多文章写的是第一种。</span></span><br><span class="line">  <span class="comment"># 新的写法比较推荐方式是：return 301 https://www.joyitsai.com$request_uri;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  listen <span class="number">443</span>;</span><br><span class="line">  server_name www.joyitsai.com;</span><br><span class="line">  root /data/release/weapp/uploadFiles;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 开启ssl功能</span></span><br><span class="line">  ssl on;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 配置ssl证书，直接用.pem和.key文件的绝对路径</span></span><br><span class="line"></span><br><span class="line">  ssl_certificate/data/release/nginx/<span class="number">1535530361992.</span>pem;</span><br><span class="line"></span><br><span class="line">  ssl_certificate_key/data/release/nginx/<span class="number">1535530361992.</span>key;</span><br><span class="line"></span><br><span class="line">  ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line"></span><br><span class="line">  ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;</span><br><span class="line"></span><br><span class="line">  ssl_ciphers ECDHE - RSA - AES128 - GCM - SHA256: ECDHE: ECDH: AES: HIGH: !<span class="literal">NULL</span>: !aNULL: !MD5: !ADH: !RC4;</span><br><span class="line"></span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line"></span><br><span class="line">     proxy_pass http:<span class="comment">//app_weapp;</span></span><br><span class="line"></span><br><span class="line">     proxy_http_version <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">     proxy_set_header Upgrade $http_upgrade;</span><br><span class="line"></span><br><span class="line">     proxy_set_header Connection <span class="string">&#x27;upgrade&#x27;</span>;</span><br><span class="line"></span><br><span class="line">     proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">     proxy_cache_bypass $http_upgrade;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /images/ &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 配置uri， ~用于正则uri前，其中.(png|jpg)为正则表达式，如果后缀是.png或.jpg的url请求，则匹配成功</span></span><br><span class="line">  <span class="comment"># root用于配置接收到请求以后查找资源的根目录路径</span></span><br><span class="line"></span><br><span class="line">  location ~ \.(png|jpg) &#123;</span><br><span class="line">     root /data/release/weapp/uploadFiles;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page <span class="number">404</span> /<span class="number">404.</span>html;</span><br><span class="line"></span><br><span class="line">  location = /<span class="number">40</span>x.html &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /<span class="number">50</span>x.html;</span><br><span class="line"></span><br><span class="line">  location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：0mei<br>链接：<a href="https://www.jianshu.com/p/d8bd75c0fb1b">https://www.jianshu.com/p/d8bd75c0fb1b</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      转载–Nginx基本功能及其原理
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Linux/Nginx/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置Nginx图片服务器</title>
    <link href="http://yoursite.com/2020/12/07/Linux%E9%85%8D%E7%BD%AENginx%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2020/12/07/Linux%E9%85%8D%E7%BD%AENginx%E5%9B%BE%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-12-07T01:45:00.000Z</published>
    <updated>2020-12-09T02:49:59.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux配置Nginx图片服务器"><a href="#Linux配置Nginx图片服务器" class="headerlink" title="Linux配置Nginx图片服务器"></a>Linux配置Nginx图片服务器</h1><h2 id="一-设置nginx-conf配置文件"><a href="#一-设置nginx-conf配置文件" class="headerlink" title="一. 设置nginx.conf配置文件"></a>一. 设置nginx.conf配置文件</h2><ol><li><p>查找配置文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name nginx.conf</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://pic.downk.cc/item/5fcd858f394ac52378e89420.jpg"></p><ol start="2"><li><p>更改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80 default_server;</span><br><span class="line">    listen       [::]:80 default_server;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         /usr/share/nginx/html;</span><br><span class="line">   </span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include /etc/nginx/default.d/*.conf;</span><br><span class="line">   </span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">    location = /404.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    error_page 500 502 503 504 /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 配置图片的存储类型</span><br><span class="line">    location ~ .*\.(gif|jpg|jpeg|png|jfif)$ &#123; </span><br><span class="line">            # 图片存放位置</span><br><span class="line">            root /root/project/yun/image; </span><br><span class="line">            autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>访问: <a href="https://ip/%E5%9B%BE%E7%89%87%E5%90%8D%E7%A7%B0">https://ip/图片名称</a></li></ol><h2 id="二-可能遇到的错误"><a href="#二-可能遇到的错误" class="headerlink" title="二. 可能遇到的错误"></a>二. 可能遇到的错误</h2><h3 id="访问nginx出现403-forbidden"><a href="#访问nginx出现403-forbidden" class="headerlink" title="访问nginx出现403 forbidden"></a>访问nginx出现403 forbidden</h3><h4 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h4><p>nginx是由root用户启动，查看进程发现worker进程是nobody用户，nginx下的静态文件worker进程没有访问权限。</p><p><img src="https://img-blog.csdnimg.cn/20181211153443874.png" alt="在这里插入图片描述"></p><h4 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h4><p>修改nginx配置文件<code>nginx.conf</code>，将user配置修改与启动用户一致。</p><p><img src="https://img-blog.csdnimg.cn/20181211153457882.png" alt="在这里插入图片描述"></p><p>执行命令使nginx重新加载配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p>再查看nginx进程，worker进程的用户被修改成了root用户。此时重新访问根目录不再报403 forbidden的错误，可以正常访问。</p><p><img src="https://img-blog.csdnimg.cn/20181211153514201.png" alt="在这里插入图片描述"></p><h3 id="未开放端口"><a href="#未开放端口" class="headerlink" title="未开放端口"></a>未开放端口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开启防火墙 </span><br><span class="line">    systemctl start firewalld</span><br><span class="line"></span><br><span class="line">2、开放指定端口</span><br><span class="line">      firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line"> 命令含义：</span><br><span class="line">--zone #作用域</span><br><span class="line">--add-port&#x3D;80&#x2F;tcp  #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">--permanent  #永久生效，没有此参数重启后失效</span><br><span class="line"></span><br><span class="line">3、重启防火墙</span><br><span class="line">      firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">4、查看端口号</span><br><span class="line">netstat -ntlp   &#x2F;&#x2F;查看当前所有tcp端口·</span><br><span class="line"></span><br><span class="line">netstat -ntulp |grep 80   &#x2F;&#x2F;查看所有80端口使用情况·</span><br><span class="line"></span><br><span class="line">查看防火墙状态:</span><br><span class="line">systemctl status firewalld</span><br><span class="line"></span><br><span class="line">关闭防火墙：</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h1 id="配置Https服务器"><a href="#配置Https服务器" class="headerlink" title="配置Https服务器"></a>配置Https服务器</h1><ol><li><p>进入到nginx.conf的配置文件中</p></li><li><p>增加https配置(nginx内置了https服务, 只需要将注释去掉并进行个人配置就好)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Settings for a TLS enabled server.</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl http2 default_server;</span><br><span class="line">        listen       [::]:443 ssl http2 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        </span><br><span class="line">        # HSTS策略</span><br><span class="line">        add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubDomains; preload&quot; always;</span><br><span class="line">        #优先采取服务器算法</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        #使用DH文件</span><br><span class="line">        ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        #定义算法</span><br><span class="line">        #减少点击劫持</span><br><span class="line">        add_header X-Frame-Options DENY;</span><br><span class="line">        #禁止服务器自动解析资源类型</span><br><span class="line">        add_header X-Content-Type-Options nosniff;</span><br><span class="line">        #防XSS攻擊</span><br><span class="line">        add_header X-Xss-Protection 1;</span><br><span class="line"></span><br><span class="line">        ssl_certificate &quot;&#x2F;root&#x2F;project&#x2F;yun&#x2F;Nginx&#x2F;1_yunservice.ltd_bundle.crt&quot;;</span><br><span class="line">        ssl_certificate_key &quot;&#x2F;root&#x2F;project&#x2F;yun&#x2F;Nginx&#x2F;2_yunservice.ltd.key&quot;;</span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line">        #ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">        #ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">        location &#x3D; &#x2F;404.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 配置个人的图片访问地址</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|png|jfif)$ &#123;</span><br><span class="line">                root &#x2F;root&#x2F;project&#x2F;yun&#x2F;image;</span><br><span class="line">                autoindex on;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="加强-HTTPS-安全性"><a href="#加强-HTTPS-安全性" class="headerlink" title="加强 HTTPS 安全性"></a>加强 HTTPS 安全性</h4><p>HTTPS 基础配置采取的默认加密算法是 SHA-1，这个算法非常脆弱，安全性在逐年降低，在 2014 年的时候， <strong>Google 官方博客就宣布在 Chrome 浏览器中逐渐降低 SHA-1 证书的安全指示，会从 2015 年起使用 SHA-2 签名的证书</strong>，可参阅 <a href="http://www.freebuf.com/author/rabbit_run">Rabbit_Run</a> 在 2014 年发表的文章：<a href="http://www.freebuf.com/news/topnews/44288.html">《为什么Google急着杀死加密算法SHA-1》</a></p><p>为此，主流的 HTTPS 配置方案应该避免 SHA-1，可以使用 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">迪菲-赫尔曼密钥交换（D-H，Diffie–Hellman key exchange）</a>方案。</p><p>首先在目录 <code>/etc/ssl/certs</code> 运行以下代码生成 <code>dhparam.pem</code> 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;ssl&#x2F;certs</span><br><span class="line"></span><br><span class="line">openssl dhparam -out dhparam.pem 2048</span><br></pre></td></tr></table></figure><p>然后加入 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优先采取服务器算法</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">#使用DH文件</span><br><span class="line">ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#定义算法</span><br><span class="line">ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br></pre></td></tr></table></figure><p>如果服务器夠強大，可以使用更为复杂的 4096 位进行加密。</p><p>一般情況下还应该加上以下几个增强安全性的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#减少点击劫持</span><br><span class="line">add_header X-Frame-Options DENY;</span><br><span class="line">#禁止服务器自动解析资源类型</span><br><span class="line">add_header X-Content-Type-Options nosniff;</span><br><span class="line">#防XSS攻击</span><br><span class="line">add_header X-Xss-Protection 1;</span><br></pre></td></tr></table></figure></li><li><p>重启配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看nginx正在运行的进程pid</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line">杀死正在运行的进程</span><br><span class="line">kill -9 &#96;pid&#96;</span><br><span class="line"></span><br><span class="line">运行配置文件</span><br><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>综合配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl http2 default_server;</span><br><span class="line">    listen       [::]:443 ssl http2 default_server;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    # HSTS策略</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubDomains; preload&quot; always;</span><br><span class="line">    # 优先采取服务器算法</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    # 使用DH文件</span><br><span class="line">    ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    # 定义算法</span><br><span class="line">    ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br><span class="line">    # 减少点击劫持</span><br><span class="line">    add_header X-Frame-Options DENY;</span><br><span class="line">    # 禁止服务器自动解析资源类型</span><br><span class="line">    add_header X-Content-Type-Options nosniff;</span><br><span class="line">    # 防XSS攻擊</span><br><span class="line">    add_header X-Xss-Protection 1;</span><br><span class="line">   </span><br><span class="line">    ssl_certificate &quot;&#x2F;root&#x2F;project&#x2F;yun&#x2F;Nginx&#x2F;1_yunservice.ltd_bundle.crt&quot;;</span><br><span class="line">    ssl_certificate_key &quot;&#x2F;root&#x2F;project&#x2F;yun&#x2F;Nginx&#x2F;2_yunservice.ltd.key&quot;;</span><br><span class="line">    ssl_session_cache shared:SSL:1m;</span><br><span class="line">    ssl_session_timeout  10m;</span><br><span class="line">    #ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    #ssl_prefer_server_ciphers on;</span><br><span class="line">   </span><br><span class="line">    # Load configuration files for the default server block.</span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line">   </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x3D; &#x2F;404.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    location ~ .*\.(gif|jpg|jpeg|png|jfif)$ &#123;</span><br><span class="line">            root &#x2F;root&#x2F;project&#x2F;yun&#x2F;image;</span><br><span class="line">            autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><p>参考文章:</p><h1 id="一些错误"><a href="#一些错误" class="headerlink" title="一些错误"></a>一些错误</h1><h2 id="外界无法访问Linux服务器上的项目的解决方法及防火墙设置"><a href="#外界无法访问Linux服务器上的项目的解决方法及防火墙设置" class="headerlink" title="外界无法访问Linux服务器上的项目的解决方法及防火墙设置"></a>外界无法访问Linux服务器上的项目的解决方法及防火墙设置</h2><p>外界无法访问服务器上的项目，<br>一是因为服务器防火墙没有设置好，例如你的项目要用到数据库，而数据库对应的端口就需要被开启，否则就无法访问数据库，进而访问项目异常；<br>二是因为你的云服务器控制台有个安全组规则，你没有开放对应的入网端口规则。<br>下面开启你所需的所有端口号，相信你的项目就能正常访问了。</p><p>在终端内查看一下防火墙是否开启：<code>firewall-cmd --state</code> running 表示已开启防火墙，否则你需要<code>systemctl start firewalld.service</code>来开启。</p><p>检查已开放的端口号：<code>firewall-cmd --list-ports</code>，以下是我已开放的端口号列表<br><img src="https://img-blog.csdnimg.cn/20200323120537491.png" alt="在这里插入图片描述"><br>若没有你需要的端口号，则要添加进去：例如添加8080端口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#永久开放8080端口</span><br><span class="line">firewall-cmd --add-port&#x3D;8080&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p>添加完后，需要重载生效：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重载生效添加的端口</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux配置Nginx图片服务器及可能遇到的问题
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Linux/Nginx/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux下配置Nginx</title>
    <link href="http://yoursite.com/2020/12/06/Linux%E4%B8%8B%E9%85%8D%E7%BD%AENginx/"/>
    <id>http://yoursite.com/2020/12/06/Linux%E4%B8%8B%E9%85%8D%E7%BD%AENginx/</id>
    <published>2020-12-06T15:12:00.000Z</published>
    <updated>2020-12-07T14:42:43.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下配置nginx"><a href="#Linux下配置nginx" class="headerlink" title="Linux下配置nginx"></a>Linux下配置nginx</h1><h2 id="一-安装依赖包"><a href="#一-安装依赖包" class="headerlink" title="一.安装依赖包"></a><strong>一.安装依赖包</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//一键安装上面四个依赖</span><br><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><h3 id="①gcc环境"><a href="#①gcc环境" class="headerlink" title="①gcc环境"></a><strong>①gcc环境</strong></h3><p>Nginx是C语言开发，nginx安装前需具备gcc g++环境在安装时进行编译。可通过下面命令查看是否有这三个包</p><p>rpm -qa | grep gcc</p><p><img src="https://pic.downk.cc/item/5fcd84d0394ac52378e81e4c.png" alt="img"></p><h3 id="②PCRE安装"><a href="#②PCRE安装" class="headerlink" title="②PCRE安装"></a><strong>②PCRE安装</strong></h3><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre库.</p><h3 id="③OpenSSL安装（非必须-用到HTTPS协议需安装）"><a href="#③OpenSSL安装（非必须-用到HTTPS协议需安装）" class="headerlink" title="③OpenSSL安装（非必须 用到HTTPS协议需安装）"></a><strong>③OpenSSL安装（非必须 用到HTTPS协议需安装）</strong></h3><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要安装 OpenSSL 库。</p><h3 id="④安装zlib"><a href="#④安装zlib" class="headerlink" title="④安装zlib"></a><strong>④安装zlib</strong></h3><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip</p><h2 id="二-安装nginx"><a href="#二-安装nginx" class="headerlink" title="二. 安装nginx"></a>二. 安装nginx</h2><p><strong>普通用户使用yum需要使用sudo yum install xxx</strong></p><p>需要在root用户下在vi /etc/sudoers, 写入 user ALL=(ALL) ALL 如下图</p><p><img src="https://pic.downk.cc/item/5fcd852f394ac52378e85a77.png"></p><p> <strong>sudo yum install nginx 遇到：没有可用软件包 nginx</strong></p><p>原因是nginx位于第三方的yum源里面，而不在centos官方yum源里面</p><p>解决办法，安装epel</p><p>sudo yum install epel-release</p><p>sudo yum update</p><p>再次执行sudo yum install nginx 可以安装了</p><p><strong>如上安装后，nginx被安装到哪里了？？？</strong></p><h3 id="1-查看nginx安装目录"><a href="#1-查看nginx安装目录" class="headerlink" title="1. 查看nginx安装目录"></a>1. 查看nginx安装目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5fcd8566394ac52378e87b27.jpg"></p><h3 id="2-启动和重启nginx"><a href="#2-启动和重启nginx" class="headerlink" title="2. 启动和重启nginx"></a>2. 启动和重启nginx</h3><p>进入到 /usr/sbin目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;sbin</span><br></pre></td></tr></table></figure><h4 id="①启动nginx"><a href="#①启动nginx" class="headerlink" title="①启动nginx"></a>①启动nginx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><h4 id="②重启nginx"><a href="#②重启nginx" class="headerlink" title="②重启nginx"></a>②重启nginx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="启动或重启中可能遇到的错误"><a href="#启动或重启中可能遇到的错误" class="headerlink" title="启动或重启中可能遇到的错误"></a>启动或重启中可能遇到的错误</h4><h5 id="一-emerg-open-“-var-run-nginx-nginx-pid”-failed-21-Is-a-directory"><a href="#一-emerg-open-“-var-run-nginx-nginx-pid”-failed-21-Is-a-directory" class="headerlink" title="一. [emerg] open() “/var/run/nginx/nginx.pid” failed (21: Is a directory)"></a>一. [emerg] open() “/var/run/nginx/nginx.pid” failed (21: Is a directory)</h5><p>从错误分析可以看出是找不到ngnix.pid这个文件或者目录</p><p>(1) 输入命令: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name nginx.pid</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5fcd857f394ac52378e88c17.jpg"></p><p>(2) 修改ngnix.conf的配置文件</p><ol><li><p>查找配置文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name nginx.conf</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://pic.downk.cc/item/5fcd858f394ac52378e89420.jpg"></p><ol start="2"><li><p>更改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://pic.downk.cc/item/5fcd85a0394ac52378e8a02d.jpg"></p><ol start="3"><li><p>完成后重启nginx: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure></li></ol><h5 id="二-如果不存在pid文件"><a href="#二-如果不存在pid文件" class="headerlink" title="二. 如果不存在pid文件"></a>二. 如果不存在pid文件</h5><p>解决办法：创建文件</p><ol><li><p>进入run下：cd /run</p></li><li><p>创建nginx.pid文件：touch nginx.pid</p></li><li><p>进入nainx文件夹 cd /usr/sbin</p></li><li><p>启动nginx：./nginx</p></li></ol><h5 id="三-启动过程中端口被占用"><a href="#三-启动过程中端口被占用" class="headerlink" title="三. 启动过程中端口被占用"></a>三. 启动过程中端口被占用</h5><p><img src="https://pic.downk.cc/item/5fcd85b0394ac52378e8abd6.jpg"></p><p>原因可能是nginx重复启动两个进程</p><ol><li><p>查看nginx进程占用的pid  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p><img src="https://pic.downk.cc/item/5fcd85c7394ac52378e8bcdb.jpg"></p></li><li><p>杀掉全部进程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 pid(例如: 13277)</span><br></pre></td></tr></table></figure></li><li><p>重启nginx</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure></li></ol><h5 id="四-Nginx报错：nginx-error-invalid-PID-number-“”-in-“-run-nginx-pid”-解决方法"><a href="#四-Nginx报错：nginx-error-invalid-PID-number-“”-in-“-run-nginx-pid”-解决方法" class="headerlink" title="四. Nginx报错：nginx: [error] invalid PID number “” in “/run/nginx.pid” 解决方法"></a>四. Nginx报错：nginx: [error] invalid PID number “” in “/run/nginx.pid” 解决方法</h5><ol><li><p>查找nginx.conf的存放目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name nginx.conf</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>执行命令: 根据上述命令返回的地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-查看nginx状态"><a href="#3-查看nginx状态" class="headerlink" title="3. 查看nginx状态"></a>3. 查看nginx状态</h3><ol><li><p>查看进程运行状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://pic.downk.cc/item/5fcd85c7394ac52378e8bcdb.jpg"></p><ol start="2"><li><p>查看启动状态</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure></li><li><p>查看服务器界面 浏览器上访问服务器ip地址</p><p>访问服务器IP后发现出现的是CentOS的欢迎页面，而不是nginx的欢迎页面，起初以为是Nginx没有启动成功，后来发现nginx.conf中指向的就是CentOS的欢迎页面<br><code>root /usr/share/nginx/html;</code> 这一条设置就是指向页面设置<br><img src="https://pic.downk.cc/item/5fcd85e4394ac52378e8cd9d.png"><br>在<code>/usr/share/nginx/html</code>目录下的index.html，nginx运行后访问的页面，打开发现就是Centos 的欢迎页面，所以Nginx已经安装成功并启动。</p></li></ol><h3 id="4-查看日志"><a href="#4-查看日志" class="headerlink" title="4.查看日志"></a>4.查看日志</h3><p>首先进入nginx.conf文件查找日志位置</p><p><img src="https://pic.downk.cc/item/5fce3f433ffa7d37b307bec3.jpg"></p><p>接着查看日志</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f -n 300 &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux下配置Nginx及可能遇到的问题
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Linux/Nginx/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Annotation</title>
    <link href="http://yoursite.com/2020/12/06/Annotation/"/>
    <id>http://yoursite.com/2020/12/06/Annotation/</id>
    <published>2020-12-06T15:12:00.000Z</published>
    <updated>2020-12-07T14:59:58.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.annotation.ElementType.TYPE：<span class="comment">//类、接口（包括注解类型）和枚举的声明</span></span><br><span class="line">java.lang.annotation.ElementType.FIELD：<span class="comment">//字段声明（包括枚举常量）</span></span><br><span class="line">java.lang.annotation.ElementType.METHOD：<span class="comment">//方法声明</span></span><br><span class="line">java.lang.annotation.ElementType.PARAMETER：<span class="comment">//参数声明</span></span><br><span class="line">java.lang.annotation.ElementType.CONSTRUCTOR：<span class="comment">//构造函数声明</span></span><br><span class="line">java.lang.annotation.ElementType.LOCAL_VARIABLE：<span class="comment">//本地变量声明</span></span><br><span class="line">java.lang.annotation.ElementType.ANNOTATION_TYPE：<span class="comment">//注解类型声明</span></span><br><span class="line">java.lang.annotation.ElementType.PACKAGE：<span class="comment">//包声明</span></span><br><span class="line">java.lang.annotation.ElementType.TYPE_PARAMETER：<span class="comment">//类型参数声明，JavaSE8引进，可以应用于类的泛型声明之处java.lang.annotation.ElementType.TYPE_USE：JavaSE8引进，此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查，例如，如果使用@Target（ElementType.TYPE_USE）对@NonNull进行标记，则类型检查器可以将@NonNull class C &#123;...&#125; C类的所有变量都视为非null</span></span><br></pre></td></tr></table></figure><p>注意：如果一个注解没有指定@Target注解，则此注解可以用于除了TYPE_PARAMETER和TYPE_USE以外的任何地方。</p><p>以下我们看看ElementType.TYPE_PARAMETER和ElementType.TYPE_USE的使用示例，对于其他的ElementType注解元素，看其说明就知道怎么用了：</p><p>声明由ElementType.TYPE_PARAMETER标记的@NotEmpty注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springmorning.demo.javabase.annotation.meta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotEmpty &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明由ElementType.TYPE_USE标记的@NotEmpty注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springmorning.demo.javabase.annotation.meta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotNull &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下示例代码说明了这两种Target注解元素的使用区别，ElementType.TYPE_USE包含了ElementType.TYPE和ElementType.TYPE_PARAMETER</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springmorning.demo.javabase.annotation.meta;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类型声明时，使用TYPE_USE类型，编译通过</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &lt;@<span class="title">NotNull</span> <span class="title">TT</span>&gt;</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类型声明时，使用使用TYPE_PARAMETER类型，编译通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeParameterAndTypeUseAnnotation</span>&lt;@<span class="title">NotEmpty</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用TYPE_PARAMETER类型，会编译不通过</span></span><br><span class="line"><span class="comment">//    public @NotEmpty T test(@NotEmpty T a)&#123;</span></span><br><span class="line"><span class="comment">//        new ArrayList&lt;@NotEmpty String&gt;();</span></span><br><span class="line"><span class="comment">//            return a;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用TYPE_USE类型，编译通过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NotNull</span> <span class="function">T <span class="title">test</span><span class="params">(<span class="meta">@NotNull</span> T a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;<span class="meta">@NotNull</span> String&gt;();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Retention-注解的作用"><a href="#Retention-注解的作用" class="headerlink" title="@Retention 注解的作用"></a>@Retention 注解的作用</h2><p>注解@Retention可以用来修饰注解，是注解的注解，称为元注解。<br>Retention注解有一个属性value，是RetentionPolicy类型的，Enum   RetentionPolicy是一个枚举类型，<br>这个枚举决定了Retention注解应该如何去保持，也可理解为Rentention 搭配 RetentionPolicy使用。</p><p>RetentionPolicy有3个值：<strong>CLASS   RUNTIME    SOURCE</strong></p><p>按生命周期来划分可分为3类：<br>1、<strong>RetentionPolicy.SOURCE</strong>：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；<br>2、<strong>RetentionPolicy.CLASS</strong>：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；<br>3、<strong>RetentionPolicy.RUNTIME</strong>：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；</p><p>这3个生命周期分别对应于：Java源文件(.java文件) —&gt; .class文件 —&gt; 内存中的字节码。<br>那怎么来选择合适的注解生命周期呢？<br>首先要明确生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。<br>一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解，比如@Deprecated使用RUNTIME注解</p><p>如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；<br>如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用SOURCE 注解。</p><p>注解@Override用在方法上，当我们想重写一个方法时，在方法上加@Override，当我们方法的名字出错时，编译器就会报错<br>注解@Deprecated，用来表示某个类或属性或方法已经过时，不想别人再用时，在属性和方法上用@Deprecated修饰<br>注解@SuppressWarnings用来压制程序中出来的警告，比如在没有用泛型或是方法已经过时的时候</p><h2 id="Documented"><a href="#Documented" class="headerlink" title="**@**Documented"></a>**@**Documented</h2><p>**@**Documented 注解表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中，是一个标记注解，没有成员。</p><h4 id="带-Documented生成的javadoc"><a href="#带-Documented生成的javadoc" class="headerlink" title="带@Documented生成的javadoc"></a>带@Documented生成的javadoc</h4><p><img src="https://img-blog.csdnimg.cn/20191222150538764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTYxODg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="不带-Documented生成的javadoc"><a href="#不带-Documented生成的javadoc" class="headerlink" title="不带@Documented生成的javadoc"></a>不带@Documented生成的javadoc</h4><p>这两个图的唯一差距就是类的说明是否有这个@API注解。<br><img src="https://img-blog.csdnimg.cn/2019122217424189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTYxODg=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>@Documented注解只是用来做标识，没什么实际作用，了解就好。</p><h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a><strong>简介：</strong></h3><p>java.lang.SuppressWarnings是J2SE5.0中标准的Annotation之一。可以标注在类、字段、方法、参数、构造方法，以及局部变量上。**</p><p>作用：**告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。</p><h3 id="一-使用"><a href="#一-使用" class="headerlink" title="一. 使用:"></a>一. 使用:</h3><p>@SuppressWarnings(“”)<br>@SuppressWarnings({})<br>@SuppressWarnings(value={})</p><p>根据sun的官方文档描述：<br>value -将由编译器在注释的元素中取消显示的警告集。允许使用重复的名称。忽略第二个和后面出现的名称。出现未被识别的警告名 <em>不是</em>错误：编译器必须忽略无法识别的所有警告名。但如果某个注释包含未被识别的警告名，那么编译器可以随意发出一个警告。</p><p>各编译器供应商应该将它们所支持的警告名连同注释类型一起记录。鼓励各供应商之间相互合作，确保在多个编译器中使用相同的名称。</p><p><strong>示例：</strong></p><p>·  @SuppressWarnings(“unchecked”)</p><p>告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。</p><p>·  @SuppressWarnings(“serial”)</p><p>如果编译器出现这样的警告信息：The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long<br>     使用这个注释将警告信息去掉。</p><p>·  @SuppressWarnings(“deprecation”)</p><p>如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。<br>     使用这个注释将警告信息去掉。</p><p>·  @SuppressWarnings(“unchecked”, “deprecation”)</p><p>告诉编译器同时忽略unchecked和deprecation的警告信息。</p><p>·  @SuppressWarnings(value={“unchecked”, “deprecation”})</p><p>等同于@SuppressWarnings(“unchecked”, “deprecation”)</p><p>转自<a href="http://blog.sina.com.cn/s/blog_ad8b5870010166vt.html">http://blog.sina.com.cn/s/blog_ad8b5870010166vt.html</a></p><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><p> 编码时我们总会发现如下变量未被使用的警告提示：</p><p><img src="http://images.cnitblog.com/blog/347002/201410/211544285432472.png" alt="img"></p><p> 上述代码编译通过且可以运行，但每行前面的“感叹号”就严重阻碍了我们判断该行是否设置的断点了。这时我们可以在方法前添加 @SuppressWarnings(“unused”) 去除这些“感叹号”。</p><h3 id="二、-SuppressWarings注解"><a href="#二、-SuppressWarings注解" class="headerlink" title="二、 @SuppressWarings注解　　"></a>二、 @SuppressWarings注解　　</h3><p> <strong>作用：用于抑制编译器产生警告信息。</strong></p><p> 示例1——抑制单类型的警告：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public void addItems(String item)&#123;</span><br><span class="line">  @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">   List items &#x3D; new ArrayList();</span><br><span class="line">   items.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例2——抑制多类型的警告：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(value&#x3D;&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br><span class="line">public void addItems(String item)&#123;</span><br><span class="line">   List items &#x3D; new ArrayList();</span><br><span class="line">   items.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例3——抑制所有类型的警告：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public void addItems(String item)&#123;</span><br><span class="line">   List items &#x3D; new ArrayList();</span><br><span class="line">   items.add(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、注解目标"><a href="#三、注解目标" class="headerlink" title="三、注解目标　"></a>三、注解目标　</h3><p> 通过 @SuppressWarnings 的源码可知，其注解目标为类、字段、函数、函数入参、构造函数和函数的局部变量。</p><p> 而家建议注解应声明在最接近警告发生的位置。</p><h3 id="四、抑制警告的关键字"><a href="#四、抑制警告的关键字" class="headerlink" title="四、抑制警告的关键字　　"></a>四、抑制警告的关键字　　</h3><table><thead><tr><th><strong>关键字</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>all</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>to suppress warnings relative to locals that hide variable</td></tr><tr><td>incomplete-switch</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtypes</td><td>to suppress warnings relative to un-specific types when using generics on class params</td></tr><tr><td>restriction</td><td>to suppress warnings relative to usage of discouraged or forbidden references</td></tr><tr><td>serial</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>o suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>to suppress warnings relative to unused code</td></tr></tbody></table><h3 id="五、Java-Lint选项"><a href="#五、Java-Lint选项" class="headerlink" title="五、Java Lint选项"></a>五、Java Lint选项</h3><p> <strong>1. lint的含义</strong></p><p>　　用于在编译程序的过程中，进行更细节的额外检查。</p><p> <strong>2. \</strong>javac** 的标准选项和非标准选项**</p><p>   <strong>标准选项：</strong>是指当前版本和未来版本中都支持的选项，如 -cp 和 -d 等。</p><p>   <strong>非标准选项：</strong>是指当前版本支持，但未来不一定支持的选项。通过 javac -X 查看当前版本支持的非标准选项。</p><p><img src="http://images.cnitblog.com/blog/347002/201410/211648020124434.png" alt="img"></p><p> <strong>3. 查看警告信息</strong></p><p>  默认情况下执行 javac 仅仅显示警告的扼要信息，也不过阻止编译过程。若想查看警告的详细信息，则需要执行 javac -Xlint:keyword 来编译源码了。</p><h2 id="从-Java-7-开始，额外添加了-3-个注解"><a href="#从-Java-7-开始，额外添加了-3-个注解" class="headerlink" title="从 Java 7 开始，额外添加了 3 个注解:"></a>从 Java 7 开始，额外添加了 3 个注解:</h2><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h1 id="1、Annotation-架构"><a href="#1、Annotation-架构" class="headerlink" title="1、Annotation 架构"></a>1、Annotation 架构</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/08/28123151-d471f82eb2bc4812b46cc5ff3e9e6b82.jpg" alt="img"></p><p>从中，我们可以看出：</p><p><strong>(01) 1 个 Annotation 和 1 个 RetentionPolicy 关联。</strong></p><p>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。</p><p><strong>(02) 1 个 Annotation 和 1~n 个 ElementType 关联。</strong></p><p>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</p><p><strong>(03) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</strong></p><p>Annotation 的每一个实现类，都 “和 1 个 RetentionPolicy 关联” 并且 “ 和 1~n 个 ElementType 关联”。</p><p>下面，我先介绍框架图的左半边(如下图)，即 Annotation, RetentionPolicy, ElementType；然后在就 Annotation 的实现类进行举例说明。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/08/28123653-84d14b886429482bb601dc97155220fb.jpg" alt="img"></p><hr><h1 id="2、Annotation-组成部分"><a href="#2、Annotation-组成部分" class="headerlink" title="2、Annotation 组成部分"></a>2、Annotation 组成部分</h1><p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p><h2 id="Annotation-java"><a href="#Annotation-java" class="headerlink" title="Annotation.java"></a>Annotation.java</h2><p><strong>package</strong> java.lang.annotation;<br><strong>public</strong> <strong>interface</strong> Annotation {</p><p>  <strong>boolean</strong> equals(Object obj);</p><p>  <strong>int</strong> hashCode();</p><p>  String toString();</p><p>  Class&lt;? **extends** Annotation&gt; annotationType();<br>}</p><h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p><strong>(01) Annotation 就是个接口。</strong></p><p>“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联，并且与 “1～n 个 ElementType” 关联。可以通俗的理解为：每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。</p><p><strong>(02) ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong></p><p>“每 1 个 Annotation” 都与 “1～n 个 ElementType” 关联。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</p><p><strong>(03) RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。</strong></p><p>“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联。</p><ul><li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ul><p>这时，只需要记住”每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联，并且与 “1～n 个 ElementType” 关联。学完后面的内容之后，再回头看这些内容，会更容易理解。</p><h1 id="3、java-自带的-Annotation"><a href="#3、java-自带的-Annotation" class="headerlink" title="3、java 自带的 Annotation"></a>3、java 自带的 Annotation</h1><p>理解了上面的 3 个类的作用之后，我们接下来可以讲解 Annotation 实现类的语法定义了。</p><h3 id="1）Annotation-通用定义"><a href="#1）Annotation-通用定义" class="headerlink" title="1）Annotation 通用定义"></a>1）Annotation 通用定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：</p><p><strong>(01) @interface</strong></p><p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p><p>定义 Annotation 时，@interface 是必须的。</p><p>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p><p><strong>(02) @Documented</strong></p><p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</p><p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p><p><strong>(03) @Target(ElementType.TYPE)</strong></p><p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p><p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p><p><strong>(04) @Retention(RetentionPolicy.RUNTIME)</strong></p><p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p><p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p><p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p><h3 id="2）java自带的Annotation"><a href="#2）java自带的Annotation" class="headerlink" title="2）java自带的Annotation"></a>2）java自带的Annotation</h3><p>通过上面的示例，我们能理解：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型，@Retention 用来指定 Annotation 的策略。</p><p>理解这一点之后，我们就很容易理解 java 中自带的 Annotation 的实现类，即 Annotation 架构图的右半边。如下图：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/08/28124653-adf73c4cdcce4a63b7bf78efbe1a9cdf.jpg" alt="img"></p><p><strong>java 常用的 Annotation：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。</span><br><span class="line">@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。</span><br><span class="line">@Documented  -- @Documented 所标注内容，可以出现在javadoc中。</span><br><span class="line">@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。</span><br><span class="line">@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</span><br><span class="line">@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</span><br><span class="line">@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</span><br></pre></td></tr></table></figure><p>由于 “@Deprecated 和 @Override” 类似，”@Documented, @Inherited, @Retention, @Target” 类似；下面，我们只对 @Deprecated, @Inherited, @SuppressWarnings 这 3 个 Annotation 进行说明。</p><p><strong>2.1) @Deprecated</strong></p><p>@Deprecated 的定义如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>(01) @interface – 它的用来修饰 Deprecated，意味着 Deprecated 实现了 java.lang.annotation.Annotation 接口；即 Deprecated 就是一个注解。 (02) @Documented – 它的作用是说明该注解能出现在 javadoc 中。</li><li>(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated 的信息保留在 .class 文件中，并且能被虚拟机读取。</li><li>(04) @Deprecated 所标注内容，不再被建议使用。</li></ul><p>例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息。</p><h1 id="4、Annotation-的作用"><a href="#4、Annotation-的作用" class="headerlink" title="4、Annotation 的作用"></a>4、Annotation 的作用</h1><p>Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。</p><p>我们在编程中经常会使用到的 Annotation 作用有：</p><h3 id="1）编译检查"><a href="#1）编译检查" class="headerlink" title="1）编译检查"></a>1）编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。</p><p>例如，@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><p>(01) 关于 @SuppressWarnings 和 @Deprecated，已经在”第3部分”中详细介绍过了。这里就不再举例说明了。</p><p>(02) 若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。</p><h3 id="2-在反射中使用-Annotation"><a href="#2-在反射中使用-Annotation" class="headerlink" title="2) 在反射中使用 Annotation"></a>2) 在反射中使用 Annotation</h3><p>在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。</p><p>这也意味着，我们可以在反射中解析并使用 Annotation。</p><h2 id="AnnotationTest-java"><a href="#AnnotationTest-java" class="headerlink" title="AnnotationTest.java"></a>AnnotationTest.java</h2><p><strong>import</strong> java.lang.annotation.Annotation;<br><strong>import</strong> java.lang.annotation.Target;<br><strong>import</strong> java.lang.annotation.ElementType;<br><strong>import</strong> java.lang.annotation.Retention;<br><strong>import</strong> java.lang.annotation.RetentionPolicy;<br><strong>import</strong> java.lang.annotation.Inherited;<br><strong>import</strong> java.lang.reflect.Method;</p><p><strong>/\</strong><br> * Annotation在反射函数中的使用示例<br> */**<br>@Retention(RetentionPolicy.RUNTIME)<br>@<strong>interface</strong> MyAnnotation {<br>  String[] value() <strong>default</strong> “unknown”;<br>}</p><p><strong>/\</strong><br> * Person类。它会使用MyAnnotation注解。<br> */**<br><strong>class</strong> Person {</p><p>  <strong>/\</strong><br>   * empty()方法同时被 “@Deprecated” 和 “@MyAnnotation(value={“a”,”b”})”所标注<br>   * (01) @Deprecated，意味着empty()方法，不再被建议使用<br>   * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值”unknown”<br>   */**<br>  @MyAnnotation<br>  @Deprecated<br>  <strong>public</strong> <strong>void</strong> empty(){<br>    System.out.println(“<strong>\n</strong>empty”);<br>  }</p><p>  <strong>/\</strong><br>   * sombody() 被 @MyAnnotation(value={“girl”,”boy”}) 所标注，<br>   * @MyAnnotation(value={“girl”,”boy”}), 意味着MyAnnotation的value值是{“girl”,”boy”}<br>   */**<br>  @MyAnnotation(value={“girl”,”boy”})<br>  <strong>public</strong> <strong>void</strong> somebody(String name, <strong>int</strong> age){<br>    System.out.println(“<strong>\n</strong>somebody: “+name+”, “+age);<br>  }<br>}</p><p><strong>public</strong> <strong>class</strong> AnnotationTest {</p><p>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) <strong>throws</strong> Exception {</p><pre><code>*// 新建Person*Person person = **new** Person();*// 获取Person的Class实例*Class&lt;Person&gt; c = Person.**class**;*// 获取 somebody() 方法的Method实例*Method mSomebody = c.getMethod(&quot;somebody&quot;, **new** **Class**[]&#123;String.**class**, **int**.**class**&#125;);*// 执行该方法*mSomebody.invoke(person, **new** Object[]&#123;&quot;lily&quot;, 18&#125;);iteratorAnnotations(mSomebody);</code></pre><p>​    <em>// 获取 somebody() 方法的Method实例</em><br>​    Method mEmpty = c.getMethod(“empty”, <strong>new</strong> <strong>Class</strong>[]{});<br>​    <em>// 执行该方法</em><br>​    mEmpty.invoke(person, <strong>new</strong> Object[]{});<br>​    iteratorAnnotations(mEmpty);<br>  }</p><p>  <strong>public</strong> <strong>static</strong> <strong>void</strong> iteratorAnnotations(Method method) {</p><p>​    <em>// 判断 somebody() 方法是否包含MyAnnotation注解</em><br>​    <strong>if</strong>(method.isAnnotationPresent(MyAnnotation.<strong>class</strong>)){<br>​      <em>// 获取该方法的MyAnnotation注解实例</em><br>​      MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.<strong>class</strong>);<br>​      <em>// 获取 myAnnotation的值，并打印出来</em><br>​      String[] values = myAnnotation.value();<br>​      <strong>for</strong> (String str:values)<br>​        System.out.printf(str+”, “);<br>​      System.out.println();<br>​    }<br>​<br>​    <em>// 获取方法上的所有注解，并打印出来</em><br>​    Annotation[] annotations = method.getAnnotations();<br>​    <strong>for</strong>(Annotation annotation : annotations){<br>​      System.out.println(annotation);<br>​    }<br>  }<br>}</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value&#x3D;[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value&#x3D;[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure><h3 id="3-根据-Annotation-生成帮助文档"><a href="#3-根据-Annotation-生成帮助文档" class="headerlink" title="3) 根据 Annotation 生成帮助文档"></a>3) 根据 Annotation 生成帮助文档</h3><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p><h3 id="4-能够帮忙查看查看代码"><a href="#4-能够帮忙查看查看代码" class="headerlink" title="4) 能够帮忙查看查看代码"></a>4) 能够帮忙查看查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><p>另外，我们也可以通过自定义 Annotation 来实现一些功能。</p>]]></content>
    
    <summary type="html">
    
      JAVA中一些常用的注解解析
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
      <category term="Annotation" scheme="http://yoursite.com/categories/JAVA/Annotation/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="Annotation" scheme="http://yoursite.com/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>转载-Nginx 配置 HTTPS 服务器</title>
    <link href="http://yoursite.com/2020/12/06/%E8%BD%AC%E8%BD%BD-Nginx-%E9%85%8D%E7%BD%AE-HTTPS-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2020/12/06/%E8%BD%AC%E8%BD%BD-Nginx-%E9%85%8D%E7%BD%AE-HTTPS-%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-12-06T15:12:00.000Z</published>
    <updated>2020-12-09T14:45:49.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx-配置-HTTPS-服务器"><a href="#Nginx-配置-HTTPS-服务器" class="headerlink" title="Nginx 配置 HTTPS 服务器"></a>Nginx 配置 HTTPS 服务器</h1><p>by <a href="https://github.com/mihanX">Mihan</a> on 2016-08-16</p><p>Chrome 浏览器地址栏标志着 HTTPS 的绿色小锁头从心理层面上可以给用户专业安全的心理暗示，本文简单总结一下如何在 Nginx 配置 HTTPS 服务器，让自己站点上『绿锁』。</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img1.jpg" alt="Nginx 配置 HTTPS"></p><p>Nginx 配置 HTTPS 并不复杂，主要有两个步骤：<strong>签署第三方可信任的 SSL 证书</strong> 和 <strong>配置 HTTPS</strong></p><h2 id="签署第三方可信任的-SSL-证书"><a href="#签署第三方可信任的-SSL-证书" class="headerlink" title="签署第三方可信任的 SSL 证书"></a>签署第三方可信任的 SSL 证书</h2><h3 id="关于-SSL-证书"><a href="#关于-SSL-证书" class="headerlink" title="关于 SSL 证书"></a>关于 SSL 证书</h3><p>有关 SSL 的介绍可以参阅维基百科的<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0">传输层安全协议</a>和阮一峰先生的 <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">《SSL/TLS协议运行机制的概述》</a>。</p><p>SSL 证书主要有两个功能：<strong>加密</strong>和<strong>身份证明</strong>，通常需要购买，也有免费的，通过第三方 SSL 证书机构颁发，常见可靠的第三方 SSL 证书颁发机构有下面几个：</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img10.jpg" alt="颁发 SSL 证书可靠的第三方机构"></p><p><a href="https://www.startssl.com/">StartCom</a> 机构上的 SSL 证书有以下几种：</p><ul><li>企业级别：EV(Extended Validation)、OV(Organization Validation)</li><li>个人级别：IV(Identity Validation)、DV（Domain Validation）</li></ul><p>其中 EV、OV、IV 需要付费</p><p>免费的证书安全认证级别一般比较低，不显示单位名称，不能证明网站的真实身份，仅起到加密传输信息的作用，适合个人网站或非电商网站。由于此类只验证域名所有权的低端 SSL 证书已经被国外各种欺诈网站滥用，因此强烈推荐部署验证单位信息并显示单位名称的 OV SSL 证书或申请最高信任级别的、显示绿色地址栏、直接在地址栏显示单位名称的 EV SSL 证书，就好像 <a href="https://www.startssl.com/">StarCom</a> 的地址栏一样：</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img2.jpg" alt="StarCom"></p><p>更多关于购买 SSL 证书的介绍：<a href="https://www.zhihu.com/question/19578422">SSL 证书服务，大家用哪家的？</a>、<a href="http://freessl.wosign.com/freessl">DV免费SSL证书</a></p><h3 id="使用-OpenSSL-生成-SSL-Key-和-CSR-文件"><a href="#使用-OpenSSL-生成-SSL-Key-和-CSR-文件" class="headerlink" title="使用 OpenSSL 生成 SSL Key 和 CSR 文件"></a>使用 OpenSSL 生成 SSL Key 和 CSR 文件</h3><p>配置 HTTPS 要用到私钥 example.key 文件和 example.crt 证书文件，申请证书文件的时候要用到 example.csr 文件，<code>OpenSSL</code> 命令可以生成 example.key 文件和 example.csr 证书文件。</p><ul><li>CSR：Cerificate Signing Request，证书签署请求文件，里面包含申请者的 DN（Distinguished Name，标识名）和公钥信息，<strong>在第三方证书颁发机构签署证书的时候需要提供</strong>。证书颁发机构拿到 CSR 后使用其根证书私钥对证书进行加密并生成 CRT 证书文件，里面包含证书加密信息以及申请者的 DN 及公钥信息</li><li>Key：证书申请者私钥文件，和证书里面的公钥配对使用，在 HTTPS 『握手』通讯过程需要使用私钥去解密客戶端发來的经过证书公钥加密的随机数信息，是 HTTPS 加密通讯过程非常重要的文件，<strong>在配置 HTTPS 的時候要用到</strong></li></ul><p>使用 <code>OpenSSl</code>命令可以在系统当前目录生成 <strong>example.key</strong> 和 <strong>example.csr</strong> 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -newkey rsa:2048 -sha256 -nodes -out example_com.csr -keyout example_com.key -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;ShenZhen&#x2F;L&#x3D;ShenZhen&#x2F;O&#x3D;Example Inc.&#x2F;OU&#x3D;Web Security&#x2F;CN&#x3D;example.com&quot;</span><br></pre></td></tr></table></figure><p>下面是上述命令相关字段含义：</p><ul><li>C：Country ，单位所在国家，为两位数的国家缩写，如： CN 就是中国</li><li>ST 字段： State/Province ，单位所在州或省</li><li>L 字段： Locality ，单位所在城市 / 或县区</li><li>O 字段： Organization ，此网站的单位名称;</li><li>OU 字段： Organization Unit，下属部门名称;也常常用于显示其他证书相关信息，如证书类型，证书产品名称或身份验证类型或验证内容等;</li><li>CN 字段： Common Name ，网站的域名;</li></ul><p>生成 csr 文件后，提供给 CA 机构，签署成功后，就会得到一個 <strong>example.crt</strong> 证书文件，SSL 证书文件获得后，就可以在 Nginx 配置文件里配置 HTTPS 了。</p><h2 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>要开启 HTTPS 服务，在配置文件信息块(server block)，必须使用监听命令 <code>listen</code> 的 ssl 参数和定义服务器证书文件和私钥文件，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    #ssl参数</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    server_name         example.com;</span><br><span class="line">    #证书文件</span><br><span class="line">    ssl_certificate     example.com.crt;</span><br><span class="line">    #私钥文件</span><br><span class="line">    ssl_certificate_key example.com.key;</span><br><span class="line">    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证书文件会作为公用实体發送到每台连接到服务器的客戶端，私钥文件作为安全实体，<strong>应该被存放在具有一定权限限制的目录文件，并保证 Nginx 主进程有存取权限</strong>。</p><p>私钥文件也有可能会和证书文件同放在一個文件中，如下面情況：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_certificate     www.example.com.cert;</span><br><span class="line">ssl_certificate_key www.example.com.cert;</span><br></pre></td></tr></table></figure><p>这种情況下，证书文件的的读取权限也应该加以限制，仅管证书和私钥存放在同一个文件里，但是只有证书会被发送到客戶端</p><p>命令 <code>ssl_protocols</code> 和 <code>ssl_ciphers</code> 可以用来限制连接只包含 SSL/TLS 的加強版本和算法，默认值如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_ciphers HIGH:!aNULL:!MD5;</span><br></pre></td></tr></table></figure><p>由于这两个命令的默认值已经好几次发生了改变，因此不建议显性定义，除非有需要额外定义的值，如定义 D-H 算法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用DH文件</span><br><span class="line">ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#定义算法</span><br><span class="line">ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br><span class="line">#...</span><br></pre></td></tr></table></figure><h3 id="HTTPS服务器优化"><a href="#HTTPS服务器优化" class="headerlink" title="HTTPS服务器优化"></a>HTTPS服务器优化</h3><h4 id="减少-CPU-运算量"><a href="#减少-CPU-运算量" class="headerlink" title="减少 CPU 运算量"></a>减少 CPU 运算量</h4><p>SSL 的运行计算需要消耗额外的 CPU 资源，一般多核处理器系统会运行多个工作进程(<a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes">worker processes </a>)，进程的数量不会少于可用的 CPU 核数。SSL 通讯过程中『握手』阶段的运算最占用 CPU 资源，有两个方法可以减少每台客户端的运算量：</p><ul><li><strong>激活 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#keepalive_timeout">keepalive</a> 长连接，一个连接发送更多个请求</strong></li><li><strong>复用 SSL 会话参数，在并行并发的连接数中避免进行多次 SSL『握手』</strong></li></ul><p>这些会话会存储在一个 SSL 会话缓存里面，通过命令 <a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_cache">ssl_session_cache</a> 配置，可以使缓存在机器间共享，然后利用客戶端在『握手』阶段使用的 <code>seesion id</code> 去查询服务端的 session cathe(如果服务端设置有的话)，简化『握手』阶段。</p><p>1M 的会话缓存大概包含 4000 個会话，默认的缓存超时时间为 5 分钟，可以通过使用 <a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_timeout">ssl_session_timeout</a> 命令设置缓存超时时间。下面是一個拥有 10M 共享会话缓存的多核系统优化配置例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    #配置共享会话缓存大小</span><br><span class="line">    ssl_session_cache   shared:SSL:10m;</span><br><span class="line">    #配置会话超时时间</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         www.example.com;</span><br><span class="line">        #设置长连接</span><br><span class="line">        keepalive_timeout   70;</span><br><span class="line"></span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        ssl_certificate_key www.example.com.key;</span><br><span class="line">        ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line">        #...</span><br></pre></td></tr></table></figure><h4 id="使用-HSTS-策略强制浏览器使用-HTTPS-连接"><a href="#使用-HSTS-策略强制浏览器使用-HTTPS-连接" class="headerlink" title="使用 HSTS 策略强制浏览器使用 HTTPS 连接"></a>使用 HSTS 策略强制浏览器使用 HTTPS 连接</h4><p>HSTS – HTTP Strict Transport Security，HTTP严格传输安全。它允许一个 HTTPS 网站要求浏览器总是通过 HTTPS 来访问，这使得攻击者在用戶与服务器通讯过程中拦截、篡改信息以及冒充身份变得更为困难。</p><p>只要在 Nginx 配置文件加上以下头信息就可以了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubDomains;preload&quot; always;</span><br></pre></td></tr></table></figure><ul><li>max-age：设置单位时间内強制使用 HTTPS 连接</li><li>includeSubDomains：可选，所有子域同时生效</li><li>preload：可选，<em>非规范值</em>，用于定义使用『HSTS 预加载列表』</li><li>always：可选，保证所有响应都发送此响应头，包括各种內置错误响应</li></ul><p>当用户进行 HTTPS 连接的时候，服务器会发送一个 <strong>Strict-Transport-Security</strong> 响应头：</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img9.jpg" alt="STS Header"></p><p>浏览器在获取该响应头后，在 <code>max-age</code> 的时间内，如果遇到 HTTP 连接，就会通过 307 跳转強制使用 HTTPS 进行连接，并忽略其它的跳转设置（如 301 重定向跳转）：</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img6.jpg" alt="HSTS"></p><p>307 跳转 <strong>Non-Authoritative-Reason</strong> 响应头</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img5.jpg" alt="HSTS"></p><h5 id="Google-HSTS-预加载列表（HSTS-Preload-List）"><a href="#Google-HSTS-预加载列表（HSTS-Preload-List）" class="headerlink" title="Google HSTS 预加载列表（HSTS Preload List）"></a>Google HSTS 预加载列表（HSTS Preload List）</h5><p>由于 HSTS 需要用戶经过一次安全的 HTTPS 连接后才会在 max-age 的时间內生效，因此HSTS 策略并不能完美防止 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/06.4.md">HTTP 会话劫持（HTTP session hijacking）</a>，在下面这些情況下还是存在被劫持的可能：</p><ul><li>从未访问过的网站</li><li>近期重裝过操作系統</li><li>近期重裝过浏览器</li><li>使用新的浏览器</li><li>使用了新的设备（如手机）</li><li>刪除了浏览器缓存</li><li>近期沒有打开过网站且 max-age 过期</li></ul><p>针对这种情況，Google 维护了一份『HSTS 预加载列表』，列表里包含了使用了 HSTS 的站点主域名和子域名，可以通过以下页面申请加入：</p><p><a href="https://hstspreload.appspot.com/">https://hstspreload.appspot.com/.</a></p><p>申请的时候会先验证站点是否符合资格，一般会检验待验证的站点主域和子域是否能通过 HTTPS 连接、HTTPS 和 HTTP 配置是否有 STS Header 等信息，通过验证后，会让你确认一些限制信息，如下图：</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img8.jpg" alt="HSTS"></p><p>当确认提交后，就会显示处理状态：</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img11.jpg" alt="HSTS"></p><p>申请通过后，列表内的站点名会被写进主流的浏览器，当浏览器更新版本后，只要打开列表内的站点，浏览器会拒绝所有 HTTP 连接而自动使用 HTTPS，即使关闭了 HSTS 设置。</p><p>可以在下面两个连接分別查找 Chrome 和 Firfox 的『HSTS 预加载列表』内容：</p><p><a href="https://www.chromium.org/hsts">The Chromium Projects - HTTP Strict Transport Security</a></p><p><a href="https://dxr.mozilla.org/comm-central/source/mozilla/security/manager/ssl/nsSTSPreloadList.inc">Firefox HSTS preload list - nsSTSPreloadList.inc</a></p><p><strong>需要注意的是：</strong></p><ul><li>一旦把自己的站点名加入『HSTS 预加载列表』，将很难彻底从列表中移除，因为不能保证其它浏览器可以及时移除，即使 Chrome 提供有便捷的移除方法，也是要通过出邮件联系，注明移除原因，并等到最新的浏览器版本更新发布才有机会（用戶不一定会及时更新）</li><li>所有不具备有效证书的子域或內嵌子域的访问将会被阻止</li></ul><p><strong>因此，如果自己站点子域名变化比较多，又沒有泛域证书，又沒法确定全站是否能应用 HTTPS 的朋友，就要谨慎申请了。</strong></p><p>更多关于 HSTS 配置可参考：</p><p><a href="https://www.nginx.com/blog/http-strict-transport-security-hsts-and-nginx/">《HTTP Strict Transport Security (HSTS) and NGINX》</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security#Preloading_Strict_Transport_Security">MDN的《HTTP Strict Transport Security》</a></p><h5 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h5><p><img src="https://misc.aotu.io/mihanX/nginx-https/img7.jpg" alt="Compatibility"></p><h4 id="加强-HTTPS-安全性"><a href="#加强-HTTPS-安全性" class="headerlink" title="加强 HTTPS 安全性"></a>加强 HTTPS 安全性</h4><p>HTTPS 基础配置采取的默认加密算法是 SHA-1，这个算法非常脆弱，安全性在逐年降低，在 2014 年的时候， <strong>Google 官方博客就宣布在 Chrome 浏览器中逐渐降低 SHA-1 证书的安全指示，会从 2015 年起使用 SHA-2 签名的证书</strong>，可参阅 <a href="http://www.freebuf.com/author/rabbit_run">Rabbit_Run</a> 在 2014 年发表的文章：<a href="http://www.freebuf.com/news/topnews/44288.html">《为什么Google急着杀死加密算法SHA-1》</a></p><p>为此，主流的 HTTPS 配置方案应该避免 SHA-1，可以使用 <a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B">迪菲-赫尔曼密钥交换（D-H，Diffie–Hellman key exchange）</a>方案。</p><p>首先在目录 <code>/etc/ssl/certs</code> 运行以下代码生成 <code>dhparam.pem</code> 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dhparam -out dhparam.pem 2048</span><br></pre></td></tr></table></figure><p>然后加入 Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优先采取服务器算法</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">#使用DH文件</span><br><span class="line">ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#定义算法</span><br><span class="line">ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br></pre></td></tr></table></figure><p>如果服务器夠強大，可以使用更为复杂的 4096 位进行加密。</p><p>一般情況下还应该加上以下几个增强安全性的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#减少点击劫持</span><br><span class="line">add_header X-Frame-Options DENY;</span><br><span class="line">#禁止服务器自动解析资源类型</span><br><span class="line">add_header X-Content-Type-Options nosniff;</span><br><span class="line">#防XSS攻击</span><br><span class="line">add_header X-Xss-Protection 1;</span><br></pre></td></tr></table></figure><p>这几个安全命令在 <a href="https://imququ.com/">Jerry Qu</a> 大神的文章<a href="https://imququ.com/post/web-security-and-response-header.html">《一些安全相关的HTTP响应头》</a>有详细的介紹。</p><h3 id="优化后的综合配置"><a href="#优化后的综合配置" class="headerlink" title="优化后的综合配置"></a>优化后的综合配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes auto;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    #配置共享会话缓存大小，视站点访问情况设定</span><br><span class="line">    ssl_session_cache   shared:SSL:10m;</span><br><span class="line">    #配置会话超时时间</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen              443 ssl;</span><br><span class="line">        server_name         www.example.com;</span><br><span class="line">        </span><br><span class="line">        #设置长连接</span><br><span class="line">        keepalive_timeout   70;</span><br><span class="line">        </span><br><span class="line">        #HSTS策略</span><br><span class="line">        add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubDomains; preload&quot; always;</span><br><span class="line">        </span><br><span class="line">        #证书文件</span><br><span class="line">        ssl_certificate     www.example.com.crt;</span><br><span class="line">        #私钥文件</span><br><span class="line">        ssl_certificate_key www.example.com.key; </span><br><span class="line">        </span><br><span class="line">        #优先采取服务器算法</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        #使用DH文件</span><br><span class="line">        ssl_dhparam &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;dhparam.pem;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        #定义算法</span><br><span class="line">        ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br><span class="line">        #减少点击劫持</span><br><span class="line">        add_header X-Frame-Options DENY;</span><br><span class="line">        #禁止服务器自动解析资源类型</span><br><span class="line">        add_header X-Content-Type-Options nosniff;</span><br><span class="line">        #防XSS攻擊</span><br><span class="line">        add_header X-Xss-Protection 1;</span><br><span class="line">        #...</span><br></pre></td></tr></table></figure><h3 id="HTTP-HTTPS混合服务器配置"><a href="#HTTP-HTTPS混合服务器配置" class="headerlink" title="HTTP/HTTPS混合服务器配置"></a>HTTP/HTTPS混合服务器配置</h3><p>可以同时配置 HTTP 和 HTTPS 服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              80;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    server_name         www.example.com;</span><br><span class="line">    ssl_certificate     www.example.com.crt;</span><br><span class="line">    ssl_certificate_key www.example.com.key;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 0.7.14 版本之前，在独立的 server 端口中是不能选择性开启 SSL 的</strong>。如上面的例子，SSL 只能通过使用 <a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl">ssl</a> 命令为单个 server 端口开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              443;</span><br><span class="line">    server_name         www.example.com;</span><br><span class="line">    ssl_certificate     www.example.com.crt;</span><br><span class="line">    ssl_certificate_key www.example.com.key;</span><br><span class="line">    #ssl命令开启 https</span><br><span class="line">    ssl on;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此没有辦法设置 HTTP/HTTPS 混合服务器。于是 Nginx 新增了监听命令 <a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#listen">listen</a>参数 <code>ssl</code> 來解决这个问题，<strong>Nginx 現代版本的<code>ssl</code>命令并不推荐使用</strong></p><h3 id="基于服务器名称（name-based）的-HTTPS-服务器"><a href="#基于服务器名称（name-based）的-HTTPS-服务器" class="headerlink" title="基于服务器名称（name-based）的 HTTPS 服务器"></a>基于服务器名称（name-based）的 HTTPS 服务器</h3><p>一个常见的问题就是当使用同一个 IP 地址去配置两个或更多的 HTTPS 服务器的时候，出现证书不匹配的情況：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          443 ssl;</span><br><span class="line">    server_name     www.example.com;</span><br><span class="line">    ssl_certificate www.example.com.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          443 ssl;</span><br><span class="line">    server_name     www.example.org;</span><br><span class="line">    ssl_certificate www.example.org.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下浏览器会获取默认的服务器证书（如上面例子的 <a href="www.example.com.crt">www.example.com.crt</a>)  而忽视请求的服务器名，如输入网址：<code>www.example.org</code> ,  服务器会发送) <code>www.example.com.crt</code> 的证书到客戶端，而不是 <code>www.exaple.org.crt</code>。</p><p>这是因为 SSL 协议行为所致，SSL 连接在浏览器发送 HTTP 请求之前就被建立，Nginx 并不知道被请求的服务器名字，因此 Nginx 只会提供默认的服务器证书。</p><p><img src="https://misc.aotu.io/mihanX/nginx-https/img4.jpg" alt="证书获取异常"></p><p>解決这个问题最原始最有效的方法就是为每个 HTTPS 服务器分配独立的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen          192.168.1.1:443 ssl;</span><br><span class="line">    server_name     www.example.com;</span><br><span class="line">    ssl_certificate www.example.com.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen          192.168.1.2:443 ssl;</span><br><span class="line">    server_name     www.example.org;</span><br><span class="line">    ssl_certificate www.example.org.crt;</span><br><span class="line">    #...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更多解決方案"><a href="#更多解決方案" class="headerlink" title="更多解決方案"></a>更多解決方案</h4><p>除此之外，官方还介绍了两个方法：<strong>泛域证书</strong>和<strong>域名指示（SNI）</strong></p><p>其实 OpenSSL 在 <strong>0.9.8f版本</strong>就支持 SNI 了，只要在安裝的时候加上 <code>--enable-tlsext</code> 选项就可以。到了 <strong>0.9.8j版本</strong>，这个选项在安裝的时候会默认启用。如果创建 Nginx 的时候支持 SNI，可以在 Nginx 版本信息查到以下的字段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TLS SNI support enabled</span><br></pre></td></tr></table></figure><p>因此，如果较新版本的 Nginx 使用默认的 OpenSSL 库，<strong>是不存在使用 HTTPS 同时支持基于名字的虚拟主机的时候同 IP 不同域名证书不匹配的问题</strong>。</p><p><em>注意：即使新版本的 Nginx 在创建时支持了 SNI，如果 Nginx 动态加载不支持 SNI 的 OpenSSL 库的话，SNI 扩展将不可用</em></p><p>有兴趣的朋友可以看下：</p><p><a href="http://nginx.org/en/docs/http/configuring_https_servers.html">An SSL certificate with several names &amp;&amp; Server Name Indication</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，我们简单总结一下在 Nginx 下配置 HTTPS 的关键要点：</p><ul><li><strong>获得 SSL 证书</strong><ul><li>通过 OpenSSL 命令获得 example.key 和 example.csr 文件</li><li>提供 example.csr 文件给第三方可靠证书颁发机构，选择适合的安全级别证书并签署，获得 example.crt 文件</li></ul></li><li><strong>通过 listen 命令 SSL 参数以及引用 example.key 和 example.crt 文件完成 HTTPS 基础配置</strong></li><li><strong>HTTPS优化</strong><ul><li>减少 CPU 运算量<ul><li>使用 keepalive 长连接</li><li>复用 SSL 会话参数</li></ul></li><li>使用 HSTS 策略强制浏览器使用 HTTPS 连接<ul><li>添加 Strict-Transport-Security 头部信息</li><li>使用 HSTS 预加载列表（HSTS Preload List）</li></ul></li><li>加强 HTTPS 安全性<ul><li>使用迪菲-赫尔曼密钥交换（D-H，Diffie–Hellman key exchange）方案</li><li>添加 X-Frame-Options 头部信息，减少点击劫持</li><li>添加 X-Content-Type-Options 头部信息，禁止服务器自动解析资源类型</li><li>添加 X-Xss-Protection 头部信息，防XSS攻击</li></ul></li></ul></li><li><strong>HTTP/HTTPS混合服务器配置</strong></li><li><strong>基于服务器名称（name-based）的 HTTPS 服务器</strong><ul><li>为每个 HTTPS 服务器分配独立的 IP 地址</li><li>泛域证书</li><li>域名标识（SNI）</li></ul></li></ul><p>其实简单的个人博客，如果没有敏感数据交互的话，使用 http 协议通讯，一般都夠用了，页面速度还会更快，但正如文章开头所说，戴上『绿锁』，更专业更安全~~有兴趣的同学可以去深入了解折腾下：）</p>]]></content>
    
    <summary type="html">
    
      Nginx 配置 HTTPS 服务器
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Linux/Nginx/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Autowired的三种注入方式</title>
    <link href="http://yoursite.com/2020/12/04/@Autowired%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/12/04/@Autowired%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2020-12-05T14:25:18.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Autowired的三种注入方式"><a href="#Autowired的三种注入方式" class="headerlink" title="@Autowired的三种注入方式"></a>@Autowired的三种注入方式</h1><h2 id="Field-injection-is-not-recommended（不再推荐使用字段注入）"><a href="#Field-injection-is-not-recommended（不再推荐使用字段注入）" class="headerlink" title="Field injection is not recommended（不再推荐使用字段注入）"></a>Field injection is not recommended（不再推荐使用字段注入）</h2><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h2><p>最近公司升级框架，由原来的<code>spring framerwork 3.0</code>升级到<code>5.0</code>，然后写代码的时候突然发现idea在属性注入的**@Autowired**注解上给出警告提示，就像下面这样的，也挺懵逼的，毕竟这么写也很多年了。</p><blockquote><p>Field injection is not recommended</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-5b102c68eb1becb08e60ba8866784aba_720w.png" alt="img"></p><p>查阅了相关文档了解了一下，原来这个提示是<code>spring framerwork 4.0</code>以后开始出现的，spring 4.0开始就不推荐使用属性注入，改为推荐构造器注入和setter注入。</p><p>下面将展示了spring框架可以使用的不同类型的依赖注入，以及每种依赖注入的适用情况。</p><h2 id="2-依赖注入的类型"><a href="#2-依赖注入的类型" class="headerlink" title="2. 依赖注入的类型"></a>2. 依赖注入的类型</h2><p>尽管针对<code>spring framerwork 5.1.3</code>的<a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html%23beans-factory-collaborators">文档</a>只定义了两种主要的依赖注入类型，但实际上有三种;</p><ul><li>基于构造函数的依赖注入</li><li>基于setter的依赖注入</li><li>基于字段的依赖注入</li></ul><p>其中<code>基于字段的依赖注入</code>被广泛使用，但是idea或者其他静态代码分析工具会给出提示信息，不推荐使用。</p><p>甚至可以在一些Spring官方指南中看到这种注入方法:</p><p><img src="https://pic1.zhimg.com/80/v2-04271e646164721421b85eedd07c1864_720w.jpg" alt="img"></p><h3 id="2-1-基于构造函数的依赖注入"><a href="#2-1-基于构造函数的依赖注入" class="headerlink" title="2.1 基于构造函数的依赖注入"></a>2.1 基于构造函数的依赖注入</h3><p>在基于构造函数的依赖注入中，类构造函数被标注为**@Autowired**，并包含了许多与要注入的对象相关的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorBasedInjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InjectedBean injectedBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorBasedInjection</span><span class="params">(InjectedBean injectedBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.injectedBean = injectedBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在spring<a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.0.3.RELEASE/spring-framework-reference/core.html%23beans-constructor-injection">官方文档</a>中，**@Autowired**注解也是可以省去的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于构造函数注入的主要优点是可以将需要注入的字段声明为<strong>final</strong>， 使得它们会在类实例化期间被初始化，这对于所需的依赖项很方便。</p><h3 id="2-2-基于Setter的依赖注入"><a href="#2-2-基于Setter的依赖注入" class="headerlink" title="2.2 基于Setter的依赖注入"></a>2.2 基于Setter的依赖注入</h3><p>在基于setter的依赖注入中，setter方法被标注为**@Autowired**。一旦使用无参数构造函数或无参数静态工厂方法实例化Bean，为了注入Bean的依赖项，Spring容器将调用这些setter方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetterBasedInjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InjectedBean injectedBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectedBean</span><span class="params">(InjectedBean injectedBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.injectedBean = injectedBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和基于构造器的依赖注入一样，在<a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.0.3.RELEASE/spring-framework-reference/core.html%23beans-setter-injection">官方文档</a>中，基于Setter的依赖注入中的**@Autowired**也可以省去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-基于属性的依赖注入"><a href="#2-3-基于属性的依赖注入" class="headerlink" title="2.3 基于属性的依赖注入"></a>2.3 基于属性的依赖注入</h3><p>在基于属性的依赖注入中，字段/属性被标注为**@Autowired**。一旦类被实例化，Spring容器将设置这些字段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldBasedInjection</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InjectedBean injectedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如所看到的，这是依赖注入最干净的方法，因为它避免了添加样板代码，并且不需要声明类的构造函数。代码看起来很干净简洁，但是正如代码检查器已经向我们暗示的那样，这种方法有一些缺点。</p><h2 id="3-基于字段的依赖注入缺陷"><a href="#3-基于字段的依赖注入缺陷" class="headerlink" title="3. 基于字段的依赖注入缺陷"></a>3. 基于字段的依赖注入缺陷</h2><h3 id="3-1-不允许声明不可变域"><a href="#3-1-不允许声明不可变域" class="headerlink" title="3.1 不允许声明不可变域"></a>3.1 不允许声明不可变域</h3><p>基于字段的依赖注入在声明为final/immutable的字段上不起作用，因为这些字段必须在类实例化时实例化。声明不可变依赖项的惟一方法是使用基于构造器的依赖注入。</p><h3 id="3-2-容易违反单一职责设计原则"><a href="#3-2-容易违反单一职责设计原则" class="headerlink" title="3.2 容易违反单一职责设计原则"></a>3.2 容易违反单一职责设计原则</h3><p>在面向对象的编程中，五大设计原则**<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>**被广泛应用，（国内一般为六大设计原则），用以提高代码的重用性，可读性，可靠性和可维护性</p><p><strong><em><a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Single_responsibility_principle">S</a></em></strong>在<strong>SOLID</strong>中代表单一职责原则，即即一个类应该只负责一项职责，这个类提供的所有服务都应该只为它负责的职责服务。</p><p>使用基于字段的依赖注入，高频使用的类随着时间的推移，我们会在类中逐渐添加越来越多的依赖项，我们用着很爽，很容易忽略类中的依赖已经太多了。但是如果使用基于构造函数的依赖注入，随着越来越多的依赖项被添加到类中，构造函数会变得越来越大，我们一眼就可以察觉到哪里不对劲。</p><p>有一个有超过10个参数的构造函数是一个明显的信号，表明类已经转变一个大而全的功能合集，需要将类分割成更小、更容易维护的块。</p><p>因此，尽管属性注入并不是破坏单一责任原则的直接原因，但它隐藏了信号，使我们很容易忽略这些信号。</p><h3 id="3-3-与依赖注入容器紧密耦合"><a href="#3-3-与依赖注入容器紧密耦合" class="headerlink" title="3.3 与依赖注入容器紧密耦合"></a>3.3 与依赖注入容器紧密耦合</h3><p>使用基于字段的依赖注入的主要原因是为了避免getter和setter的样板代码或为类创建构造函数。最后，这意味着设置这些字段的唯一方法是通过Spring容器实例化类并使用反射注入它们，否则字段将保持null。</p><p>依赖注入设计模式将类依赖项的创建与类本身分离开来，并将此责任转移到类注入容器，从而允许程序设计解耦，并遵循单一职责和依赖项倒置原则(同样可靠)。因此，通过自动装配（autowiring）字段来实现的类的解耦，最终会因为再次与类注入容器(在本例中是Spring)耦合而丢失，从而使类在Spring容器之外变得无用。</p><p>这意味着，如果您想在应用程序容器之外使用您的类，例如用于单元测试，您将被迫使用Spring容器来实例化您的类，因为没有其他可能的方法(除了反射)来设置自动装配字段。</p><p>依赖注入容器耦合<br>DI框架的核心思想之一是托管类不应该依赖于所使用的DI容器。换句话说，它应该只是一个普通的POJO，可以独立地实例化它，前提是将所有必需的依赖项传递给它。通过这种方式，您可以在单元测试中实例化它，而不需要启动DI容器，并单独测试它(使用的容器更像是集成测试)。如果没有容器耦合，则可以将该类作为托管或非托管类使用，甚至可以切换到新的DI框架。</p><p>然而，当直接注入字段时，您无法直接用所有需要的依赖项实例化类。这意味着:<br>1）有一种方法(通过调用默认构造函数)可以在一个状态中使用new来创建一个对象，该状态中缺少一些强制协作者，使用将导致NullPointerException。<br>2）这样的类不能在DI容器(测试、其他模块)之外重用，因为除了反射之外，没有其他方法为它提供所需的依赖项。</p><h3 id="3-4-隐藏依赖关系"><a href="#3-4-隐藏依赖关系" class="headerlink" title="3.4 隐藏依赖关系"></a>3.4 隐藏依赖关系</h3><p>在使用依赖注入时，受影响的类应该使用公共接口清楚地公开这些依赖项，方法是在构造函数中公开所需的依赖项，或者使用方法(setter)公开可选的依赖项。当使用基于字段的依赖注入时，实质上是将这些依赖对外隐藏了。</p><h3 id="3-5-初始化时优先级较低"><a href="#3-5-初始化时优先级较低" class="headerlink" title="3.5 初始化时优先级较低"></a>3.5 初始化时优先级较低</h3><p><img src="/2020/12/04/@Autowired%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/Users\13470\AppData\Roaming\Typora\typora-user-images\image-20201029190009906.png" alt="image-20201029190009906"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我们已经看到，基于字段的注入应该尽可能地避免，因为它有许多缺点，无论它看起来多么优雅。推荐的方法是使用基于构造函数和基于setter的依赖注入。对于必需的依赖，建议使用基于构造函数的注入，设置它们为不可变的，并防止它们为null。对于可选的依赖项，建议使用基于sett的注入。</p><h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h2><p><em><a href="https://link.zhihu.com/?target=http://blog.marcnuri.com/field-injection-is-not-recommended/">Field injection is not recommended – Spring IOC</a></em> <em>by <a href="https://link.zhihu.com/?target=http://blog.marcnuri.com/author/marcnuri/">Marc Nuri</a></em></p><p><em><a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html%23beans-factory-collaborators">spring官方文档 1.4. Dependencies</a></em></p><h1 id="Field-injection-is-not-recommended（不再推荐使用字段注入）-1"><a href="#Field-injection-is-not-recommended（不再推荐使用字段注入）-1" class="headerlink" title="Field injection is not recommended（不再推荐使用字段注入）"></a>Field injection is not recommended（不再推荐使用字段注入）</h1><p>优点：变量方式注入非常简洁，没有任何多余代码，非常有效的提高了java的简洁性。即使再多几个依赖一样能解决掉这个问题。</p><p>缺点：不能有效的指明依赖。相信很多人都遇见过一个bug，依赖注入的对象为null，在启动依赖容器时遇到这个问题都是配置的依赖注入少了一个注解什么的，然而这种方式就过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。<br>在使用set方式时，这是一种选择注入，可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。<br>在使用构造器方式时已经显式注明必须强制注入。通过强制指明依赖注入来保证这个类的运行。</p><p>另一个方面：<br>依赖注入的核心思想之一就是被容器管理的类不应该依赖被容器管理的依赖，换成白话来说就是如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。<br>既然使用了依赖注入方式，那么就表明这个类不再对这些依赖负责，这些都由容器管理，那么如何清楚的知道这个类需要哪些依赖呢？它就要使用set方法方式注入或者构造器注入。</p><p>总结下：<br>变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Autowired的三种注入方式&quot;&gt;&lt;a href=&quot;#Autowired的三种注入方式&quot; class=&quot;headerlink&quot; title=&quot;@Autowired的三种注入方式&quot;&gt;&lt;/a&gt;@Autowired的三种注入方式&lt;/h1&gt;&lt;h2 id=&quot;Field-i
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="Autowired" scheme="http://yoursite.com/tags/Autowired/"/>
    
  </entry>
  
  <entry>
    <title>Java中为什么不允许直接创建泛型数组</title>
    <link href="http://yoursite.com/2020/12/04/Java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/12/04/Java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2020-12-04T12:51:48.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中为什么不允许直接创建泛型数组"><a href="#Java中为什么不允许直接创建泛型数组" class="headerlink" title="Java中为什么不允许直接创建泛型数组"></a>Java中为什么不允许直接创建泛型数组</h1><p>在Java中，如果创建泛型数组，会出现以下编译错误, 例如<br><code>List&lt;String&gt;[] stringLists = new List&lt;String&gt;[10];</code><br>会提示<br><code>Error:(9, 38) java: 创建泛型数组</code><br>但是却可以创建泛型数组的引用<br><code>List&lt;String&gt;[] stringLists = null;</code><br>并将一个普通数组的引用赋值给它。<br><code>List&lt;String&gt;[] stringLists = new List[10];</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt;[] stringLists = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        stringLists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringLists[<span class="number">0</span>].add(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中为什么不允许直接创建泛型数组？<br>《Effective Java》第五章给出了一个解释：</p><blockquote><p>使用泛型的作用是使得程序在编译期可以检查出与类型相关的错误，但是如果使用了泛型数组，这种能力就会受到破坏。</p></blockquote><p>假如我们可以声明这样一个泛型数组（实际上是不可以的）：<br><code>List&lt;String&gt;[] stringLists = new List&lt;String&gt;[10];</code><br>由于在 Java 中，数组是协变(covariant)的，这意味着基类类型的数组可以接收子类类型的数组，例如：<br><code>Object[] objects = stringLists;</code><br>一旦我们这样做之后，就可以通过objects向 stringLists中添加非<code>List&lt;String&gt;</code>类型的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>);</span><br><span class="line">objects[<span class="number">0</span>] = intList;<span class="number">12</span></span><br></pre></td></tr></table></figure><p>随后，再使用 stringList 时，stringList[0] 就会保存 intList, 而使用下面的代码，编译器不会提示错误，但运行时，就会出错。<br><code>String str = stringList[0].get(0);</code></p><p>即使创建出来“泛型数组”以上错误也依然存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] stringLists = (List&lt;String&gt;[])<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">Object[] objects = stringLists;</span><br><span class="line">List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>);</span><br><span class="line">objects[<span class="number">0</span>] = intList;</span><br><span class="line">String str = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">//runtime error12345</span></span><br></pre></td></tr></table></figure><hr><p>当我们创建泛型容器时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E elem[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_ARRAY_LENGTH = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elem = <span class="keyword">new</span> E[INITIAL_ARRAY_LENGTH]; <span class="comment">//编译期就会报错：不能创建泛型数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E elem[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(Class&lt;?&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        elem = (E[]) java.lang.reflect.Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        elem[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E elem[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        elem = (E[]) <span class="keyword">new</span> Object[size];<span class="comment">//强制类型转换就是为了逃避编译时的检查</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        elem[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Array&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;elem=&quot;</span> + Arrays.toString(elem) +</span><br><span class="line">                <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的出现在很大程度上是为了避免运行时出现烦人的 <code>ClassCastException</code>，可是具有讽刺意味的是，泛型数组却又导致了<br><code>ClassCastException</code>异常的出现。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Z[][] array=(Z[][])(Array.newInstance(Class&lt;Z&gt; <span class="class"><span class="keyword">class</span> ,<span class="title">XLabel</span>.<span class="title">size</span>(),<span class="title">YLabel</span>.<span class="title">size</span>()))</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中为什么不允许直接创建泛型数组&quot;&gt;&lt;a href=&quot;#Java中为什么不允许直接创建泛型数组&quot; class=&quot;headerlink&quot; title=&quot;Java中为什么不允许直接创建泛型数组&quot;&gt;&lt;/a&gt;Java中为什么不允许直接创建泛型数组&lt;/h1&gt;&lt;p&gt;在J
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Springboot中配置SSL证书</title>
    <link href="http://yoursite.com/2020/12/04/Springboot%E4%B8%AD%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://yoursite.com/2020/12/04/Springboot%E4%B8%AD%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2020-12-04T12:51:02.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot中配置SSL证书"><a href="#Springboot中配置SSL证书" class="headerlink" title="Springboot中配置SSL证书"></a>Springboot中配置SSL证书</h1><h2 id="一、为什么要部署SSL证书："><a href="#一、为什么要部署SSL证书：" class="headerlink" title="一、为什么要部署SSL证书："></a><strong>一、为什么要部署SSL证书：</strong></h2><blockquote><p>目前互联网采取的是全网强制SSL，尤其是微信开发、APP开发、谷歌等都是强制的，为确保数据安全性，把http请求改成HTTPS（URL<br>https://而不是http://）请求确保客户端与站点传输数据的加密作用，所有操作系统都可以部署。</p></blockquote><h2 id="二、SSL证书是什么？"><a href="#二、SSL证书是什么？" class="headerlink" title="二、SSL证书是什么？"></a><strong>二、SSL证书是什么？</strong></h2><blockquote><p>SSL(Secure socket<br>layer)对用户和服务器进行认证，对传输数据进行加密的和隐藏的全球化标准的的安全协议，保证在互联网交易中，双方传递信息的安全性。</p></blockquote><p>作为文件形式存在的证书一般有这几种格式：</p><h2 id="1-带有私钥的证书"><a href="#1-带有私钥的证书" class="headerlink" title="　　**1.**带有私钥的证书"></a>　　**1.**带有私钥的证书</h2><p>　　由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作为证书文件后缀名。</p><h2 id="2-二进制编码的证书"><a href="#2-二进制编码的证书" class="headerlink" title="　　**2.**二进制编码的证书"></a>　　**2.**二进制编码的证书</h2><p>　　证书中没有私钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。</p><h2 id="3-Base64编码的证书"><a href="#3-Base64编码的证书" class="headerlink" title="　　3.Base64编码的证书"></a>　　<strong>3.Base64</strong>编码的证书</h2><p>证书中没有私钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。</p><p><strong>由定义可以看出，只有pfx**</strong>格式的数字证书是包含有私钥的，cer**<strong>格式的数字证书里面只有公钥没有私钥。</strong></p><p>　　在pfx证书的导入过程中有一项是“标志此密钥是可导出的。这将您在稍候备份或传输密钥”。一般是不选中的，如果选中，别人就有机会备份你的密钥了。如果是不选中，其实密钥也导入了，只是不能再次被导出。这就保证了密钥的安全。</p><p>　　如果导入过程中没有选中这一项，做证书备份时“导出私钥”这一项是灰色的，不能选。只能导出cer格式的公钥。如果导入时选中该项，则在导出时“导出私钥”这一项就是可选的。</p><p>　　如果要导出私钥（pfx),是需要输入密码的，这个密码就是对私钥再次加密，这样就保证了私钥的安全，别人即使拿到了你的证书备份（pfx),不知道加密私钥的密码，也是无法导入证书的。相反，如果只是导入导出cer格式的证书，是不会提示你输入密码的。因为公钥一般来说是对外公开的，不用加密</p><h2 id="三-配置"><a href="#三-配置" class="headerlink" title="三. 配置"></a>三. 配置</h2><ol><li><p>将.pfx文件放到项目的resources目录下</p></li><li><p>在properties或yml中如下配置</p></li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https加密端口号 8002</span></span><br><span class="line"><span class="string">server.port=8002</span></span><br><span class="line"><span class="comment">#SSL证书路径 一定要加上classpath: 3824167.jks</span></span><br><span class="line"><span class="string">server.ssl.key-store=classpath:yunservice.ltd.pfx</span></span><br><span class="line"><span class="comment">#SSL证书密码6cj3QrTo</span></span><br><span class="line"><span class="string">server.ssl.key-store-password=7K8UBVe5</span></span><br><span class="line"><span class="comment">#证书类型</span></span><br><span class="line"><span class="string">server.ssl.key-store-type=PKCS12</span></span><br><span class="line"><span class="comment">#证书别名</span></span><br><span class="line"><span class="string">server.ssl.key-alias=alias</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在项目中添加如下配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TomcatServletWebServerFactory <span class="title">tomcatServletWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                SecurityConstraint constraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(<span class="string">&quot;CONFIDENTIAL&quot;</span>);</span><br><span class="line">                SecurityCollection collection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="keyword">return</span> factory;        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connector <span class="title">createTomcatConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connector connector = <span class="keyword">new</span> Connector(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        connector.setPort(<span class="number">8001</span>);</span><br><span class="line">        connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="number">8002</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先配置一个TomcatServletWebServerFactory,然后添加一个Tomcat中的Connector（监听80端口），并将请求转发到8080上去.</p><p>配置完成后，在浏览器中输入:”<a href="http://localhost:8001/hello&quot;%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0https://localhost:8002/hello%E4%B8%8A%E3%80%82">http://localhost:8001/hello&quot;，就会自动重定向到https://localhost:8002/hello上。</a></p><p>或者直接输入<a href="https://localhost:8002/hello%E4%B9%9F%E6%98%AF%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84">https://localhost:8002/hello也是能访问的</a></p><h1 id="问题-post请求重定向后变成了GET请求"><a href="#问题-post请求重定向后变成了GET请求" class="headerlink" title="问题: post请求重定向后变成了GET请求"></a>问题: post请求重定向后变成了GET请求</h1><p>配置之后，确实生效。http get 请求 都能被重定向到https get 上，但是 http post 请求 死活不行，后台老是报requestMethod GET not supported，我访问的是post 方法呀，怎么就变成了get,百思不得其解，后来看到一篇博客讲到nginx做转发的时候也有这种问题，看了一下他的解决方法。</p><blockquote><p>server {<br>listen 80;<br>server_name *.snsprj.cn;<br>return 307 <a href="https://$host$request_uri/">https://</a>request_uri;<br>}</p></blockquote><p>我首先注意到了307 状态码，于是我想看一下我用tomcat 配置的它默认返回的状态码是多少<br><img src="https://img-blog.csdn.net/20180427214308461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyNDI2NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从上图中可以看出状态码是302，由于本人知识面比较窄，并不知道302，307的代表含义，于是就去查询相关资料，摘自wikipedia</p><blockquote><p>302 Found<br>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。[20]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p></blockquote><p>看到这里就明白了为什么http post 请求重定向时会被变成http get 请求。</p><blockquote><p>307 Temporary Redirect<br>在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>由于我使用的是tomcat 进行重定向的，从上文中也可以看出tomcat 默认进行的是302重定向，不符合我们的需求，那又什么办法可以解决呢？办法就是不用tomcat提供的配置，那就是我们自己后台程序处理，毕竟用人家的受限制，自己搞，想怎么弄就怎么弄。自己做的话很明显需要一个过滤器，在请求到达sevlet 之前进行处理，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns=&quot;/*&quot;,filterName=&quot;HttpsFilter&quot;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  过滤器，将http 请求转发到https请求上来</span></span><br><span class="line"><span class="comment"> *  重定向类型：307</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> FrankYuan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(HttpsFilter.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTPS =<span class="string">&quot;https&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTPS_PORT = <span class="number">8443</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;------------destroy HttpsFilter --------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">         URL newUrl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(request.getScheme().equals(HTTPS)) &#123;</span><br><span class="line">             chain.doFilter(request, response);</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             HttpServletRequest httpRequest = (HttpServletRequest)request;</span><br><span class="line">             HttpServletResponse httpResponse = (HttpServletResponse)response;</span><br><span class="line">             String queryString = httpRequest.getQueryString()==<span class="keyword">null</span> ? <span class="string">&quot;&quot;</span>:<span class="string">&quot;?&quot;</span>+httpRequest.getQueryString();</span><br><span class="line">             httpResponse.setStatus(<span class="number">307</span>);</span><br><span class="line">             String requestUrl = httpRequest.getRequestURL().toString();</span><br><span class="line">             URL reqUrl = <span class="keyword">new</span> URL(requestUrl+queryString);</span><br><span class="line">             logger.info(<span class="string">&quot;【original request-】 &quot;</span>+reqUrl.toString());</span><br><span class="line">             newUrl = <span class="keyword">new</span> URL(HTTPS,reqUrl.getHost(),HTTPS_PORT,reqUrl.getFile());</span><br><span class="line">             <span class="comment">//进行重定向</span></span><br><span class="line">             logger.info(<span class="string">&quot;【new request-】 &quot;</span>+newUrl.toString());</span><br><span class="line">             httpResponse.setHeader(<span class="string">&quot;Location&quot;</span>, newUrl.toString());</span><br><span class="line">             httpResponse.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>);</span><br><span class="line">             <span class="comment">//允许所有跨域请求</span></span><br><span class="line">             httpResponse.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);     </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;------------init HttpsFilter --------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:这里又个坑，就是重定向后需要也需要解决跨域问题，不然页面ajax请求 http 地址会出现跨域问题。</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpResponse.setStatus(<span class="number">307</span>);</span><br></pre></td></tr></table></figure><p>将响应码换成307</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot中配置SSL证书&quot;&gt;&lt;a href=&quot;#Springboot中配置SSL证书&quot; class=&quot;headerlink&quot; title=&quot;Springboot中配置SSL证书&quot;&gt;&lt;/a&gt;Springboot中配置SSL证书&lt;/h1&gt;&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="SSL" scheme="http://yoursite.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot配置Cors解决跨域请求问题</title>
    <link href="http://yoursite.com/2020/12/04/SpringBoot%E9%85%8D%E7%BD%AECors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/12/04/SpringBoot%E9%85%8D%E7%BD%AECors%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2021-01-14T12:07:50.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot配置Cors解决跨域请求问题"><a href="#SpringBoot配置Cors解决跨域请求问题" class="headerlink" title="SpringBoot配置Cors解决跨域请求问题"></a><a href="https://www.cnblogs.com/yuansc/p/9076604.html">SpringBoot配置Cors解决跨域请求问题</a></h1><h2 id="一、同源策略简介"><a href="#一、同源策略简介" class="headerlink" title="一、同源策略简介"></a>一、同源策略简介</h2><p><strong>同源策略</strong>[same origin policy]是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。 同源策略是浏览器安全的基石。</p><h3 id="什么是源"><a href="#什么是源" class="headerlink" title="什么是源"></a>什么是源</h3><p><strong>源</strong>[origin]就是协议、域名和端口号。例如：<a href="http://www.baidu.com/">http://www.baidu.com:80</a> 这个URL。</p><h3 id="什么是同源"><a href="#什么是同源" class="headerlink" title="什么是同源"></a>什么是同源</h3><p>若地址里面的协议、域名和端口号均相同则属于同源。</p><h3 id="是否是同源的判断"><a href="#是否是同源的判断" class="headerlink" title="是否是同源的判断"></a>是否是同源的判断</h3><p>例如判断下面的<code>URL</code>是否与 <a href="http://www.a.com/test/index.html">http://www.a.com/test/index.html</a> 同源</p><ul><li><a href="http://www.a.com/dir/page.html">http://www.a.com/dir/page.html</a> 同源</li><li><a href="http://www.child.a.com/test/index.html">http://www.child.a.com/test/index.html</a> 不同源，域名不相同</li><li><a href="https://www.a.com/test/index.html">https://www.a.com/test/index.html</a> 不同源，协议不相同</li><li><a href="http://www.a.com:8080/test/index.html">http://www.a.com:8080/test/index.html</a> 不同源，端口号不相同</li></ul><h3 id="哪些操作不受同源策略限制"><a href="#哪些操作不受同源策略限制" class="headerlink" title="哪些操作不受同源策略限制"></a>哪些操作不受同源策略限制</h3><ol><li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的；</li><li>跨域资源的引入是可以的。但是<code>JS</code>不能读写加载的内容。如嵌入到页面中的<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>，<code>&lt;img&gt;</code>，<code>&lt;link&gt;</code>，<code>&lt;iframe&gt;</code>等。</li></ol><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>受前面所讲的浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象就需要跨域。 在同源策略的限制下，<em>非同源</em>的网站之间不能发送 <code>AJAX</code> 请求。</p><h3 id="如何跨域"><a href="#如何跨域" class="headerlink" title="如何跨域"></a>如何跨域</h3><ul><li><p>降域</p><p>可以通过设置 <code>document.damain=&#39;a.com&#39;</code>，浏览器就会认为它们都是同一个源。想要实现以上任意两个页面之间的通信，两个页面必须都设置<code>documen.damain=&#39;a.com&#39;</code>。</p></li><li><p><code>JSONP</code>跨域</p></li><li><p><code>CORS</code> 跨域</p></li></ul><h2 id="二、CORS-简介"><a href="#二、CORS-简介" class="headerlink" title="二、CORS 简介"></a>二、CORS 简介</h2><p>为了解决浏览器同源问题，<code>W3C</code> 提出了跨源资源共享，即 <code>CORS</code>(<a href="https://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a>)。</p><p><code>CORS</code> 做到了如下两点：</p><ul><li>不破坏即有规则</li><li>服务器实现了 <code>CORS</code> 接口，就可以跨源通信</li></ul><p>基于这两点，<code>CORS</code> 将请求分为两类：简单请求和非简单请求。</p><h4 id="1、简单请求"><a href="#1、简单请求" class="headerlink" title="1、简单请求"></a>1、简单请求</h4><p>在<code>CORS</code>出现前，发送<code>HTTP</code>请求时在头信息中不能包含任何自定义字段，且 <code>HTTP</code> 头信息不超过以下几个字段：</p><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Last-Event-ID</code></li><li><code>Content-Type</code> 只限于 [<code>application/x-www-form-urlencoded</code> 、<code>multipart/form-data</code>、<code>text/plain</code> ] 类型</li></ul><p>一个简单的请求例子：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">GET /test HTTP/1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch, br</span><br><span class="line">Origin: http://www.examples.com</span><br><span class="line">Host: www.examples.com</span><br></pre></td></tr></table></figure><p>对于简单请求，<code>CORS</code>的策略是请求时在请求头中增加一个<code>Origin</code>字段，服务器收到请求后，根据该字段判断是否允许该请求访问。</p><ol><li>如果允许，则在 HTTP 头信息中添加 <code>Access-Control-Allow-Origin</code> 字段，并返回正确的结果 ；</li><li>如果不 允许，则不在 HTTP 头信息中添加 <code>Access-Control-Allow-Origin</code> 字段 。</li></ol><p>除了上面提到的 <code>Access-Control-Allow-Origin</code> ，还有几个字段用于描述 <code>CORS</code> 返回结果 ：</p><ol><li><code>Access-Control-Allow-Credentials</code>： 可选，用户是否可以发送、处理 <code>cookie</code>；</li><li><code>Access-Control-Expose-Headers</code>：可选，可以让用户拿到的字段。有几个字段无论设置与否都可以拿到的，包括：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code> 。</li></ol><h4 id="2、非简单请求"><a href="#2、非简单请求" class="headerlink" title="2、非简单请求"></a>2、非简单请求</h4><p>对于非简单请求的跨源请求，<strong>浏览器会在真实请求发出前</strong>，增加一次<code>OPTION</code>请求，称为预检请求(<code>preflight request</code>)。预检请求将真实请求的信息，包括请求方法、自定义头字段、源信息添加到 HTTP 头信息字段中，询问服务器是否允许这样的操作。</p><p>例如一个<code>DELETE</code>请求：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">OPTIONS /test HTTP/1.1</span><br><span class="line">Origin: http://www.examples.com</span><br><span class="line">Access-Control-Request-Method: DELETE</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: www.examples.com</span><br></pre></td></tr></table></figure><p>与 <code>CORS</code> 相关的字段有：</p><ol><li>请求使用的 <code>HTTP</code> 方法 <code>Access-Control-Request-Method</code> ；</li><li>请求中包含的自定义头字段 <code>Access-Control-Request-Headers</code> 。</li></ol><p>服务器收到请求时，需要分别对 <code>Origin</code>、<code>Access-Control-Request-Method</code>、<code>Access-Control-Request-Headers</code> 进行验证，验证通过后，会在返回 <code>HTTP</code>头信息中添加 ：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.examples.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT, DELETE</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure><p>他们的含义分别是：</p><ol><li>Access-Control-Allow-Methods: 真实请求允许的方法</li><li>Access-Control-Allow-Headers: 服务器允许使用的字段</li><li>Access-Control-Allow-Credentials: 是否允许用户发送、处理 cookie</li><li>Access-Control-Max-Age: 预检请求的有效期，单位为秒。有效期内，不会重复发送预检请求</li></ol><p>当预检请求通过后，浏览器会发送真实请求到服务器。这就实现了跨源请求。</p><h2 id="三、Spring-Boot-配置-CORS"><a href="#三、Spring-Boot-配置-CORS" class="headerlink" title="三、Spring Boot 配置 CORS"></a>三、Spring Boot 配置 CORS</h2><h3 id="1、使用-CrossOrigin-注解实现"><a href="#1、使用-CrossOrigin-注解实现" class="headerlink" title="1、使用@CrossOrigin 注解实现"></a>1、使用<code>@CrossOrigin</code> 注解实现</h3><p><code>#</code>如果想要对某一接口配置 <code>CORS</code>，可以在方法上添加 <code>@CrossOrigin</code> 注解 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://localhost:9000&quot;, &quot;null&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">greetings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;project\&quot;:\&quot;just a test\&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#</code>如果想对一系列接口添加 CORS 配置，可以在类上添加注解，对该类声明所有接口都有效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &#123;&quot;http://localhost:9000&quot;, &quot;null&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootCorsTestApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#</code>如果想添加全局配置，则需要添加一个配置类 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，还可以通过添加 Filter 的方式，配置 CORS 规则，并手动指定对哪些接口有效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    config.setAllowCredentials(<span class="keyword">true</span>);    config.addAllowedOrigin(<span class="string">&quot;http://localhost:9000&quot;</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config); <span class="comment">// CORS 配置对所有接口都有效</span></span><br><span class="line">    FilterRegistrationBean bean = newFilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">    bean.setOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、原理剖析"><a href="#2、原理剖析" class="headerlink" title="2、原理剖析"></a>2、原理剖析</h3><p>无论是通过哪种方式配置 <code>CORS</code>，其实都是在构造 <code>CorsConfiguration</code>。 一个 <code>CORS</code> 配置用一个 <code>CorsConfiguration</code>类来表示，它的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; allowedOrigins;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; allowedMethods;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; allowedHeaders;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; exposedHeaders;</span><br><span class="line">    <span class="keyword">private</span> Boolean allowCredentials;</span><br><span class="line">    <span class="keyword">private</span> Long maxAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spring</code> 中对 <code>CORS</code> 规则的校验，都是通过委托给 <code>DefaultCorsProcessor</code>实现的。</p><p><code>DefaultCorsProcessor</code> 处理过程如下：</p><ol><li>判断依据是 <code>Header</code>中是否包含 <code>Origin</code>。如果包含则说明为 <code>CORS</code>请求，转到 2；否则，说明不是 <code>CORS</code> 请求，不作任何处理。</li><li>判断 <code>response</code> 的 <code>Header</code> 是否已经包含 <code>Access-Control-Allow-Origin</code>，如果包含，证明已经被处理过了, 转到 3，否则不再处理。</li><li>判断是否同源，如果是则转交给负责该请求的类处理</li><li>是否配置了 <code>CORS</code> 规则，如果没有配置，且是预检请求，则拒绝该请求，如果没有配置，且不是预检请求，则交给负责该请求的类处理。如果配置了，则对该请求进行校验。</li></ol><p>校验就是根据 <code>CorsConfiguration</code> 这个类的配置进行判断：</p><ol><li>判断 <code>origin</code> 是否合法</li><li>判断 <code>method</code> 是否合法</li><li>判断 <code>header</code>是否合法</li><li>如果全部合法，则在 <code>response header</code>中添加响应的字段，并交给负责该请求的类处理，如果不合法，则拒绝该请求。</li></ol>]]></content>
    
    <summary type="html">
    
      SpringBoot配置Cors解决跨域请求问题
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>为什么阿里规定需要在事务注解Transactional中指定rollbackFor？</title>
    <link href="http://yoursite.com/2020/12/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E8%A7%84%E5%AE%9A%E9%9C%80%E8%A6%81%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3@Transactional%E4%B8%AD%E6%8C%87%E5%AE%9ArollbackFor%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/12/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E8%A7%84%E5%AE%9A%E9%9C%80%E8%A6%81%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3@Transactional%E4%B8%AD%E6%8C%87%E5%AE%9ArollbackFor%EF%BC%9F/</id>
    <published>2020-12-04T12:54:00.000Z</published>
    <updated>2020-12-04T12:56:43.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？"><a href="#为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？" class="headerlink" title="为什么阿里规定需要在事务注解@Transactional中指定rollbackFor？"></a>为什么阿里规定需要在事务注解@Transactional中指定rollbackFor？</h1><blockquote><p>阿里巴巴Java规范：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。</p></blockquote><h2 id="异常的分类-exception-1-png"><a href="#异常的分类-exception-1-png" class="headerlink" title="异常的分类   exception-1.png"></a>异常的分类  <img src="https://upload-images.jianshu.io/upload_images/12553249-eb4b881c2f4661f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944/format/webp" alt="img"> exception-1.png</h2><p><img src="https://upload-images.jianshu.io/upload_images/12553249-fba65fc05c777ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1182/format/webp" alt="img"></p><p>Exception.png</p><p>Throwable:有两个重要的子类：Exception（异常）和Error（错误），二者都是Java异常处理的重要子类，各自都包含大量子类。</p><p>Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM   （Java虚拟机）出现的问题。例如。Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需要的内存资源时，将出现  OutOfMemoryError  。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>Exception（异常）：是程序本身可以处理的异常。他又分为运行时异常RuntimeException和非运行时异常。</p><h2 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h2><p>error表示恢复不是不可能但很困难的情况下的一种严重问题。   比如说内存溢出。不可能指望程序能处理这样的情况。exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p><h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><p>常见的运行时异常：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ArithmeticException——由于除数为<span class="number">0</span>引起的异常；</span><br><span class="line"></span><br><span class="line">ArrayStoreException——由于数组存储空间不够引起的异常；</span><br><span class="line"></span><br><span class="line">ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常；</span><br><span class="line"></span><br><span class="line">IllegalMonitorStateException——监控器状态出错引起的异常；</span><br><span class="line"></span><br><span class="line">NegativeArraySizeException—一数组长度是负数，则产生异常；</span><br><span class="line"></span><br><span class="line">NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常； OutofMemoryException——用<span class="keyword">new</span>语句创建对象时，如系统无法为其分配内存空 间则产生异常；</span><br><span class="line"></span><br><span class="line">SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常；</span><br><span class="line"></span><br><span class="line">IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常；</span><br><span class="line"></span><br><span class="line">IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常；</span><br><span class="line"></span><br><span class="line">ClassNotFoundException——未找到指定名字的类或接口引起异常；</span><br><span class="line"></span><br><span class="line">CloneNotSupportedException——一程序中的一个对象引用<span class="keyword">Object</span>类的<span class="keyword">clone</span>方法，但 此对象并没有连接Cloneable接口，从而引起异常；</span><br><span class="line"></span><br><span class="line">InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述；</span><br><span class="line"></span><br><span class="line">NoSuchMethodException一所调用的方法未找到，引起异常；</span><br><span class="line"></span><br><span class="line">Illega1AccessExcePtion—一试图访问一个非<span class="keyword">public</span>方法；</span><br><span class="line"></span><br><span class="line">StringIndexOutOfBoundsException——访问字符串序号越界，引起异常；</span><br><span class="line"></span><br><span class="line">ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常；</span><br><span class="line"></span><br><span class="line">NumberFormatException——字符的UTF代码数据格式有错引起异常；</span><br><span class="line"></span><br><span class="line">IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常；</span><br><span class="line"></span><br><span class="line">FileNotFoundException——未找到指定文件引起异常；</span><br><span class="line"></span><br><span class="line">EOFException——未完成输入操作即遇文件结束引起异常。</span><br></pre></td></tr></table></figure><h2 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h2><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不要自定义检查异常。</p><h2 id="可查异常和不可查异常"><a href="#可查异常和不可查异常" class="headerlink" title="可查异常和不可查异常"></a>可查异常和不可查异常</h2><blockquote><p>可查的异常（checked exceptions）:Exception下除了RuntimeException外的异常<br> 不可查的异常（unchecked exceptions）:RuntimeException及其子类和错误（Error）</p></blockquote><p>如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。  如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。</p><p>队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。</p><p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。</p><p>对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p><h2 id="Transactional-的写法"><a href="#Transactional-的写法" class="headerlink" title="@Transactional 的写法"></a>@Transactional 的写法</h2><p><strong><code>@Transactional</code>如果只这样写,Spring框架的事务基础架构代码将默认地 只 在抛出运行时和unchecked exceptions时才标识事务回滚。也就是说，当抛出个RuntimeException 或其子类例的实例时。（Errors 也一样 - 默认地 - 标识事务回滚。）从事务方法中抛出的Checked exceptions将 不 被标识进行事务回滚。</strong></p><ul><li>让checked例外也回滚<br> <code>@Transactional(rollbackFor=Exception.class)</code></li><li>让unchecked例外不回滚<br> <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li>不需要事务管理的(只查询的)方法<br> <code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li></ul><blockquote><p>如果异常被try｛｝catch｛｝了，事务就不回滚了，如果想让事务回滚必须再往外抛try｛｝catch｛throw Exception｝。</p></blockquote><h1 id="关于使用注解-Transactional，手动抛出异常不回滚现象总结："><a href="#关于使用注解-Transactional，手动抛出异常不回滚现象总结：" class="headerlink" title="关于使用注解@Transactional，手动抛出异常不回滚现象总结："></a>关于使用注解@Transactional，手动抛出异常不回滚现象总结：</h1><p>我用的是自定义异常直接继承Exception异常，在实际操作中，出现异常后没有回滚，还是把数据写入数据库了。</p><p>查了一下资料，只有runtimeexception并且没有被try catch处理的异常才会回滚。另外Transactional可以指定回滚异常，然后我用@Transactional(rollbackFor=Exception.class)就好使了。</p><p>总结@Transactional(rollbackFor=Exception.class)如果有异常，并且这个异常没有被try catch 就会回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？&quot;&gt;&lt;a href=&quot;#为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？&quot; class=&quot;headerlink&quot; title=&quot;为什么阿里规
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="Transactional" scheme="http://yoursite.com/tags/Transactional/"/>
    
      <category term="事务回滚" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之定时任务详解</title>
    <link href="http://yoursite.com/2020/12/04/SpringBoot%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/12/04/SpringBoot%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-12-04T12:53:00.000Z</published>
    <updated>2020-12-04T12:53:21.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot之定时任务详解"><a href="#SpringBoot之定时任务详解" class="headerlink" title="SpringBoot之定时任务详解"></a>SpringBoot之定时任务详解</h1><p><strong>阅读目录：</strong></p><ul><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label0">序言</a></li><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label1">一、静态：基于注解</a></li><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label2">二、动态：基于接口</a></li><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label3">三、多线程定时任务</a></li></ul><p><strong>阅读正文：</strong></p><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>使用SpringBoot创建定时任务非常简单，目前主要有以下三种创建方式：</p><ul><li>一、基于注解(@Scheduled)</li><li>二、基于接口（SchedulingConfigurer） 前者相信大家都很熟悉，但是实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。</li><li>三、基于注解设定多线程定时任务</li></ul><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="一、静态：基于注解"><a href="#一、静态：基于注解" class="headerlink" title="一、静态：基于注解"></a>一、静态：基于注解</h2><p>基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。</p><h4 id="1、创建定时器"><a href="#1、创建定时器" class="headerlink" title="1、创建定时器"></a>1、创建定时器</h4><p>使用SpringBoot基于注解来创建定时任务非常简单，只需几行代码便可完成。 代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration      &#x2F;&#x2F;1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   &#x2F;&#x2F; 2.开启定时任务</span><br><span class="line">public class SaticScheduleTask &#123;</span><br><span class="line">    &#x2F;&#x2F;3.添加定时任务</span><br><span class="line">    @Scheduled(cron &#x3D; &quot;0&#x2F;5 * * * * ?&quot;)</span><br><span class="line">    &#x2F;&#x2F;或直接指定时间间隔，例如：5秒</span><br><span class="line">    &#x2F;&#x2F;@Scheduled(fixedRate&#x3D;5000)</span><br><span class="line">    private void configureTasks() &#123;</span><br><span class="line">        System.err.println(&quot;执行静态定时任务时间: &quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="Cron表达式参数分别表示："><a href="#Cron表达式参数分别表示：" class="headerlink" title="Cron表达式参数分别表示："></a>Cron表达式参数分别表示：</h4><ul><li>秒（0~59） 例如0/5表示每5秒</li><li>分（0~59）</li><li>时（0~23）</li><li>日（0~31）的某天，需计算</li><li>月（0~11）</li><li>周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT）</li></ul><p>@Scheduled：除了支持灵活的参数表达式cron之外，还支持简单的延时操作，例如 fixedDelay ，fixedRate 填写相应的毫秒数即可。</p><ol><li>首先使用 @Scheduled 注解开启一个定时任务。</li><li>fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。</li><li>fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。</li><li>initialDelay 表示首次任务启动的延迟时间。</li><li>所有时间的单位都是毫秒。</li></ol><p>上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下：</p><blockquote><p>[秒] [分] [小时] [日] [月] [周] [年]</p></blockquote><p>具体取值如下：</p><table><thead><tr><th align="left">序号</th><th align="left">说明</th><th align="left">是否必填</th><th align="left">允许填写的值</th><th align="left">允许的通配符</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">秒</td><td align="left">是</td><td align="left">0-59</td><td align="left">- * /</td></tr><tr><td align="left">2</td><td align="left">分</td><td align="left">是</td><td align="left">0-59</td><td align="left">- * /</td></tr><tr><td align="left">3</td><td align="left">时</td><td align="left">是</td><td align="left">0-23</td><td align="left">- * /</td></tr><tr><td align="left">4</td><td align="left">日</td><td align="left">是</td><td align="left">1-31</td><td align="left">- * ? / L W</td></tr><tr><td align="left">5</td><td align="left">月</td><td align="left">是</td><td align="left">1-12 or JAN-DEC</td><td align="left">- * /</td></tr><tr><td align="left">6</td><td align="left">周</td><td align="left">是</td><td align="left">1-7 or SUN-SAT</td><td align="left">- * ? / L #</td></tr><tr><td align="left">7</td><td align="left">年</td><td align="left">否</td><td align="left">1970-2099</td><td align="left">- * /</td></tr></tbody></table><p><strong>这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></strong></p><p><strong>通配符含义：</strong></p><ul><li><code>?</code> 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></li><li><code>*</code> 表示所有值，例如:在秒的字段上设置 <code>*</code>,表示每一秒都会触发</li><li><code>,</code> 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li><li><code>-</code> 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发</li><li><code>/</code> 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)</li><li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了)</li><li>周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同</li><li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五”</li><li><code>W</code> 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)</li><li><code>L</code> 和 <code>W</code> 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )</li></ul><p>例如，在 @Scheduled 注解中来一个简单的 cron 表达式，每隔5秒触发一次，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、启动测试"><a href="#2、启动测试" class="headerlink" title="2、启动测试"></a>2、启动测试</h4><p>启动应用，可以看到控制台打印出如下信息：</p><p><img src="https://img-blog.csdnimg.cn/20181220161509852.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>显然，使用@Scheduled 注解很方便，但缺点是当我们调整了执行周期的时候，需要重启应用才能生效，这多少有些不方便。为了达到实时生效的效果，可以使用接口来完成定时任务。</p><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="二、动态：基于接口"><a href="#二、动态：基于接口" class="headerlink" title="二、动态：基于接口"></a>二、动态：基于接口</h2><p>基于接口（SchedulingConfigurer）</p><h4 id="1、导入依赖包："><a href="#1、导入依赖包：" class="headerlink" title="1、导入依赖包："></a>1、导入依赖包：</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!--添加Web依赖 --&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!--添加MySql依赖 --&gt;</span><br><span class="line">         &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!--添加Mybatis依赖 配置mybatis的一些初始化的东西--&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!-- 添加mybatis依赖 --&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="2、添加数据库记录："><a href="#2、添加数据库记录：" class="headerlink" title="2、添加数据库记录："></a>2、添加数据库记录：</h4><p>开启本地数据库mysql，随便打开查询窗口，然后执行脚本内容，如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS &#96;socks&#96;;</span><br><span class="line">CREATE DATABASE &#96;socks&#96;;</span><br><span class="line">USE &#96;SOCKS&#96;;</span><br><span class="line">DROP TABLE IF EXISTS &#96;cron&#96;;</span><br><span class="line">CREATE TABLE &#96;cron&#96;  (</span><br><span class="line">  &#96;cron_id&#96; varchar(30) NOT NULL PRIMARY KEY,</span><br><span class="line">  &#96;cron&#96; varchar(30) NOT NULL  </span><br><span class="line">);</span><br><span class="line">INSERT INTO &#96;cron&#96; VALUES (&#39;1&#39;, &#39;0&#x2F;5 * * * * ?&#39;);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://img-blog.csdnimg.cn/20181220161546371.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>然后在项目中的application.yml 添加数据源：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;socks</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br></pre></td></tr></table></figure><h4 id="3、创建定时器"><a href="#3、创建定时器" class="headerlink" title="3、创建定时器"></a>3、创建定时器</h4><p>数据库准备好数据之后，我们编写定时任务，注意这里添加的是TriggerTask，目的是循环读取我们在数据库设置好的执行周期，以及执行相关定时任务的内容。<br>具体代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration      &#x2F;&#x2F;1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   &#x2F;&#x2F; 2.开启定时任务</span><br><span class="line">public class DynamicScheduleTask implements SchedulingConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Mapper</span><br><span class="line">    public interface CronMapper &#123;</span><br><span class="line">        @Select(&quot;select cron from cron limit 1&quot;)</span><br><span class="line">        public String getCron();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired      &#x2F;&#x2F;注入mapper</span><br><span class="line">    @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">    CronMapper cronMapper;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 执行定时任务.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                &#x2F;&#x2F;1.添加任务内容(Runnable)</span><br><span class="line">                () -&gt; System.out.println(&quot;执行动态定时任务: &quot; + LocalDateTime.now().toLocalTime()),</span><br><span class="line">                &#x2F;&#x2F;2.设置执行周期(Trigger)</span><br><span class="line">                triggerContext -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F;2.1 从数据库获取执行周期</span><br><span class="line">                    String cron &#x3D; cronMapper.getCron();</span><br><span class="line">                    &#x2F;&#x2F;2.2 合法性校验.</span><br><span class="line">                    if (StringUtils.isEmpty(cron)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Omitted Code ..</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;2.3 返回执行周期(Date)</span><br><span class="line">                    return new CronTrigger(cron).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="4、启动测试"><a href="#4、启动测试" class="headerlink" title="4、启动测试"></a>4、启动测试</h4><p>启动应用后，查看控制台，打印时间是我们预期的每10秒一次：<br><img src="https://img-blog.csdnimg.cn/20181220161739406.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>然后打开Navicat ，将执行周期修改为每6秒执行一次，如图：<br><img src="https://img-blog.csdnimg.cn/20181220161905131.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>查看控制台，发现执行周期已经改变，并且不需要我们重启应用，十分方便。如图：<br><img src="https://img-blog.csdnimg.cn/20181220161911141.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>注意： 如果在数据库修改时格式出现错误，则定时任务会停止，即使重新修改正确；此时只能重新启动项目才能恢复。</p><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="三、多线程定时任务"><a href="#三、多线程定时任务" class="headerlink" title="三、多线程定时任务"></a>三、多线程定时任务</h2><p>基于注解设定多线程定时任务</p><h4 id="1、创建多线程定时任务"><a href="#1、创建多线程定时任务" class="headerlink" title="1、创建多线程定时任务"></a>1、创建多线程定时任务</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@Component注解用于对那些比较中立的类进行注释；</span><br><span class="line">&#x2F;&#x2F;相对与在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释</span><br><span class="line">@Component</span><br><span class="line">@EnableScheduling   &#x2F;&#x2F; 1.开启定时任务</span><br><span class="line">@EnableAsync        &#x2F;&#x2F; 2.开启多线程</span><br><span class="line">public class MultithreadScheduleTask &#123;</span><br><span class="line"></span><br><span class="line">        @Async</span><br><span class="line">        @Scheduled(fixedDelay &#x3D; 1000)  &#x2F;&#x2F;间隔1秒</span><br><span class="line">        public void first() throws InterruptedException &#123;</span><br><span class="line">            System.out.println(&quot;第一个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">            System.out.println();</span><br><span class="line">            Thread.sleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Async</span><br><span class="line">        @Scheduled(fixedDelay &#x3D; 2000)</span><br><span class="line">        public void second() &#123;</span><br><span class="line">            System.out.println(&quot;第二个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>注：</strong> 这里的<a href="https://www.cnblogs.com/mmzs/p/11557583.html">@Async</a>注解很关键</p><h4 id="2、启动测试-1"><a href="#2、启动测试-1" class="headerlink" title="2、启动测试"></a>2、启动测试</h4><p>启动应用后，查看控制台：<br><img src="https://img-blog.csdnimg.cn/20181220165535820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vYml1c1N0cmlw,size_16,color_FFFFFF,t_70&ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>从控制台可以看出，第一个定时任务和第二个定时任务互不影响；</p><p>并且，由于开启了多线程，第一个任务的执行时间也不受其本身执行时间的限制，所以需要注意可能会出现重复操作导致数据异常。</p><p>代码地址：<a href="https://github.com/mmzsblog/springboot-schedule">https://github.com/mmzsblog/springboot-schedule</a></p>]]></content>
    
    <summary type="html">
    
      SpringBoot之定时任务详解
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目启动时如何执行特定方法</title>
    <link href="http://yoursite.com/2020/12/04/Spring%20Boot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/12/04/Spring%20Boot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-04T12:52:00.000Z</published>
    <updated>2020-12-04T12:52:30.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot：项目启动时如何执行特定方法"><a href="#Spring-Boot：项目启动时如何执行特定方法" class="headerlink" title="Spring Boot：项目启动时如何执行特定方法"></a>Spring Boot：项目启动时如何执行特定方法</h1><h2 id="1-PostConstruct"><a href="#1-PostConstruct" class="headerlink" title="1. @PostConstruct"></a>1. @PostConstruct</h2><p>应该也是最简单的方式</p><p>直接在方式上面注入，但是会影响服务提供，比如这个方法要执行五分钟 这五分钟之内是无法提供服务的，这个方法是在服务初始化后之前运行， 所以 此方法运行不结束，服务就无法初始化， 在这过程路也无法提供服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">pingStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; ping start:&quot;</span>);</span><br><span class="line">    getPingip();</span><br><span class="line">    System.out.println(<span class="string">&quot; ping end: &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用ApplicationListener"><a href="#2-使用ApplicationListener" class="headerlink" title="2. 使用ApplicationListener"></a>2. 使用ApplicationListener</h2><p>是通过监听接口方式启动，服务已经初始化过，不影响 服务启动，并且启动之后可以正常提供服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationStartQuartzJobListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzManager quartzManager;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始启动quartz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            quartzManager.start();</span><br><span class="line">            System.out.println(<span class="string">&quot;任务已经启动...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-CommandLineRunner"><a href="#3-CommandLineRunner" class="headerlink" title="3. CommandLineRunner"></a>3. CommandLineRunner</h2><p>也是监听接口方式，启动服务，执行方式时仍然提供服务，服务初始化之后，执行方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartPingService</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Ping ping;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        ping.pingStart();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-指定启动方法执行的顺序"><a href="#4-指定启动方法执行的顺序" class="headerlink" title="4. 指定启动方法执行的顺序"></a>4. 指定启动方法执行的顺序</h2><p> 这两种方式的实现都很简单，直接实现了相应的接口就可以了。记得在类上加@Component注解。</p><p>如果想要指定启动方法执行的顺序，可以通过实现org.springframework.core.Ordered接口或者使用org.springframework.core.annotation.Order注解来实现。</p><p><strong>1.Ordered接口：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.boot.ApplicationArguments;</span><br><span class="line">import org.springframework.boot.ApplicationRunner;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner,Ordered&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder()&#123;</span><br><span class="line">        return 1;&#x2F;&#x2F;通过设置这里的数字来知道指定顺序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments var1) throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner1!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><p><strong>2.Order注解实现方式：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.boot.ApplicationArguments;</span><br><span class="line">import org.springframework.boot.ApplicationRunner;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Order(value &#x3D; 1)</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments var1) throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner1!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用例, 类, 写作, 顺序</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot：项目启动时如何执行特定方法&quot;&gt;&lt;a href=&quot;#Spring-Boot：项目启动时如何执行特定方法&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot：项目启动时如何执行特定方法&quot;&gt;&lt;/a&gt;Spring Boot
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
