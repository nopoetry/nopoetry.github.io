<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Li buyan Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-04T12:56:36.173Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Li buyan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Autowired的三种注入方式</title>
    <link href="http://yoursite.com/2020/12/04/@Autowired%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/12/04/@Autowired%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2020-12-04T12:56:36.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Autowired的三种注入方式"><a href="#Autowired的三种注入方式" class="headerlink" title="@Autowired的三种注入方式"></a>@Autowired的三种注入方式</h1><h2 id="Field-injection-is-not-recommended（不再推荐使用字段注入）"><a href="#Field-injection-is-not-recommended（不再推荐使用字段注入）" class="headerlink" title="Field injection is not recommended（不再推荐使用字段注入）"></a>Field injection is not recommended（不再推荐使用字段注入）</h2><h2 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h2><p>最近公司升级框架，由原来的<code>spring framerwork 3.0</code>升级到<code>5.0</code>，然后写代码的时候突然发现idea在属性注入的**@Autowired**注解上给出警告提示，就像下面这样的，也挺懵逼的，毕竟这么写也很多年了。</p><blockquote><p>Field injection is not recommended</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-5b102c68eb1becb08e60ba8866784aba_720w.png" alt="img"></p><p>查阅了相关文档了解了一下，原来这个提示是<code>spring framerwork 4.0</code>以后开始出现的，spring 4.0开始就不推荐使用属性注入，改为推荐构造器注入和setter注入。</p><p>下面将展示了spring框架可以使用的不同类型的依赖注入，以及每种依赖注入的适用情况。</p><h2 id="2-依赖注入的类型"><a href="#2-依赖注入的类型" class="headerlink" title="2. 依赖注入的类型"></a>2. 依赖注入的类型</h2><p>尽管针对<code>spring framerwork 5.1.3</code>的<a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html%23beans-factory-collaborators">文档</a>只定义了两种主要的依赖注入类型，但实际上有三种;</p><ul><li>基于构造函数的依赖注入</li><li>基于setter的依赖注入</li><li>基于字段的依赖注入</li></ul><p>其中<code>基于字段的依赖注入</code>被广泛使用，但是idea或者其他静态代码分析工具会给出提示信息，不推荐使用。</p><p>甚至可以在一些Spring官方指南中看到这种注入方法:</p><p><img src="https://pic1.zhimg.com/80/v2-04271e646164721421b85eedd07c1864_720w.jpg" alt="img"></p><h3 id="2-1-基于构造函数的依赖注入"><a href="#2-1-基于构造函数的依赖注入" class="headerlink" title="2.1 基于构造函数的依赖注入"></a>2.1 基于构造函数的依赖注入</h3><p>在基于构造函数的依赖注入中，类构造函数被标注为**@Autowired**，并包含了许多与要注入的对象相关的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorBasedInjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InjectedBean injectedBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructorBasedInjection</span><span class="params">(InjectedBean injectedBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.injectedBean = injectedBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在spring<a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.0.3.RELEASE/spring-framework-reference/core.html%23beans-constructor-injection">官方文档</a>中，**@Autowired**注解也是可以省去的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于构造函数注入的主要优点是可以将需要注入的字段声明为<strong>final</strong>， 使得它们会在类实例化期间被初始化，这对于所需的依赖项很方便。</p><h3 id="2-2-基于Setter的依赖注入"><a href="#2-2-基于Setter的依赖注入" class="headerlink" title="2.2 基于Setter的依赖注入"></a>2.2 基于Setter的依赖注入</h3><p>在基于setter的依赖注入中，setter方法被标注为**@Autowired**。一旦使用无参数构造函数或无参数静态工厂方法实例化Bean，为了注入Bean的依赖项，Spring容器将调用这些setter方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetterBasedInjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InjectedBean injectedBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInjectedBean</span><span class="params">(InjectedBean injectedBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.injectedBean = injectedBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和基于构造器的依赖注入一样，在<a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.0.3.RELEASE/spring-framework-reference/core.html%23beans-setter-injection">官方文档</a>中，基于Setter的依赖注入中的**@Autowired**也可以省去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-基于属性的依赖注入"><a href="#2-3-基于属性的依赖注入" class="headerlink" title="2.3 基于属性的依赖注入"></a>2.3 基于属性的依赖注入</h3><p>在基于属性的依赖注入中，字段/属性被标注为**@Autowired**。一旦类被实例化，Spring容器将设置这些字段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldBasedInjection</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InjectedBean injectedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如所看到的，这是依赖注入最干净的方法，因为它避免了添加样板代码，并且不需要声明类的构造函数。代码看起来很干净简洁，但是正如代码检查器已经向我们暗示的那样，这种方法有一些缺点。</p><h2 id="3-基于字段的依赖注入缺陷"><a href="#3-基于字段的依赖注入缺陷" class="headerlink" title="3. 基于字段的依赖注入缺陷"></a>3. 基于字段的依赖注入缺陷</h2><h3 id="3-1-不允许声明不可变域"><a href="#3-1-不允许声明不可变域" class="headerlink" title="3.1 不允许声明不可变域"></a>3.1 不允许声明不可变域</h3><p>基于字段的依赖注入在声明为final/immutable的字段上不起作用，因为这些字段必须在类实例化时实例化。声明不可变依赖项的惟一方法是使用基于构造器的依赖注入。</p><h3 id="3-2-容易违反单一职责设计原则"><a href="#3-2-容易违反单一职责设计原则" class="headerlink" title="3.2 容易违反单一职责设计原则"></a>3.2 容易违反单一职责设计原则</h3><p>在面向对象的编程中，五大设计原则**<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>**被广泛应用，（国内一般为六大设计原则），用以提高代码的重用性，可读性，可靠性和可维护性</p><p><strong><em><a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Single_responsibility_principle">S</a></em></strong>在<strong>SOLID</strong>中代表单一职责原则，即即一个类应该只负责一项职责，这个类提供的所有服务都应该只为它负责的职责服务。</p><p>使用基于字段的依赖注入，高频使用的类随着时间的推移，我们会在类中逐渐添加越来越多的依赖项，我们用着很爽，很容易忽略类中的依赖已经太多了。但是如果使用基于构造函数的依赖注入，随着越来越多的依赖项被添加到类中，构造函数会变得越来越大，我们一眼就可以察觉到哪里不对劲。</p><p>有一个有超过10个参数的构造函数是一个明显的信号，表明类已经转变一个大而全的功能合集，需要将类分割成更小、更容易维护的块。</p><p>因此，尽管属性注入并不是破坏单一责任原则的直接原因，但它隐藏了信号，使我们很容易忽略这些信号。</p><h3 id="3-3-与依赖注入容器紧密耦合"><a href="#3-3-与依赖注入容器紧密耦合" class="headerlink" title="3.3 与依赖注入容器紧密耦合"></a>3.3 与依赖注入容器紧密耦合</h3><p>使用基于字段的依赖注入的主要原因是为了避免getter和setter的样板代码或为类创建构造函数。最后，这意味着设置这些字段的唯一方法是通过Spring容器实例化类并使用反射注入它们，否则字段将保持null。</p><p>依赖注入设计模式将类依赖项的创建与类本身分离开来，并将此责任转移到类注入容器，从而允许程序设计解耦，并遵循单一职责和依赖项倒置原则(同样可靠)。因此，通过自动装配（autowiring）字段来实现的类的解耦，最终会因为再次与类注入容器(在本例中是Spring)耦合而丢失，从而使类在Spring容器之外变得无用。</p><p>这意味着，如果您想在应用程序容器之外使用您的类，例如用于单元测试，您将被迫使用Spring容器来实例化您的类，因为没有其他可能的方法(除了反射)来设置自动装配字段。</p><h3 id="3-4-隐藏依赖关系"><a href="#3-4-隐藏依赖关系" class="headerlink" title="3.4 隐藏依赖关系"></a>3.4 隐藏依赖关系</h3><p>在使用依赖注入时，受影响的类应该使用公共接口清楚地公开这些依赖项，方法是在构造函数中公开所需的依赖项，或者使用方法(setter)公开可选的依赖项。当使用基于字段的依赖注入时，实质上是将这些依赖对外隐藏了。</p><h3 id="3-5-初始化时优先级较低"><a href="#3-5-初始化时优先级较低" class="headerlink" title="3.5 初始化时优先级较低"></a>3.5 初始化时优先级较低</h3><p><img src="/.com//Users\13470\AppData\Roaming\Typora\typora-user-images\image-20201029190009906.png" alt="image-20201029190009906"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>我们已经看到，基于字段的注入应该尽可能地避免，因为它有许多缺点，无论它看起来多么优雅。推荐的方法是使用基于构造函数和基于setter的依赖注入。对于必需的依赖，建议使用基于构造函数的注入，设置它们为不可变的，并防止它们为null。对于可选的依赖项，建议使用基于sett的注入。</p><h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h2><p><em><a href="https://link.zhihu.com/?target=http://blog.marcnuri.com/field-injection-is-not-recommended/">Field injection is not recommended – Spring IOC</a></em> <em>by <a href="https://link.zhihu.com/?target=http://blog.marcnuri.com/author/marcnuri/">Marc Nuri</a></em></p><p><em><a href="https://link.zhihu.com/?target=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html%23beans-factory-collaborators">spring官方文档 1.4. Dependencies</a></em></p><h1 id="Field-injection-is-not-recommended（不再推荐使用字段注入）-1"><a href="#Field-injection-is-not-recommended（不再推荐使用字段注入）-1" class="headerlink" title="Field injection is not recommended（不再推荐使用字段注入）"></a>Field injection is not recommended（不再推荐使用字段注入）</h1><p>优点：变量方式注入非常简洁，没有任何多余代码，非常有效的提高了java的简洁性。即使再多几个依赖一样能解决掉这个问题。</p><p>缺点：不能有效的指明依赖。相信很多人都遇见过一个bug，依赖注入的对象为null，在启动依赖容器时遇到这个问题都是配置的依赖注入少了一个注解什么的，然而这种方式就过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。<br>在使用set方式时，这是一种选择注入，可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。<br>在使用构造器方式时已经显式注明必须强制注入。通过强制指明依赖注入来保证这个类的运行。</p><p>另一个方面：<br>依赖注入的核心思想之一就是被容器管理的类不应该依赖被容器管理的依赖，换成白话来说就是如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。<br>既然使用了依赖注入方式，那么就表明这个类不再对这些依赖负责，这些都由容器管理，那么如何清楚的知道这个类需要哪些依赖呢？它就要使用set方法方式注入或者构造器注入。</p><p>总结下：<br>变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Autowired的三种注入方式&quot;&gt;&lt;a href=&quot;#Autowired的三种注入方式&quot; class=&quot;headerlink&quot; title=&quot;@Autowired的三种注入方式&quot;&gt;&lt;/a&gt;@Autowired的三种注入方式&lt;/h1&gt;&lt;h2 id=&quot;Field-i
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="Autowired" scheme="http://yoursite.com/tags/Autowired/"/>
    
  </entry>
  
  <entry>
    <title>Springboot中配置SSL证书</title>
    <link href="http://yoursite.com/2020/12/04/Springboot%E4%B8%AD%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://yoursite.com/2020/12/04/Springboot%E4%B8%AD%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2020-12-04T12:51:02.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot中配置SSL证书"><a href="#Springboot中配置SSL证书" class="headerlink" title="Springboot中配置SSL证书"></a>Springboot中配置SSL证书</h1><h2 id="一、为什么要部署SSL证书："><a href="#一、为什么要部署SSL证书：" class="headerlink" title="一、为什么要部署SSL证书："></a><strong>一、为什么要部署SSL证书：</strong></h2><blockquote><p>目前互联网采取的是全网强制SSL，尤其是微信开发、APP开发、谷歌等都是强制的，为确保数据安全性，把http请求改成HTTPS（URL<br>https://而不是http://）请求确保客户端与站点传输数据的加密作用，所有操作系统都可以部署。</p></blockquote><h2 id="二、SSL证书是什么？"><a href="#二、SSL证书是什么？" class="headerlink" title="二、SSL证书是什么？"></a><strong>二、SSL证书是什么？</strong></h2><blockquote><p>SSL(Secure socket<br>layer)对用户和服务器进行认证，对传输数据进行加密的和隐藏的全球化标准的的安全协议，保证在互联网交易中，双方传递信息的安全性。</p></blockquote><p>作为文件形式存在的证书一般有这几种格式：</p><h2 id="1-带有私钥的证书"><a href="#1-带有私钥的证书" class="headerlink" title="　　**1.**带有私钥的证书"></a>　　**1.**带有私钥的证书</h2><p>　　由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作为证书文件后缀名。</p><h2 id="2-二进制编码的证书"><a href="#2-二进制编码的证书" class="headerlink" title="　　**2.**二进制编码的证书"></a>　　**2.**二进制编码的证书</h2><p>　　证书中没有私钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。</p><h2 id="3-Base64编码的证书"><a href="#3-Base64编码的证书" class="headerlink" title="　　3.Base64编码的证书"></a>　　<strong>3.Base64</strong>编码的证书</h2><p>证书中没有私钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。</p><p><strong>由定义可以看出，只有pfx**</strong>格式的数字证书是包含有私钥的，cer**<strong>格式的数字证书里面只有公钥没有私钥。</strong></p><p>　　在pfx证书的导入过程中有一项是“标志此密钥是可导出的。这将您在稍候备份或传输密钥”。一般是不选中的，如果选中，别人就有机会备份你的密钥了。如果是不选中，其实密钥也导入了，只是不能再次被导出。这就保证了密钥的安全。</p><p>　　如果导入过程中没有选中这一项，做证书备份时“导出私钥”这一项是灰色的，不能选。只能导出cer格式的公钥。如果导入时选中该项，则在导出时“导出私钥”这一项就是可选的。</p><p>　　如果要导出私钥（pfx),是需要输入密码的，这个密码就是对私钥再次加密，这样就保证了私钥的安全，别人即使拿到了你的证书备份（pfx),不知道加密私钥的密码，也是无法导入证书的。相反，如果只是导入导出cer格式的证书，是不会提示你输入密码的。因为公钥一般来说是对外公开的，不用加密</p><h2 id="三-配置"><a href="#三-配置" class="headerlink" title="三. 配置"></a>三. 配置</h2><ol><li><p>将.pfx文件放到项目的resources目录下</p></li><li><p>在properties或yml中如下配置</p></li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https加密端口号 8002</span></span><br><span class="line"><span class="string">server.port=8002</span></span><br><span class="line"><span class="comment">#SSL证书路径 一定要加上classpath: 3824167.jks</span></span><br><span class="line"><span class="string">server.ssl.key-store=classpath:yunservice.ltd.pfx</span></span><br><span class="line"><span class="comment">#SSL证书密码6cj3QrTo</span></span><br><span class="line"><span class="string">server.ssl.key-store-password=7K8UBVe5</span></span><br><span class="line"><span class="comment">#证书类型</span></span><br><span class="line"><span class="string">server.ssl.key-store-type=PKCS12</span></span><br><span class="line"><span class="comment">#证书别名</span></span><br><span class="line"><span class="string">server.ssl.key-alias=alias</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在项目中添加如下配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TomcatServletWebServerFactory <span class="title">tomcatServletWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                SecurityConstraint constraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(<span class="string">&quot;CONFIDENTIAL&quot;</span>);</span><br><span class="line">                SecurityCollection collection = <span class="keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="keyword">return</span> factory;        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connector <span class="title">createTomcatConnector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connector connector = <span class="keyword">new</span> Connector(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        connector.setPort(<span class="number">8001</span>);</span><br><span class="line">        connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="number">8002</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先配置一个TomcatServletWebServerFactory,然后添加一个Tomcat中的Connector（监听80端口），并将请求转发到8080上去.</p><p>配置完成后，在浏览器中输入:”<a href="http://localhost:8001/hello&quot;%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0https://localhost:8002/hello%E4%B8%8A%E3%80%82">http://localhost:8001/hello&quot;，就会自动重定向到https://localhost:8002/hello上。</a></p><p>或者直接输入<a href="https://localhost:8002/hello%E4%B9%9F%E6%98%AF%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84">https://localhost:8002/hello也是能访问的</a></p><h1 id="问题-post请求重定向后变成了GET请求"><a href="#问题-post请求重定向后变成了GET请求" class="headerlink" title="问题: post请求重定向后变成了GET请求"></a>问题: post请求重定向后变成了GET请求</h1><p>配置之后，确实生效。http get 请求 都能被重定向到https get 上，但是 http post 请求 死活不行，后台老是报requestMethod GET not supported，我访问的是post 方法呀，怎么就变成了get,百思不得其解，后来看到一篇博客讲到nginx做转发的时候也有这种问题，看了一下他的解决方法。</p><blockquote><p>server {<br>listen 80;<br>server_name *.snsprj.cn;<br>return 307 <a href="https://$host$request_uri/">https://</a>request_uri;<br>}</p></blockquote><p>我首先注意到了307 状态码，于是我想看一下我用tomcat 配置的它默认返回的状态码是多少<br><img src="https://img-blog.csdn.net/20180427214308461?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEyNDI2NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从上图中可以看出状态码是302，由于本人知识面比较窄，并不知道302，307的代表含义，于是就去查询相关资料，摘自wikipedia</p><blockquote><p>302 Found<br>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。[20]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p></blockquote><p>看到这里就明白了为什么http post 请求重定向时会被变成http get 请求。</p><blockquote><p>307 Temporary Redirect<br>在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求</p></blockquote><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>由于我使用的是tomcat 进行重定向的，从上文中也可以看出tomcat 默认进行的是302重定向，不符合我们的需求，那又什么办法可以解决呢？办法就是不用tomcat提供的配置，那就是我们自己后台程序处理，毕竟用人家的受限制，自己搞，想怎么弄就怎么弄。自己做的话很明显需要一个过滤器，在请求到达sevlet 之前进行处理，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns=&quot;/*&quot;,filterName=&quot;HttpsFilter&quot;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  过滤器，将http 请求转发到https请求上来</span></span><br><span class="line"><span class="comment"> *  重定向类型：307</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> FrankYuan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpsFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(HttpsFilter.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HTTPS =<span class="string">&quot;https&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTPS_PORT = <span class="number">8443</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;------------destroy HttpsFilter --------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">         URL newUrl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(request.getScheme().equals(HTTPS)) &#123;</span><br><span class="line">             chain.doFilter(request, response);</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             HttpServletRequest httpRequest = (HttpServletRequest)request;</span><br><span class="line">             HttpServletResponse httpResponse = (HttpServletResponse)response;</span><br><span class="line">             String queryString = httpRequest.getQueryString()==<span class="keyword">null</span> ? <span class="string">&quot;&quot;</span>:<span class="string">&quot;?&quot;</span>+httpRequest.getQueryString();</span><br><span class="line">             httpResponse.setStatus(<span class="number">307</span>);</span><br><span class="line">             String requestUrl = httpRequest.getRequestURL().toString();</span><br><span class="line">             URL reqUrl = <span class="keyword">new</span> URL(requestUrl+queryString);</span><br><span class="line">             logger.info(<span class="string">&quot;【original request-】 &quot;</span>+reqUrl.toString());</span><br><span class="line">             newUrl = <span class="keyword">new</span> URL(HTTPS,reqUrl.getHost(),HTTPS_PORT,reqUrl.getFile());</span><br><span class="line">             <span class="comment">//进行重定向</span></span><br><span class="line">             logger.info(<span class="string">&quot;【new request-】 &quot;</span>+newUrl.toString());</span><br><span class="line">             httpResponse.setHeader(<span class="string">&quot;Location&quot;</span>, newUrl.toString());</span><br><span class="line">             httpResponse.setHeader(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>);</span><br><span class="line">             <span class="comment">//允许所有跨域请求</span></span><br><span class="line">             httpResponse.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);     </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;------------init HttpsFilter --------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:这里又个坑，就是重定向后需要也需要解决跨域问题，不然页面ajax请求 http 地址会出现跨域问题。</p><p><strong>关键代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">httpResponse.setStatus(<span class="number">307</span>);</span><br></pre></td></tr></table></figure><p>将响应码换成307</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot中配置SSL证书&quot;&gt;&lt;a href=&quot;#Springboot中配置SSL证书&quot; class=&quot;headerlink&quot; title=&quot;Springboot中配置SSL证书&quot;&gt;&lt;/a&gt;Springboot中配置SSL证书&lt;/h1&gt;&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="SSL" scheme="http://yoursite.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>Java中为什么不允许直接创建泛型数组</title>
    <link href="http://yoursite.com/2020/12/04/Java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/12/04/Java%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/</id>
    <published>2020-12-04T13:34:00.000Z</published>
    <updated>2020-12-04T12:51:48.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中为什么不允许直接创建泛型数组"><a href="#Java中为什么不允许直接创建泛型数组" class="headerlink" title="Java中为什么不允许直接创建泛型数组"></a>Java中为什么不允许直接创建泛型数组</h1><p>在Java中，如果创建泛型数组，会出现以下编译错误, 例如<br><code>List&lt;String&gt;[] stringLists = new List&lt;String&gt;[10];</code><br>会提示<br><code>Error:(9, 38) java: 创建泛型数组</code><br>但是却可以创建泛型数组的引用<br><code>List&lt;String&gt;[] stringLists = null;</code><br>并将一个普通数组的引用赋值给它。<br><code>List&lt;String&gt;[] stringLists = new List[10];</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt;[] stringLists = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">        stringLists[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringLists[<span class="number">0</span>].add(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中为什么不允许直接创建泛型数组？<br>《Effective Java》第五章给出了一个解释：</p><blockquote><p>使用泛型的作用是使得程序在编译期可以检查出与类型相关的错误，但是如果使用了泛型数组，这种能力就会受到破坏。</p></blockquote><p>假如我们可以声明这样一个泛型数组（实际上是不可以的）：<br><code>List&lt;String&gt;[] stringLists = new List&lt;String&gt;[10];</code><br>由于在 Java 中，数组是协变(covariant)的，这意味着基类类型的数组可以接收子类类型的数组，例如：<br><code>Object[] objects = stringLists;</code><br>一旦我们这样做之后，就可以通过objects向 stringLists中添加非<code>List&lt;String&gt;</code>类型的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>);</span><br><span class="line">objects[<span class="number">0</span>] = intList;<span class="number">12</span></span><br></pre></td></tr></table></figure><p>随后，再使用 stringList 时，stringList[0] 就会保存 intList, 而使用下面的代码，编译器不会提示错误，但运行时，就会出错。<br><code>String str = stringList[0].get(0);</code></p><p>即使创建出来“泛型数组”以上错误也依然存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] stringLists = (List&lt;String&gt;[])<span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">Object[] objects = stringLists;</span><br><span class="line">List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>);</span><br><span class="line">objects[<span class="number">0</span>] = intList;</span><br><span class="line">String str = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">//runtime error12345</span></span><br></pre></td></tr></table></figure><hr><p>当我们创建泛型容器时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E elem[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_ARRAY_LENGTH = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elem = <span class="keyword">new</span> E[INITIAL_ARRAY_LENGTH]; <span class="comment">//编译期就会报错：不能创建泛型数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E elem[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(Class&lt;?&gt; type, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        elem = (E[]) java.lang.reflect.Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        elem[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E elem[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        elem = (E[]) <span class="keyword">new</span> Object[size];<span class="comment">//强制类型转换就是为了逃避编译时的检查</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        elem[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elem[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Array&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;elem=&quot;</span> + Arrays.toString(elem) +</span><br><span class="line">                <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型的出现在很大程度上是为了避免运行时出现烦人的 <code>ClassCastException</code>，可是具有讽刺意味的是，泛型数组却又导致了<br><code>ClassCastException</code>异常的出现。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Z[][] array=(Z[][])(Array.newInstance(Class&lt;Z&gt; <span class="class"><span class="keyword">class</span> ,<span class="title">XLabel</span>.<span class="title">size</span>(),<span class="title">YLabel</span>.<span class="title">size</span>()))</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中为什么不允许直接创建泛型数组&quot;&gt;&lt;a href=&quot;#Java中为什么不允许直接创建泛型数组&quot; class=&quot;headerlink&quot; title=&quot;Java中为什么不允许直接创建泛型数组&quot;&gt;&lt;/a&gt;Java中为什么不允许直接创建泛型数组&lt;/h1&gt;&lt;p&gt;在J
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么阿里规定需要在事务注解Transactional中指定rollbackFor？</title>
    <link href="http://yoursite.com/2020/12/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E8%A7%84%E5%AE%9A%E9%9C%80%E8%A6%81%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3@Transactional%E4%B8%AD%E6%8C%87%E5%AE%9ArollbackFor%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/12/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%98%BF%E9%87%8C%E8%A7%84%E5%AE%9A%E9%9C%80%E8%A6%81%E5%9C%A8%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3@Transactional%E4%B8%AD%E6%8C%87%E5%AE%9ArollbackFor%EF%BC%9F/</id>
    <published>2020-12-04T12:54:00.000Z</published>
    <updated>2020-12-04T12:56:43.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？"><a href="#为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？" class="headerlink" title="为什么阿里规定需要在事务注解@Transactional中指定rollbackFor？"></a>为什么阿里规定需要在事务注解@Transactional中指定rollbackFor？</h1><blockquote><p>阿里巴巴Java规范：方法【edit】需要在Transactional注解指定rollbackFor或者在方法中显示的rollback。</p></blockquote><h2 id="异常的分类-exception-1-png"><a href="#异常的分类-exception-1-png" class="headerlink" title="异常的分类   exception-1.png"></a>异常的分类  <img src="https://upload-images.jianshu.io/upload_images/12553249-eb4b881c2f4661f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/944/format/webp" alt="img"> exception-1.png</h2><p><img src="https://upload-images.jianshu.io/upload_images/12553249-fba65fc05c777ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1182/format/webp" alt="img"></p><p>Exception.png</p><p>Throwable:有两个重要的子类：Exception（异常）和Error（错误），二者都是Java异常处理的重要子类，各自都包含大量子类。</p><p>Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM   （Java虚拟机）出现的问题。例如。Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需要的内存资源时，将出现  OutOfMemoryError  。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>Exception（异常）：是程序本身可以处理的异常。他又分为运行时异常RuntimeException和非运行时异常。</p><h2 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别"></a>error和exception有什么区别</h2><p>error表示恢复不是不可能但很困难的情况下的一种严重问题。   比如说内存溢出。不可能指望程序能处理这样的情况。exception表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p><h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><p>常见的运行时异常：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ArithmeticException——由于除数为<span class="number">0</span>引起的异常；</span><br><span class="line"></span><br><span class="line">ArrayStoreException——由于数组存储空间不够引起的异常；</span><br><span class="line"></span><br><span class="line">ClassCastException—一当把一个对象归为某个类，但实际上此对象并不是由这个类 创建的，也不是其子类创建的，则会引起异常；</span><br><span class="line"></span><br><span class="line">IllegalMonitorStateException——监控器状态出错引起的异常；</span><br><span class="line"></span><br><span class="line">NegativeArraySizeException—一数组长度是负数，则产生异常；</span><br><span class="line"></span><br><span class="line">NullPointerException—一程序试图访问一个空的数组中的元素或访问空的对象中的 方法或变量时产生异常； OutofMemoryException——用<span class="keyword">new</span>语句创建对象时，如系统无法为其分配内存空 间则产生异常；</span><br><span class="line"></span><br><span class="line">SecurityException——由于访问了不应访问的指针，使安全性出问题而引起异常；</span><br><span class="line"></span><br><span class="line">IndexOutOfBoundsExcention——由于数组下标越界或字符串访问越界引起异常；</span><br><span class="line"></span><br><span class="line">IOException——由于文件未找到、未打开或者I/O操作不能进行而引起异常；</span><br><span class="line"></span><br><span class="line">ClassNotFoundException——未找到指定名字的类或接口引起异常；</span><br><span class="line"></span><br><span class="line">CloneNotSupportedException——一程序中的一个对象引用<span class="keyword">Object</span>类的<span class="keyword">clone</span>方法，但 此对象并没有连接Cloneable接口，从而引起异常；</span><br><span class="line"></span><br><span class="line">InterruptedException—一当一个线程处于等待状态时，另一个线程中断此线程，从 而引起异常，有关线程的内容，将在下一章讲述；</span><br><span class="line"></span><br><span class="line">NoSuchMethodException一所调用的方法未找到，引起异常；</span><br><span class="line"></span><br><span class="line">Illega1AccessExcePtion—一试图访问一个非<span class="keyword">public</span>方法；</span><br><span class="line"></span><br><span class="line">StringIndexOutOfBoundsException——访问字符串序号越界，引起异常；</span><br><span class="line"></span><br><span class="line">ArrayIdexOutOfBoundsException—一访问数组元素下标越界，引起异常；</span><br><span class="line"></span><br><span class="line">NumberFormatException——字符的UTF代码数据格式有错引起异常；</span><br><span class="line"></span><br><span class="line">IllegalThreadException—一线程调用某个方法而所处状态不适当，引起异常；</span><br><span class="line"></span><br><span class="line">FileNotFoundException——未找到指定文件引起异常；</span><br><span class="line"></span><br><span class="line">EOFException——未完成输入操作即遇文件结束引起异常。</span><br></pre></td></tr></table></figure><h2 id="非运行时异常"><a href="#非运行时异常" class="headerlink" title="非运行时异常"></a>非运行时异常</h2><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不要自定义检查异常。</p><h2 id="可查异常和不可查异常"><a href="#可查异常和不可查异常" class="headerlink" title="可查异常和不可查异常"></a>可查异常和不可查异常</h2><blockquote><p>可查的异常（checked exceptions）:Exception下除了RuntimeException外的异常<br> 不可查的异常（unchecked exceptions）:RuntimeException及其子类和错误（Error）</p></blockquote><p>如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。  如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。</p><p>队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。</p><p>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。</p><p>对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p><h2 id="Transactional-的写法"><a href="#Transactional-的写法" class="headerlink" title="@Transactional 的写法"></a>@Transactional 的写法</h2><p><strong><code>@Transactional</code>如果只这样写,Spring框架的事务基础架构代码将默认地 只 在抛出运行时和unchecked exceptions时才标识事务回滚。也就是说，当抛出个RuntimeException 或其子类例的实例时。（Errors 也一样 - 默认地 - 标识事务回滚。）从事务方法中抛出的Checked exceptions将 不 被标识进行事务回滚。</strong></p><ul><li>让checked例外也回滚<br> <code>@Transactional(rollbackFor=Exception.class)</code></li><li>让unchecked例外不回滚<br> <code>@Transactional(notRollbackFor=RunTimeException.class)</code></li><li>不需要事务管理的(只查询的)方法<br> <code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></li></ul><blockquote><p>如果异常被try｛｝catch｛｝了，事务就不回滚了，如果想让事务回滚必须再往外抛try｛｝catch｛throw Exception｝。</p></blockquote><h1 id="关于使用注解-Transactional，手动抛出异常不回滚现象总结："><a href="#关于使用注解-Transactional，手动抛出异常不回滚现象总结：" class="headerlink" title="关于使用注解@Transactional，手动抛出异常不回滚现象总结："></a>关于使用注解@Transactional，手动抛出异常不回滚现象总结：</h1><p>我用的是自定义异常直接继承Exception异常，在实际操作中，出现异常后没有回滚，还是把数据写入数据库了。</p><p>查了一下资料，只有runtimeexception并且没有被try catch处理的异常才会回滚。另外Transactional可以指定回滚异常，然后我用@Transactional(rollbackFor=Exception.class)就好使了。</p><p>总结@Transactional(rollbackFor=Exception.class)如果有异常，并且这个异常没有被try catch 就会回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？&quot;&gt;&lt;a href=&quot;#为什么阿里规定需要在事务注解-Transactional中指定rollbackFor？&quot; class=&quot;headerlink&quot; title=&quot;为什么阿里规
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="Transactional" scheme="http://yoursite.com/tags/Transactional/"/>
    
      <category term="事务回滚" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之定时任务详解</title>
    <link href="http://yoursite.com/2020/12/04/SpringBoot%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/12/04/SpringBoot%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-12-04T12:53:00.000Z</published>
    <updated>2020-12-04T12:53:21.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot之定时任务详解"><a href="#SpringBoot之定时任务详解" class="headerlink" title="SpringBoot之定时任务详解"></a>SpringBoot之定时任务详解</h1><p><strong>阅读目录：</strong></p><ul><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label0">序言</a></li><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label1">一、静态：基于注解</a></li><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label2">二、动态：基于接口</a></li><li><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_label3">三、多线程定时任务</a></li></ul><p><strong>阅读正文：</strong></p><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>使用SpringBoot创建定时任务非常简单，目前主要有以下三种创建方式：</p><ul><li>一、基于注解(@Scheduled)</li><li>二、基于接口（SchedulingConfigurer） 前者相信大家都很熟悉，但是实际使用中我们往往想从数据库中读取指定时间来动态执行定时任务，这时候基于接口的定时任务就派上用场了。</li><li>三、基于注解设定多线程定时任务</li></ul><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="一、静态：基于注解"><a href="#一、静态：基于注解" class="headerlink" title="一、静态：基于注解"></a>一、静态：基于注解</h2><p>基于注解@Scheduled默认为单线程，开启多个任务时，任务的执行时机会受上一个任务执行时间的影响。</p><h4 id="1、创建定时器"><a href="#1、创建定时器" class="headerlink" title="1、创建定时器"></a>1、创建定时器</h4><p>使用SpringBoot基于注解来创建定时任务非常简单，只需几行代码便可完成。 代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration      &#x2F;&#x2F;1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   &#x2F;&#x2F; 2.开启定时任务</span><br><span class="line">public class SaticScheduleTask &#123;</span><br><span class="line">    &#x2F;&#x2F;3.添加定时任务</span><br><span class="line">    @Scheduled(cron &#x3D; &quot;0&#x2F;5 * * * * ?&quot;)</span><br><span class="line">    &#x2F;&#x2F;或直接指定时间间隔，例如：5秒</span><br><span class="line">    &#x2F;&#x2F;@Scheduled(fixedRate&#x3D;5000)</span><br><span class="line">    private void configureTasks() &#123;</span><br><span class="line">        System.err.println(&quot;执行静态定时任务时间: &quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="Cron表达式参数分别表示："><a href="#Cron表达式参数分别表示：" class="headerlink" title="Cron表达式参数分别表示："></a>Cron表达式参数分别表示：</h4><ul><li>秒（0~59） 例如0/5表示每5秒</li><li>分（0~59）</li><li>时（0~23）</li><li>日（0~31）的某天，需计算</li><li>月（0~11）</li><li>周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT）</li></ul><p>@Scheduled：除了支持灵活的参数表达式cron之外，还支持简单的延时操作，例如 fixedDelay ，fixedRate 填写相应的毫秒数即可。</p><ol><li>首先使用 @Scheduled 注解开启一个定时任务。</li><li>fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。</li><li>fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。</li><li>initialDelay 表示首次任务启动的延迟时间。</li><li>所有时间的单位都是毫秒。</li></ol><p>上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下：</p><blockquote><p>[秒] [分] [小时] [日] [月] [周] [年]</p></blockquote><p>具体取值如下：</p><table><thead><tr><th align="left">序号</th><th align="left">说明</th><th align="left">是否必填</th><th align="left">允许填写的值</th><th align="left">允许的通配符</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">秒</td><td align="left">是</td><td align="left">0-59</td><td align="left">- * /</td></tr><tr><td align="left">2</td><td align="left">分</td><td align="left">是</td><td align="left">0-59</td><td align="left">- * /</td></tr><tr><td align="left">3</td><td align="left">时</td><td align="left">是</td><td align="left">0-23</td><td align="left">- * /</td></tr><tr><td align="left">4</td><td align="left">日</td><td align="left">是</td><td align="left">1-31</td><td align="left">- * ? / L W</td></tr><tr><td align="left">5</td><td align="left">月</td><td align="left">是</td><td align="left">1-12 or JAN-DEC</td><td align="left">- * /</td></tr><tr><td align="left">6</td><td align="left">周</td><td align="left">是</td><td align="left">1-7 or SUN-SAT</td><td align="left">- * ? / L #</td></tr><tr><td align="left">7</td><td align="left">年</td><td align="left">否</td><td align="left">1970-2099</td><td align="left">- * /</td></tr></tbody></table><p><strong>这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></strong></p><p><strong>通配符含义：</strong></p><ul><li><code>?</code> 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></li><li><code>*</code> 表示所有值，例如:在秒的字段上设置 <code>*</code>,表示每一秒都会触发</li><li><code>,</code> 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li><li><code>-</code> 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发</li><li><code>/</code> 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)</li><li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了)</li><li>周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同</li><li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五”</li><li><code>W</code> 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)</li><li><code>L</code> 和 <code>W</code> 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )</li></ul><p>例如，在 @Scheduled 注解中来一个简单的 cron 表达式，每隔5秒触发一次，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、启动测试"><a href="#2、启动测试" class="headerlink" title="2、启动测试"></a>2、启动测试</h4><p>启动应用，可以看到控制台打印出如下信息：</p><p><img src="https://img-blog.csdnimg.cn/20181220161509852.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>显然，使用@Scheduled 注解很方便，但缺点是当我们调整了执行周期的时候，需要重启应用才能生效，这多少有些不方便。为了达到实时生效的效果，可以使用接口来完成定时任务。</p><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="二、动态：基于接口"><a href="#二、动态：基于接口" class="headerlink" title="二、动态：基于接口"></a>二、动态：基于接口</h2><p>基于接口（SchedulingConfigurer）</p><h4 id="1、导入依赖包："><a href="#1、导入依赖包：" class="headerlink" title="1、导入依赖包："></a>1、导入依赖包：</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!--添加Web依赖 --&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!--添加MySql依赖 --&gt;</span><br><span class="line">         &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!--添加Mybatis依赖 配置mybatis的一些初始化的东西--&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;&lt;!-- 添加mybatis依赖 --&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="2、添加数据库记录："><a href="#2、添加数据库记录：" class="headerlink" title="2、添加数据库记录："></a>2、添加数据库记录：</h4><p>开启本地数据库mysql，随便打开查询窗口，然后执行脚本内容，如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS &#96;socks&#96;;</span><br><span class="line">CREATE DATABASE &#96;socks&#96;;</span><br><span class="line">USE &#96;SOCKS&#96;;</span><br><span class="line">DROP TABLE IF EXISTS &#96;cron&#96;;</span><br><span class="line">CREATE TABLE &#96;cron&#96;  (</span><br><span class="line">  &#96;cron_id&#96; varchar(30) NOT NULL PRIMARY KEY,</span><br><span class="line">  &#96;cron&#96; varchar(30) NOT NULL  </span><br><span class="line">);</span><br><span class="line">INSERT INTO &#96;cron&#96; VALUES (&#39;1&#39;, &#39;0&#x2F;5 * * * * ?&#39;);</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><img src="https://img-blog.csdnimg.cn/20181220161546371.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>然后在项目中的application.yml 添加数据源：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;socks</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br></pre></td></tr></table></figure><h4 id="3、创建定时器"><a href="#3、创建定时器" class="headerlink" title="3、创建定时器"></a>3、创建定时器</h4><p>数据库准备好数据之后，我们编写定时任务，注意这里添加的是TriggerTask，目的是循环读取我们在数据库设置好的执行周期，以及执行相关定时任务的内容。<br>具体代码如下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration      &#x2F;&#x2F;1.主要用于标记配置类，兼备Component的效果。</span><br><span class="line">@EnableScheduling   &#x2F;&#x2F; 2.开启定时任务</span><br><span class="line">public class DynamicScheduleTask implements SchedulingConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Mapper</span><br><span class="line">    public interface CronMapper &#123;</span><br><span class="line">        @Select(&quot;select cron from cron limit 1&quot;)</span><br><span class="line">        public String getCron();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired      &#x2F;&#x2F;注入mapper</span><br><span class="line">    @SuppressWarnings(&quot;all&quot;)</span><br><span class="line">    CronMapper cronMapper;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 执行定时任务.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                &#x2F;&#x2F;1.添加任务内容(Runnable)</span><br><span class="line">                () -&gt; System.out.println(&quot;执行动态定时任务: &quot; + LocalDateTime.now().toLocalTime()),</span><br><span class="line">                &#x2F;&#x2F;2.设置执行周期(Trigger)</span><br><span class="line">                triggerContext -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F;2.1 从数据库获取执行周期</span><br><span class="line">                    String cron &#x3D; cronMapper.getCron();</span><br><span class="line">                    &#x2F;&#x2F;2.2 合法性校验.</span><br><span class="line">                    if (StringUtils.isEmpty(cron)) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Omitted Code ..</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;2.3 返回执行周期(Date)</span><br><span class="line">                    return new CronTrigger(cron).nextExecutionTime(triggerContext);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h4 id="4、启动测试"><a href="#4、启动测试" class="headerlink" title="4、启动测试"></a>4、启动测试</h4><p>启动应用后，查看控制台，打印时间是我们预期的每10秒一次：<br><img src="https://img-blog.csdnimg.cn/20181220161739406.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>然后打开Navicat ，将执行周期修改为每6秒执行一次，如图：<br><img src="https://img-blog.csdnimg.cn/20181220161905131.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>查看控制台，发现执行周期已经改变，并且不需要我们重启应用，十分方便。如图：<br><img src="https://img-blog.csdnimg.cn/20181220161911141.png?ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>注意： 如果在数据库修改时格式出现错误，则定时任务会停止，即使重新修改正确；此时只能重新启动项目才能恢复。</p><p><a href="https://www.cnblogs.com/mmzs/p/10161936.html#_labelTop">回到顶部</a></p><h2 id="三、多线程定时任务"><a href="#三、多线程定时任务" class="headerlink" title="三、多线程定时任务"></a>三、多线程定时任务</h2><p>基于注解设定多线程定时任务</p><h4 id="1、创建多线程定时任务"><a href="#1、创建多线程定时任务" class="headerlink" title="1、创建多线程定时任务"></a>1、创建多线程定时任务</h4><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@Component注解用于对那些比较中立的类进行注释；</span><br><span class="line">&#x2F;&#x2F;相对与在持久层、业务层和控制层分别采用 @Repository、@Service 和 @Controller 对分层中的类进行注释</span><br><span class="line">@Component</span><br><span class="line">@EnableScheduling   &#x2F;&#x2F; 1.开启定时任务</span><br><span class="line">@EnableAsync        &#x2F;&#x2F; 2.开启多线程</span><br><span class="line">public class MultithreadScheduleTask &#123;</span><br><span class="line"></span><br><span class="line">        @Async</span><br><span class="line">        @Scheduled(fixedDelay &#x3D; 1000)  &#x2F;&#x2F;间隔1秒</span><br><span class="line">        public void first() throws InterruptedException &#123;</span><br><span class="line">            System.out.println(&quot;第一个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">            System.out.println();</span><br><span class="line">            Thread.sleep(1000 * 10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Async</span><br><span class="line">        @Scheduled(fixedDelay &#x3D; 2000)</span><br><span class="line">        public void second() &#123;</span><br><span class="line">            System.out.println(&quot;第二个定时任务开始 : &quot; + LocalDateTime.now().toLocalTime() + &quot;\r\n线程 : &quot; + Thread.currentThread().getName());</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>注：</strong> 这里的<a href="https://www.cnblogs.com/mmzs/p/11557583.html">@Async</a>注解很关键</p><h4 id="2、启动测试-1"><a href="#2、启动测试-1" class="headerlink" title="2、启动测试"></a>2、启动测试</h4><p>启动应用后，查看控制台：<br><img src="https://img-blog.csdnimg.cn/20181220165535820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vYml1c1N0cmlw,size_16,color_FFFFFF,t_70&ynotemdtimestamp=1545462152300" alt="在这里插入图片描述"> </p><p>从控制台可以看出，第一个定时任务和第二个定时任务互不影响；</p><p>并且，由于开启了多线程，第一个任务的执行时间也不受其本身执行时间的限制，所以需要注意可能会出现重复操作导致数据异常。</p><p>代码地址：<a href="https://github.com/mmzsblog/springboot-schedule">https://github.com/mmzsblog/springboot-schedule</a></p>]]></content>
    
    <summary type="html">
    
      SpringBoot之定时任务详解
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="定时任务" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目启动时如何执行特定方法</title>
    <link href="http://yoursite.com/2020/12/04/Spring%20Boot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/12/04/Spring%20Boot%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%97%B6%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-04T12:52:00.000Z</published>
    <updated>2020-12-04T12:52:30.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot：项目启动时如何执行特定方法"><a href="#Spring-Boot：项目启动时如何执行特定方法" class="headerlink" title="Spring Boot：项目启动时如何执行特定方法"></a>Spring Boot：项目启动时如何执行特定方法</h1><h2 id="1-PostConstruct"><a href="#1-PostConstruct" class="headerlink" title="1. @PostConstruct"></a>1. @PostConstruct</h2><p>应该也是最简单的方式</p><p>直接在方式上面注入，但是会影响服务提供，比如这个方法要执行五分钟 这五分钟之内是无法提供服务的，这个方法是在服务初始化后之前运行， 所以 此方法运行不结束，服务就无法初始化， 在这过程路也无法提供服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">pingStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; ping start:&quot;</span>);</span><br><span class="line">    getPingip();</span><br><span class="line">    System.out.println(<span class="string">&quot; ping end: &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用ApplicationListener"><a href="#2-使用ApplicationListener" class="headerlink" title="2. 使用ApplicationListener"></a>2. 使用ApplicationListener</h2><p>是通过监听接口方式启动，服务已经初始化过，不影响 服务启动，并且启动之后可以正常提供服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationStartQuartzJobListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzManager quartzManager;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始启动quartz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            quartzManager.start();</span><br><span class="line">            System.out.println(<span class="string">&quot;任务已经启动...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-CommandLineRunner"><a href="#3-CommandLineRunner" class="headerlink" title="3. CommandLineRunner"></a>3. CommandLineRunner</h2><p>也是监听接口方式，启动服务，执行方式时仍然提供服务，服务初始化之后，执行方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartPingService</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Ping ping;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        ping.pingStart();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-指定启动方法执行的顺序"><a href="#4-指定启动方法执行的顺序" class="headerlink" title="4. 指定启动方法执行的顺序"></a>4. 指定启动方法执行的顺序</h2><p> 这两种方式的实现都很简单，直接实现了相应的接口就可以了。记得在类上加@Component注解。</p><p>如果想要指定启动方法执行的顺序，可以通过实现org.springframework.core.Ordered接口或者使用org.springframework.core.annotation.Order注解来实现。</p><p><strong>1.Ordered接口：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.boot.ApplicationArguments;</span><br><span class="line">import org.springframework.boot.ApplicationRunner;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner,Ordered&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder()&#123;</span><br><span class="line">        return 1;&#x2F;&#x2F;通过设置这里的数字来知道指定顺序</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments var1) throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner1!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><p><strong>2.Order注解实现方式：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.boot.ApplicationArguments;</span><br><span class="line">import org.springframework.boot.ApplicationRunner;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Order(value &#x3D; 1)</span><br><span class="line">public class MyApplicationRunner implements ApplicationRunner&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments var1) throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;MyApplicationRunner1!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用例, 类, 写作, 顺序</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot：项目启动时如何执行特定方法&quot;&gt;&lt;a href=&quot;#Spring-Boot：项目启动时如何执行特定方法&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot：项目启动时如何执行特定方法&quot;&gt;&lt;/a&gt;Spring Boot
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>VIM使用教程</title>
    <link href="http://yoursite.com/2020/12/04/%E7%AE%80%E6%98%8EVIM%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/"/>
    <id>http://yoursite.com/2020/12/04/%E7%AE%80%E6%98%8EVIM%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</id>
    <published>2020-12-04T12:50:00.000Z</published>
    <updated>2020-12-04T12:50:41.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简明VIM练级攻略"><a href="#简明VIM练级攻略" class="headerlink" title="简明VIM练级攻略"></a>简明VIM练级攻略</h1><p>vim的学习曲线相当的大（参看<a href="https://coolshell.cn/articles/3125.html">各种文本编辑器的学习曲线</a>），所以，如果你一开始看到的是一大堆VIM的命令分类，你一定会对这个编辑器失去兴趣的。下面的文章翻译自《<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">Learn Vim Progressively</a>》，我觉得这是给新手最好的VIM的升级教程了，没有列举所有的命令，只是列举了那些最有用的命令。非常不错。</p><p>——————————正文开始——————————</p><p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。</p><p><a href="http://www.vim.org/">Vim</a> the Six Billion Dollar editor</p><blockquote><p>Better, Stronger, Faster.</p></blockquote><p>学习 <a href="http://www.vim.org/">vim</a> 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p><p>我建议下面这四个步骤：</p><ol><li>存活</li><li>感觉良好</li><li>觉得更好，更强，更快</li><li>使用VIM的超能力</li></ol><p>当你走完这篇文章，你会成为一个vim的 superstar。</p><p>在开始学习以前，我需要给你一些警告：</p><ul><li>学习vim在开始时是痛苦的。</li><li>需要时间</li><li>需要不断地练习，就像你学习一个乐器一样。</li><li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li><li>事实上，你需要2周时间的苦练，而不是3天。</li></ul><h2 id="第一级-–-存活"><a href="#第一级-–-存活" class="headerlink" title="第一级 – 存活"></a><strong>第一级 – 存活</strong></h2><ol><li>安装 <a href="http://www.vim.org/">vim</a></li><li>启动 vim</li><li><strong>什么也别干！</strong>请先阅读</li></ol><p>当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p><ul><li>启 动Vim后，vim在 <em>Normal</em> 模式下。</li><li>让我们进入 <em>Insert</em> 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</li><li>此时，你可以输入文本了，就像你用“记事本”一样。</li><li>如果你想返回 <em>Normal</em> 模式，请按 <code>ESC</code> 键。</li></ul><p>现在，你知道如何在 <em>Insert</em> 和 <em>Normal</em> 模式下切换了。下面是一些命令，可以让你在 <em>Normal</em> 模式下幸存下来：</p><blockquote><ul><li><code>i</code> → <em>Insert</em> 模式，按 <code>ESC</code> 回到 <em>Normal</em> 模式.</li><li><code>x</code> → 删当前光标所在的一个字符。</li><li><code>:wq</code> → 存盘 + 退出 (<code>:w</code> 存盘, <code>:q</code> 退出)  （陈皓注：:w 后可以跟文件名）</li><li><code>dd</code> → 删除当前行，并把删除的行存到剪贴板里</li><li><code>p</code> → 粘贴剪贴板</li></ul><p><strong>推荐</strong>:</p><ul><li><code>hjkl</code> (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: <code>j</code> 就像下箭头。</li><li><code>:help &lt;command&gt;</code> → 显示相关命令的帮助。你也可以就输入 <code>:help</code> 而不跟命令。（陈皓注：退出帮助需要输入:q）</li></ul></blockquote><p>你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p><p>当是，在你进入第二级时，需要再说一下 <em>Normal</em> 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 <code>Ctrl</code> 键，比如：<code>Ctrl-C</code>。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，<strong>在VIM的Normal模式下，所有的键就是功能键了</strong>。这个你需要知道。</p><p>标记:</p><ul><li>下面的文字中，如果是 <code>Ctrl-λ</code>我会写成 <code>&lt;C-λ&gt;</code>.</li><li>以 <code>:</code> 开始的命令你需要输入 <code>&lt;enter&gt;</code>回车，例如 — 如果我写成 <code>:q</code> 也就是说你要输入 <code>:q&lt;enter&gt;</code>.</li></ul><h2 id="第二级-–-感觉良好"><a href="#第二级-–-感觉良好" class="headerlink" title="第二级 – 感觉良好"></a><strong>第二级 – 感觉良好</strong></h2><p>上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）</p><h3 id="各种插入模式"><a href="#各种插入模式" class="headerlink" title="各种插入模式"></a>各种插入模式</h3><blockquote><ul><li><code>a</code> → 在光标后插入</li><li><code>o</code> → 在当前行后插入一个新行</li><li><code>O</code> → 在当前行前插入一个新行</li><li><code>cw</code> → 替换从光标所在位置后到一个单词结尾的字符</li></ul></blockquote><h3 id="简单的移动光标"><a href="#简单的移动光标" class="headerlink" title="简单的移动光标"></a>简单的移动光标</h3><blockquote><ul><li><code>0</code> → 数字零，到行头</li><li><code>^</code> → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</li><li><code>$</code> → 到本行行尾</li><li><code>g_</code> → 到本行最后一个不是blank字符的位置。</li><li><code>/pattern</code> → 搜索 <code>pattern</code> 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）</li></ul></blockquote><h3 id="拷贝-粘贴"><a href="#拷贝-粘贴" class="headerlink" title="拷贝/粘贴"></a>拷贝/粘贴</h3><p> （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</p><blockquote><ul><li><code>P</code> → 粘贴</li><li><code>yy</code> → 拷贝当前行当行于 <code>ddP</code></li></ul></blockquote><h3 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo/Redo"></a>Undo/Redo</h3><blockquote><ul><li><code>u</code> → undo</li><li><code>&lt;C-r&gt;</code> → redo</li></ul></blockquote><h3 id="打开-保存-退出-改变文件"><a href="#打开-保存-退出-改变文件" class="headerlink" title="打开/保存/退出/改变文件"></a>打开/保存/退出/改变文件</h3><p>(Buffer)</p><blockquote><ul><li><code>:e &lt;path/to/file&gt;</code> → 打开一个文件</li><li><code>:w</code> → 存盘</li><li><code>:saveas &lt;path/to/file&gt;</code> → 另存为 <code>&lt;path/to/file&gt;</code></li><li><code>:x</code>， <code>ZZ</code> 或 <code>:wq</code> → 保存并退出 (<code>:x</code> 表示仅在需要时保存，ZZ不需要输入冒号并回车)</li><li><code>:q!</code> → 退出不保存 <code>:qa!</code> 强行退出所有的正在编辑的文件，就算别的文件有更改。</li><li><code>:bn</code> 和 <code>:bp</code> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）</li></ul></blockquote><p>花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p><h2 id="第三级-–-更好，更强，更快"><a href="#第三级-–-更好，更强，更快" class="headerlink" title="第三级 – 更好，更强，更快"></a><strong>第三级 – 更好，更强，更快</strong></h2><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p><h3 id="更好"><a href="#更好" class="headerlink" title="更好"></a><strong>更好</strong></h3><p>下面，让我们看一下vim是怎么重复自己的：</p><ol><li><code>.</code> → (小数点) 可以重复上一次的命令</li><li>N<command> → 重复某个命令N次</li></ol><p>下面是一个示例，找开一个文件你可以试试下面的命令：</p><blockquote><ul><li><code>2dd</code> → 删除2行</li><li><code>3p</code> → 粘贴文本3次</li><li><code>100idesu [ESC]</code> → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</li><li><code>.</code> → 重复上一个命令—— 100 “desu “.</li><li><code>3.</code> → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</li></ul></blockquote><h3 id="更强"><a href="#更强" class="headerlink" title="更强"></a><strong>更强</strong></h3><p>你要让你的光标移动更有效率，你一定要了解下面的这些命令，<strong>千万别跳过</strong>。</p><ol><li><p>N<code>G</code> → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</p></li><li><p><code>gg</code> → 到第一行。（陈皓注：相当于1G，或 :1）</p></li><li><p><code>G</code> → 到最后一行。</p></li><li><p>按单词移动：</p><blockquote><ol><li><code>w</code> → 到下一个单词的开头。</li><li><code>e</code> → 到下一个单词的结尾。</li></ol><p>&gt; 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量）</p><p>&gt; 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句）</p><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/word_moves.jpg"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/word_moves.jpg" alt="Word moves example"></a></p></blockquote></li></ol><p>下面，让我来说说最强的光标移动：</p><blockquote><ul><li><code>%</code> : 匹配括号移动，包括 <code>(</code>, <code>&#123;</code>, <code>[</code>. （陈皓注：你需要把光标先移到括号上）</li><li><code>*</code> 和 <code>#</code>:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li></ul></blockquote><p>相信我，上面这三个命令对程序员来说是相当强大的。</p><h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a><strong>更快</strong></h3><p>你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</span><br></pre></td></tr></table></figure><p>例如 <code>0y$</code> 命令意味着：</p><ul><li><code>0</code> → 先到行头</li><li><code>y</code> → 从这里开始拷贝</li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul><p>你可可以输入 <code>ye</code>，从当前位置拷贝到本单词的最后一个字符。</p><p>你也可以输入 <code>y2/foo</code> 来拷贝2个 “foo” 之间的字符串。</p><p>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p><ul><li><code>d</code> (删除 )</li><li><code>v</code> (可视化的选择)</li><li><code>gU</code> (变大写)</li><li><code>gu</code> (变小写)</li><li>等等</li></ul><p>（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</p><h2 id="第四级-–-Vim-超能力"><a href="#第四级-–-Vim-超能力" class="headerlink" title="第四级 – Vim 超能力"></a><strong>第四级 – Vim 超能力</strong></h2><p>你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p><h3 id="在当前行上移动光标-0-f-F-t-T"><a href="#在当前行上移动光标-0-f-F-t-T" class="headerlink" title="在当前行上移动光标: 0 ^ $ f F t T , ;"></a><strong>在当前行上移动光标: 0 ^ $ f F t T , ;</strong></h3><blockquote><ul><li><code>0</code> → 到行头</li><li><code>^</code> → 到本行的第一个非blank字符</li><li><code>$</code> → 到行尾</li><li><code>g_</code> → 到本行最后一个不是blank字符的位置。</li><li><code>fa</code> → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</li><li><code>t,</code> → 到逗号前的第一个字符。逗号可以变成其它字符。</li><li><code>3fa</code> → 在当前行查找第三个出现的a。</li><li><code>F</code> 和 <code>T</code> → 和 <code>f</code> 和 <code>t</code> 一样，只不过是相反方向。<br><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/line_moves.jpg"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/line_moves.jpg" alt="Line moves"></a></li></ul></blockquote><p>还有一个很有用的命令是 <code>dt&quot;</code> → 删除所有的内容，直到遇到双引号—— <code>&quot;。</code></p><h3 id="区域选择-a-或-i"><a href="#区域选择-a-或-i" class="headerlink" title="区域选择 a 或 i"></a><strong>区域选择 <action>a<object> 或 <action>i<object></object></action></object></action></strong></h3><p>在visual 模式下，这些命令很强大，其命令格式为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;action&gt;a&lt;object&gt;&#96; 和 &#96;&lt;action&gt;i&lt;object&gt;</span><br></pre></td></tr></table></figure><ul><li>action可以是任何的命令，如 <code>d</code> (删除), <code>y</code> (拷贝), <code>v</code> (可以视模式选择)。</li><li>object 可能是： <code>w</code> 一个单词， <code>W</code> 一个以空格为分隔的单词， <code>s</code> 一个句字， <code>p</code> 一个段落。也可以是一个特别的字符：<code>&quot;、</code> <code>&#39;、</code> <code>)、</code> <code>&#125;、</code> <code>]。</code></li></ul><p>假设你有一个字符串 <code>(map (+) (&quot;foo&quot;))</code>.而光标键在第一个 <code>o </code>的位置。</p><blockquote><ul><li><code>vi&quot;</code> → 会选择 <code>foo</code>.</li><li><code>va&quot;</code> → 会选择 <code>&quot;foo&quot;</code>.</li><li><code>vi)</code> → 会选择 <code>&quot;foo&quot;</code>.</li><li><code>va)</code> → 会选择<code>(&quot;foo&quot;)</code>.</li><li><code>v2i)</code> → 会选择 <code>map (+) (&quot;foo&quot;)</code></li><li><code>v2a)</code> → 会选择 <code>(map (+) (&quot;foo&quot;))</code></li></ul></blockquote><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/textobjects.png"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/textobjects.png" alt="Text objects selection"></a></p><h3 id="块操作"><a href="#块操作" class="headerlink" title="块操作: "></a><strong>块操作: <C-v></C-v></strong></h3><p>块操作，典型的操作： <code>0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</code></p><ul><li><code>^</code> → 到行头</li><li><code>&lt;C-v&gt;</code> → 开始块操作</li><li><code>&lt;C-d&gt;</code> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)</li><li><code>I-- [ESC]</code> → I是插入，插入“<code>--</code>”，按ESC键来为每一行生效。</li></ul><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/rectangular-blocks.gif"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/rectangular-blocks.gif" alt="Rectangular blocks"></a></p><p>在Windows下的vim，你需要使用 <code>&lt;C-q&gt;</code> 而不是 <code>&lt;C-v&gt;</code> ，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p><h3 id="自动提示：-和"><a href="#自动提示：-和" class="headerlink" title="自动提示：  和 "></a><strong>自动提示： <C-n> 和 <C-p></C-p></C-n></strong></h3><p>在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了……</code></p><p>``<a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/completion.gif"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/completion.gif" alt="Completion"></a></p><h3 id="宏录制：-qa-操作序列-q-a"><a href="#宏录制：-qa-操作序列-q-a" class="headerlink" title="宏录制： qa 操作序列 q, @a, @@"></a><strong>宏录制： qa 操作序列 q, @a, @@</strong></h3><ul><li><code>qa</code> 把你的操作记录在寄存器 <code>a。</code></li><li>于是 <code>@a</code> 会replay被录制的宏。</li><li><code>@@</code> 是一个快捷键用来replay最新录制的宏。</li></ul><blockquote><p><strong>示例</strong></p><p>在一个只有一行且这一行只有“1”的文本中，键入如下命令：</p><ul><li><pre><code>qaYp&lt;C-a&gt;q</code></pre><p>→</p><ul><li><code>qa</code> 开始录制</li><li><code>Yp</code> 复制行.</li><li><code>&lt;C-a&gt;</code> 增加1.</li><li><code>q</code> 停止录制.</li></ul></li><li><p><code>@a</code> → 在1下面写下 2</p></li><li><p><code>@@</code> → 在2 正面写下3</p></li><li><p>现在做 <code>100@@</code> 会创建新的100行，并把数据增加到 103.</p></li></ul></blockquote><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/macros.gif"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/macros.gif" alt="Macros"></a></p><h3 id="可视化选择：-v-V"><a href="#可视化选择：-v-V" class="headerlink" title="可视化选择： v,V,"></a><strong>可视化选择： v,V,<C-v></C-v></strong></h3><p>前面，我们看到了 <code>&lt;C-v&gt;</code>的示例 （在Windows下应该是<C-q>），我们可以使用 <code>v</code> 和 <code>V</code>。一但被选好了，你可以做下面的事：</C-q></p><ul><li><code>J</code> → 把所有的行连接起来（变成一行）</li><li><code>&lt;</code> 或 <code>&gt;</code> → 左右缩进</li><li><code>=</code> → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）</li></ul><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/autoindent.gif"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/autoindent.gif" alt="Autoindent"></a></p><p>在所有被选择的行后加上点东西：</p><ul><li><code>&lt;C-v&gt;</code></li><li>选中相关的行 (可使用 <code>j</code> 或 <code>&lt;C-d&gt;</code> 或是 <code>/pattern</code> 或是 <code>%</code> 等……)</li><li><code>$</code> 到行最后</li><li><code>A</code>, 输入字符串，按 <code>ESC。</code></li></ul><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/append-to-many-lines.gif"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/append-to-many-lines.gif" alt="Append to many lines"></a></p><h3 id="分屏-split-和-vsplit"><a href="#分屏-split-和-vsplit" class="headerlink" title="分屏: :split 和 vsplit."></a><strong>分屏: :split 和 vsplit.</strong></h3><p>下面是主要的命令，你可以使用VIM的帮助 <code>:help split</code>. 你可以参考本站以前的一篇文章<a href="https://coolshell.cn/articles/1679.html">VIM分屏</a>。</p><blockquote><ul><li><code>:split</code> → 创建分屏 (<code>:vsplit</code>创建垂直分屏)</li><li><code>&lt;C-w&gt;&lt;dir&gt;</code> : dir就是方向，可以是 <code>hjkl</code> 或是 ←↓↑→ 中的一个，其用来切换分屏。</li><li><code>&lt;C-w&gt;_</code> (或 <code>&lt;C-w&gt;|</code>) : 最大化尺寸 (<C-w>| 垂直分屏)</C-w></li><li><code>&lt;C-w&gt;+</code> (或 <code>&lt;C-w&gt;-</code>) : 增加尺寸</li></ul></blockquote><p><a href="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/split.gif"><img src="http://yannesposito.com/Scratch/img/blog/Learn-Vim-Progressively/split.gif" alt="Split"></a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><ul><li><p>上面是作者最常用的90%的命令。</p></li><li><p>我建议你每天都学1到2个新的命令。</p></li><li><p>在两到三周后，你会感到vim的强大的。</p></li><li><p>有时候，学习VIM就像是在死背一些东西。</p></li><li><p>幸运的是，vim有很多很不错的工具和优秀的文档。</p></li><li><p>运行vimtutor直到你熟悉了那些基本命令。</p></li><li><p>其在线帮助文档中你应该要仔细阅读的是 <code>:help usr_02.txt</code>.</p></li><li><p>你会学习到诸如 <code>!，</code> 目录，寄存器，插件等很多其它的功能。</p></li></ul><p>学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p><p>——————————正文结束——————————</p><p>对于vi/vim只是点评一点：这是一个你不需要使用鼠标，不需使用小键盘，只需要使用大键盘就可以完成很多复杂功能文本编辑的编辑器。不然，<a href="https://coolshell.cn/articles/1901.html">Visual Studio也不就会有vim的插件了</a>。</p>]]></content>
    
    <summary type="html">
    
      简明VIM练级攻略
    
    </summary>
    
    
      <category term="VIM" scheme="http://yoursite.com/categories/VIM/"/>
    
    
      <category term="VIM" scheme="http://yoursite.com/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>Linux安全之SSH 密钥创建及密钥登录</title>
    <link href="http://yoursite.com/2020/12/04/Linux%E5%AE%89%E5%85%A8%E4%B9%8BSSH%20%E5%AF%86%E9%92%A5%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2020/12/04/Linux%E5%AE%89%E5%85%A8%E4%B9%8BSSH%20%E5%AF%86%E9%92%A5%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/</id>
    <published>2020-12-04T12:40:00.000Z</published>
    <updated>2020-12-04T12:40:48.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux安全之SSH-密钥创建及密钥登录"><a href="#Linux安全之SSH-密钥创建及密钥登录" class="headerlink" title="Linux安全之SSH 密钥创建及密钥登录"></a>Linux安全之SSH 密钥创建及密钥登录</h1><p>在我们平时使用Linux系统时候，通常使用的Linux SSH登录方式是用户名加密码的登录方式，今天来探讨另外的一种相对安全的登录方式——密钥登录。</p><p>我们知道SSH登录是用的RSA非对称加密的，所以我们在SSH登录的时候就可以使用RSA密钥登录，SSH有专门创建SSH密钥的工具ssh-keygen，下面就来一睹风采。</p><h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><p>首先进入Linux系统的用户目录下的.ssh目录下，root用户是/root/.ssh，普通用户是/home/您的用户名/.ssh，我们以root用户为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/.ssh</span><br></pre></td></tr></table></figure><p> 可以先看看目录下，如果没有进行过ssh密钥创建是长这样子的：</p><p><img src="https://img-blog.csdn.net/20180114210719384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p> 执行ssh-keygen命令创建密钥对，</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br></pre></td></tr></table></figure><p>这里笔者加了-b 参数，指定了长度，也可以不加-b参数，直接使用ssh-keygen -t rsa，ssh-keygen命令的参数后文再介绍。</p><p>执行密钥生成命令，基本上是一路回车既可以了，但是需要注意的是：执行命令的过程中是会提示呢输入密钥的密码的（如下图中红色箭头处，输入两次相同的，即是又一次确认密码），不需要密码直接回车就行。</p><p><img src="https://img-blog.csdn.net/20180114211526868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>密钥生成后会在当前目录下多出两个文件，id_rsa和id_rsa.pub，其中id_rsa是私钥（敲黑板：这个很重要，不能外泄），id_rsa.pub这个是公钥，</p><p><img src="https://img-blog.csdn.net/20180114211740064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>把公钥拷贝到需要登录的远程服务器或Linux系统上，这里可以使用ssh-copy-id自动完成，也可以手动追加秘钥到远程服务器。</p><h2 id="方法一（推荐）："><a href="#方法一（推荐）：" class="headerlink" title="方法一（推荐）："></a>方法一（推荐）：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.100.10</span><br></pre></td></tr></table></figure><p>执行命令了会要求输入远程机器的密码，输入密码即可。</p><p>注：ssh-copy-id默认端口是22，如果您的SSH端口不是22，也就是远程服务器端口修改成其他的了，那就要得加上 -p +端口。</p><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>进入远程服务器需要SSH登录的用户的目录下，这里仍然用root用户，cd /root/.ssh，执行ls看看目录下是否有authorized_keys文件没有的话则执行以下命令创建：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">touch authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180114213737113?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>执行成功会创建空authorized_keys文件，授予600权限（注意：此处权限必须是600）：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">chmod 600 /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180114213721453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>如果已经有了authorized_keys文件，这直接执行以下的密钥追加工作。</p><p>将上面生成的公钥id_rsa.pub追加到authorized_keys文件中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>如下图所示，注意图中红色箭头处，是&gt;&gt;而不是&gt;，双尖括号&gt;&gt;表示像向文件中追加：</p><p><img src="https://img-blog.csdn.net/20180114213701202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>单尖括号&gt;表示将文件内容全部替换掉；也就是说使用单尖括号&gt;，authorized_keys文件里面如果原来有内容的话就全部不在了。<br><img src="https://img-blog.csdn.net/20180114214144208?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>密钥准备好了接下来就可以使用密钥登录了，</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ssh -i ./id_rsa root@192.168.100.39</span><br><span class="line"></span><br><span class="line">或者ssh root@192.168.100.39 -i ./id_rsa</span><br></pre></td></tr></table></figure><p>注意：id_rsa是私钥，笔者这里是进入私钥的目录下操作的，如果没在私钥的目录下，请写全目录，比如/mnt/id_rsa，也可以是您自定义的目录。执行命令过程中，如果创建密钥对的时候设置了密码，则会提示您输入密码，没有的话会直接登录。</p><p><img src="https://img-blog.csdn.net/20180114214831455?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>在Windows系统上使用密钥的话要看您使用的工具是否支持密钥登录， 笔者这里使用Xshell 5 演示，</p><p><img src="https://img-blog.csdn.net/20180114215437372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmFoYW5jeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>在输入密码处选择Public key，可以在浏览处添加密钥，这里添加的是私钥id_rsa,如果创建密钥对的时候设置密码了，需要在下方的密码框中输入密码，没有密码直接确定登录。</p><h2 id="小贴士：ssh-keygen可用的参数选项有："><a href="#小贴士：ssh-keygen可用的参数选项有：" class="headerlink" title="小贴士：ssh-keygen可用的参数选项有："></a>小贴士：ssh-keygen可用的参数选项有：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ssh-keygen可用的参数选项有：</span><br><span class="line"></span><br><span class="line">     -a trials</span><br><span class="line">             在使用 -T 对 DH-GEX 候选素数进行安全筛选时需要执行的基本测试数量。</span><br><span class="line"></span><br><span class="line">     -B      显示指定的公钥/私钥文件的 bubblebabble 摘要。</span><br><span class="line"></span><br><span class="line">     -b bits</span><br><span class="line">             指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</span><br><span class="line"></span><br><span class="line">     -C comment  提供一个新注释</span><br><span class="line"></span><br><span class="line">     -c      要求修改私钥和公钥文件中的注释。本选项只支持 RSA1 密钥。</span><br><span class="line">             程序将提示输入私钥文件名、密语(如果存在)、新注释。</span><br><span class="line"></span><br><span class="line">     -D reader 下载存储在智能卡 reader 里的 RSA 公钥。</span><br><span class="line"></span><br><span class="line">     -e      读取OpenSSH的私钥或公钥文件，并以 RFC 4716 SSH 公钥文件格式在 stdout 上显示出来。</span><br><span class="line">             该选项能够为多种商业版本的 SSH 输出密钥。</span><br><span class="line"></span><br><span class="line">     -F hostname 在 known_hosts 文件中搜索指定的 hostname ，并列出所有的匹配项。 这个选项主要用于查找散列过的主机名/ip地址，还可以和 -H 选项联用打印找到的公钥的散列值。</span><br><span class="line"></span><br><span class="line">     -f filename 指定密钥文件名。</span><br><span class="line"></span><br><span class="line">     -G output_file  为 DH-GEX 产生候选素数。这些素数必须在使用之前使用 -T 选项进行安全筛选。</span><br><span class="line"></span><br><span class="line">     -g      在使用 -r 打印指纹资源记录的时候使用通用的 DNS 格式。</span><br><span class="line"></span><br><span class="line">     -H      对 known_hosts 文件进行散列计算。这将把文件中的所有主机名/ip地址替换为相应的散列值。</span><br><span class="line">原来文件的内容将会添加一个&quot;.old&quot;后缀后保存。这些散列值只能被 ssh 和 sshd 使用。这个选项不会修改已经经过散列的主机名/ip地址，因此可以在部分公钥已经散列过的文件上安全使用。</span><br><span class="line"></span><br><span class="line">     -i      读取未加密的SSH-2兼容的私钥/公钥文件，然后在 stdout 显示OpenSSH兼容的私钥/公钥。该选项主要用于从多种商业版本的SSH中导入密钥。</span><br><span class="line"></span><br><span class="line">     -l      显示公钥文件的指纹数据。它也支持 RSA1 的私钥。 对于RSA和DSA密钥，将会寻找对应的公钥文件，然后显示其指纹数据。</span><br><span class="line"></span><br><span class="line">     -M memory 指定在生成 DH-GEXS 候选素数的时候最大内存用量(MB)。</span><br><span class="line"></span><br><span class="line">     -N new_passphrase  提供一个新的密语。</span><br><span class="line"></span><br><span class="line">     -P passphrase 提供(旧)密语。</span><br><span class="line"></span><br><span class="line">     -p      要求改变某私钥文件的密语而不重建私钥。程序将提示输入私钥文件名、原来的密语、以及两次输入新密语。</span><br><span class="line"></span><br><span class="line">     -q      安静模式。用于在 /etc/rc 中创建新密钥的时候。</span><br><span class="line"></span><br><span class="line">     -R hostname 从 known_hosts 文件中删除所有属于 hostname 的密钥。 这个选项主要用于删除经过散列的主机(参见 -H 选项)的密钥。</span><br><span class="line"></span><br><span class="line">     -r hostname 打印名为 hostname 的公钥文件的 SSHFP 指纹资源记录。</span><br><span class="line"></span><br><span class="line">     -S start 指定在生成 DH-GEX 候选模数时的起始点(16进制)。</span><br><span class="line"></span><br><span class="line">     -T output_file 测试 Diffie-Hellman group exchange 候选素数(由 -G 选项生成)的安全性。</span><br><span class="line"></span><br><span class="line">     -t type 指定要创建的密钥类型。可以使用：&quot;rsa1&quot;(SSH-1) &quot;rsa&quot;(SSH-2) &quot;dsa&quot;(SSH-2)</span><br><span class="line"></span><br><span class="line">     -U reader 把现存的RSA私钥上传到智能卡 reader</span><br><span class="line"></span><br><span class="line">     -v      详细模式。ssh-keygen 将会输出处理过程的详细调试信息。常用于调试模数的产生过程。</span><br><span class="line">             重复使用多个 -v 选项将会增加信息的详细程度(最大3次)。</span><br><span class="line"></span><br><span class="line">     -W generator 指定在为 DH-GEX 测试候选模数时想要使用的 generator</span><br><span class="line"></span><br><span class="line">     -y      读取OpenSSH专有格式的公钥文件，并将OpenSSH公钥显示在 stdout 上。</span><br><span class="line">ssh-copy-id的参数有：</span><br><span class="line"></span><br><span class="line">    -i #指定密钥文件</span><br><span class="line"></span><br><span class="line">    -p #指定端口，默认端口号是22</span><br><span class="line"></span><br><span class="line">    -o <span class="tag">&lt;<span class="name">ssh</span> <span class="attr">-o</span> <span class="attr">options</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    user@]hostname #用户名@主机名</span><br><span class="line"></span><br><span class="line">    -f: force mode -- copy keys without trying to check if they are already installed</span><br><span class="line"></span><br><span class="line">    -n: dry run    -- no keys are actually copied</span><br><span class="line"></span><br><span class="line">    -h|-?: 显示帮助</span><br></pre></td></tr></table></figure><h1 id="centOS服务器添加电脑ssh-key以支持远程登陆"><a href="#centOS服务器添加电脑ssh-key以支持远程登陆" class="headerlink" title="centOS服务器添加电脑ssh key以支持远程登陆"></a><a href="https://www.cnblogs.com/zhangnan35/p/11145921.html">centOS服务器添加电脑ssh key以支持远程登陆</a></h1><p>1，生成电脑的密钥对（在powershell或cmd命令行中）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#96;&#96;&quot;自己的邮箱&quot;</span><br></pre></td></tr></table></figure><p>2.打开刚刚生成的电脑公钥（<del>即代表用户主目录，/则代表根目录。比如我本地windows电脑中，/表示c盘，而</del>表示c盘中的user/adol/这个路径）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub </span><br></pre></td></tr></table></figure><p>3.先用密码登录centOS服务器,登入后直接打开授权文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;root&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>4.将刚刚在本地电脑生成的公钥复制粘贴进去，并保存退出。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编辑模式: i</span><br><span class="line">退出编辑: esc</span><br><span class="line">保存: :w</span><br><span class="line">退出: :q</span><br><span class="line">保存并退出: :wq</span><br></pre></td></tr></table></figure><p>5.返回powershell，输入ssh root@xxx,其中xxx表示自己的公网ip地址，即可登录。</p><h1 id="linux权限问题"><a href="#linux权限问题" class="headerlink" title="linux权限问题"></a>linux权限问题</h1><p>在linux下执行sh文件时提示下面信息：<br>-bash: ./xx.sh: Permission denied<br>解决：<br>chmod 777 xx.sh</p><p>Linux chmod +755和chmod +777 各是什么意思呢？</p><p>755 代表用户对该文件拥有读，写，执行的权限，同组其他人员拥有执行和读的权限，没有写的权限，其他用户的权限和同组人员权限一样。<br>777代表，user,group ,others ,都有读写和可执行权限。</p><p>在linux终端先输入ls -al,可以看到如:<br>  -rwx-r–r– (一共10个参数)<br>第一个跟参数跟chmod无关,先不管.<br>2-4参数:属于user<br>5-7参数:属于group<br>8-10参数:属于others<br>接下来就简单了:r==&gt;可读 w==&gt;可写 x==&gt;可执行<br>        r=4   w=2   x=1<br>所以755代表 rwxr-xr-x</p>]]></content>
    
    <summary type="html">
    
      Linux下生成ssh密钥以及配置远程登陆
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="SSH" scheme="http://yoursite.com/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>linux配置mysql</title>
    <link href="http://yoursite.com/2020/12/04/linux%E9%85%8D%E7%BD%AEmysql/"/>
    <id>http://yoursite.com/2020/12/04/linux%E9%85%8D%E7%BD%AEmysql/</id>
    <published>2020-12-04T12:34:00.000Z</published>
    <updated>2020-12-04T12:34:42.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux卸载mysql（完全卸载）"><a href="#linux卸载mysql（完全卸载）" class="headerlink" title="linux卸载mysql（完全卸载）"></a>linux卸载mysql（完全卸载）</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//rpm包安装方式卸载</span><br><span class="line">查包名：rpm -qa|grep -i mysql</span><br><span class="line">删除命令：rpm -e –nodeps 包名</span><br><span class="line"></span><br><span class="line">//yum安装方式下载</span><br><span class="line">1.查看已安装的mysql</span><br><span class="line">命令：rpm -qa | grep -i mysql</span><br><span class="line">2.卸载mysql</span><br><span class="line">命令：yum remove mysql-community-server-5.6.36-2.el7.x86<span class="emphasis">_64</span></span><br><span class="line"><span class="emphasis">查看mysql的其它依赖：rpm -qa | grep -i mysql</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">//卸载依赖</span></span><br><span class="line"><span class="emphasis">yum remove mysql-libs</span></span><br><span class="line"><span class="emphasis">yum remove mysql-server</span></span><br><span class="line"><span class="emphasis">yum remove perl-DBD-MySQL</span></span><br><span class="line"><span class="emphasis">yum remove mysql</span></span><br></pre></td></tr></table></figure><h1 id="linux安装mysql"><a href="#linux安装mysql" class="headerlink" title="linux安装mysql"></a>linux安装mysql</h1><p><strong>1、查看系统版本</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@test107vm14 rpm-gpg]# lsb_release -a</span><br><span class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release 7.3.1611 (Core) </span><br><span class="line">Release:    7.3.1611</span><br><span class="line">Codename:   Core</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><p><strong>2、下载mysql安装包</strong></p><p>下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a><br>选择想要下载的mysql版本和对应的系统版本<br><img src="https://img-blog.csdn.net/20180822183850434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eTk4Nzg3MjY3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180822183945885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eTk4Nzg3MjY3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>下载MySQL-5.6.41-1.el7.x86_64.rpm-bundle.tar，我下载的mysql5.6版本，下载新版本类似，找到对应的rpm-bundle.tar安装包下载即可！<br><img src="https://img-blog.csdn.net/20180822184037200?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eTk4Nzg3MjY3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>3、检查是否已经存在mysql，若存在卸载，避免安装时产生一些错误！</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br></pre></td></tr></table></figure><p>若存在，使用rpm -e packname –nodeps命令删除安装包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">which mysql</span><br></pre></td></tr></table></figure><p>查看mysql配置信息，删除对应的配置文件等信息！</p><p>删除mysql用户</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel mysql</span><br></pre></td></tr></table></figure><p><strong>4、上传安装包</strong></p><p>将下载的安装包上传到相应的目录，我上传至/usr/local/mysql 目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;mysql1</span><br></pre></td></tr></table></figure><p>上传安装包</p><p><strong>5、解压缩安装包</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf MySQL-5.6.41-1.el7.x86_64.rpm-bundle.tar1</span><br></pre></td></tr></table></figure><p>解压后，得到如下文件<br><img src="https://img-blog.csdn.net/20180822185330984?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eTk4Nzg3MjY3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><strong>6、创建mysql用户和组</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd -g 1000 mysql</span><br><span class="line">useradd mysql -g mysql -p mysql</span><br></pre></td></tr></table></figure><p><strong>7、安装mysql</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-server-5.6.41-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>提示错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conflicts with file from package mariadb-libs-1:5.5.56-2.el7.x86_641</span><br></pre></td></tr></table></figure><p>与mariadb冲突，删除mariadb即可！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e mariadb-libs-1:5.5.56-2.el7.x86_64 --nodeps1</span><br></pre></td></tr></table></figure><p>然后重新执行上面的安装命令！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-client-5.6.41-1.el7.x86_64.rpm1</span><br><span class="line">rpm -ivh MySQL-devel-5.6.41-1.el7.x86_64.rpm1</span><br><span class="line">rpm -ivh MySQL-shared-5.6.41-1.el7.x86_64.rpm1</span><br></pre></td></tr></table></figure><p>安装这四个即可，至此安装完成！</p><p><strong>8、启动mysql</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysql start1</span><br></pre></td></tr></table></figure><p>启动成功后，可查看是否成功监听3306端口</p><p><strong>9、使用随机密码登录mysql</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name .mysql_secret1</span><br></pre></td></tr></table></figure><p>查找生成的随机密码路径，查看此文件，获取随机密码</p><p><img src="https://img-blog.csdn.net/20180822190602213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p4eTk4Nzg3MjY3NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>使用随机默认密码登录mysql</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p1</span><br></pre></td></tr></table></figure><p><strong>10、修改密码</strong></p><p>登陆成功后，修改密码，否则无法选择数据库进行操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET PASSWORD&#x3D;password(&#39;password&#39;);1</span><br><span class="line">FLUSH PRIVILEGES;1</span><br></pre></td></tr></table></figure><p>至此，便可以进行mysql操作了；</p><h1 id="Centos7-安装MySQL-5-7"><a href="#Centos7-安装MySQL-5-7" class="headerlink" title="Centos7 安装MySQL 5.7"></a><a href="https://www.cnblogs.com/zsh-blogs/p/11497720.html">Centos7 安装MySQL 5.7</a></h1><p>在CentOS中默认安装有MariaDB，这个是MySQL的分支，但为了需要，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。</p><h3 id="1-下载并安装MySQL官方的-Yum-Repository"><a href="#1-下载并安装MySQL官方的-Yum-Repository" class="headerlink" title="1 下载并安装MySQL官方的 Yum Repository"></a>1 下载并安装MySQL官方的 Yum Repository</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -i -c http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p>使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br></pre></td></tr></table></figure><p>之后就开始安装MySQL服务器。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><p>这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb。</p><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910152003346-124172716.png" alt="img"></p><p>至此MySQL就安装完成了，然后是对MySQL的一些设置。</p><h3 id="2-MySQL数据库设置"><a href="#2-MySQL数据库设置" class="headerlink" title="2 MySQL数据库设置"></a>2 MySQL数据库设置</h3><p> 首先启动MySQL</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start  mysqld.service</span><br></pre></td></tr></table></figure><p>查看MySQL运行状态，运行状态如图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910152057991-1891324736.png" alt="img"></p><p> 此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910152125152-1298938276.png" alt="img"></p><p>如下命令进入数据库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>输入初始密码（是上面图片最后面的 no;e!5&gt;&gt;alfg），此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;</span><br></pre></td></tr></table></figure><p>其中‘new password’替换成你要设置的密码，注意:密码设置必须要大小写字母数字和特殊符号（,/‘;:等）,不然不能配置成功</p><p>如果要修改为root这样的弱密码，需要进行以下配置：</p><p>查看密码策略</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%password%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910152304822-756480013.png" alt="img"></p><p> 修改密码策略<br>vi /etc/my.cnf<br>添加validate_password_policy配置</p><p>选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加validate_password_policy配置</span><br><span class="line">validate_password_policy&#x3D;0</span><br><span class="line">#关闭密码策略</span><br><span class="line">validate_password &#x3D; off</span><br></pre></td></tr></table></figure><p>重启mysql服务使配置生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>然后就可以修改为弱密码啦</p><h1 id="CentOS7使用yum安装MySQL8-0"><a href="#CentOS7使用yum安装MySQL8-0" class="headerlink" title="CentOS7使用yum安装MySQL8.0"></a>CentOS7使用yum安装MySQL8.0</h1><p>1、yum仓库下载MySQL：sudo yum localinstall <a href="https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm">https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</a></p><p>2、yum安装MySQL：sudo yum install mysql-community-server</p><p>3、启动MySQL服务：sudo service mysqld start</p><p>4、检查MySQL服务状态：sudo service mysqld status</p><p>5、查看初始密码（如无内容直接跳过）：sudo grep ‘temporary password’ /var/log/mysqld.log</p><p>6、本地MySQL客户端登录：mysql -uroot -p</p><p>7、输入密码为第5步查出的，如果没有，直接回车，然后输入命令 flush privileges</p><p>8、修改root登录密码：ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘密码’;（注意要切换到mysql数据库，使用use mysql）</p><p>注意：开始遇到问题是不输入密码或输错密码都能连接MySQL server，后来在修改允许阿里CentOS7允许远程操作MySQL数据库时，</p><p>才发现需要去调整 /etc/my.cnf文件，注释掉skip-grant-tables，重启MySQL服务（sudo service mysqld restart），quit退出连接，重新连接就需要输入密码了</p><p>后期如果忘记密码，可以通过skip-grant-tables配置跳过输入密码登录MySQL，执行7、8步进行修改，如果‘root’@’localhost’变为‘root’@’%’，那么alter语句中的也要修改</p><p>9、配置MySQL允许外部访问：1）首先设置阿里云安全组规则入方向，支持MySQL端口3306可访问（协议类型下拉菜单中有MySQL端口）</p><p>　　　　　　　　　　　　　　2）服务端登录MySQL，use mysql;然后执行select user,host from user可查看用户及对应允许访问主机</p><p>　　　　　　　　　　　　　　　　然后执行update user set host = ‘%’ where user =’root’;允许任何外部可访问；再执行上一步查看命令，可比较结果</p><h3 id="3-mysql开启远程访问权限的设置"><a href="#3-mysql开启远程访问权限的设置" class="headerlink" title="3. mysql开启远程访问权限的设置"></a>3. mysql开启远程访问权限的设置</h3><p><strong>MySql-Server 出于安全方面考虑默认只允许本机(localhost, 127.0.0.1)来连接访问.</strong></p><p>所以必须给root修改可以远程访问的权限</p><p><strong>1.在连接服务器后,操作mysql系统数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令为： mysql -u root -p</span><br><span class="line"></span><br><span class="line">root:表示用户名</span><br><span class="line"></span><br><span class="line">use mysql；</span><br></pre></td></tr></table></figure><p><strong>2.查询用户列表</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">User</span>,authentication_string,Host <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>3.新增用户及其权限</strong></p><ol><li><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@’%’ IDENTIFIED BY ‘123456’  </p><p>这里的123456为你给新增权限用户设置的密码，%代表所有主机，也可以具体到你的主机ip地址</p></li><li><p>flush privileges;     </p><p>这一步一定要做，不然无法成功！ 这句表示从mysql数据库的grant表中重新加载权限数据</p><p>因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。</p></li></ol><p><strong>4.删除用户及其权限</strong></p><p>delete from user where Host=’%’;</p><h3 id="4-为firewalld添加开放端口"><a href="#4-为firewalld添加开放端口" class="headerlink" title="4 为firewalld添加开放端口"></a>4 为firewalld添加开放端口</h3><p>添加mysql端口3306</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure><p>如果提示 : <a href>FirewallD is not running</a> 查看 <strong>centos出现“FirewallD is not running”怎么办</strong></p><p>然后再重新载入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910152800260-2144918960.png" alt="img"></p><h3 id="5-修改mysql的字符编码（不修改会产生中文乱码问题）"><a href="#5-修改mysql的字符编码（不修改会产生中文乱码问题）" class="headerlink" title="5 修改mysql的字符编码（不修改会产生中文乱码问题）"></a>5 修改mysql的字符编码（不修改会产生中文乱码问题）</h3><p>显示原来编码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%character%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910152946939-1117644087.png" alt="img"></p><p>修改/etc/my.cnf</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br></pre></td></tr></table></figure><p>重启数据库</p><p><img src="https://img2018.cnblogs.com/blog/1201066/201909/1201066-20190910153030577-1953443392.png" alt="img"></p><h1 id="mysql忘记密码"><a href="#mysql忘记密码" class="headerlink" title="mysql忘记密码:"></a>mysql忘记密码:</h1><p><strong>1. 检查<code>mysql</code>服务是否启动，如果启动，关闭<code>mysql</code>服务</strong></p><p>运行命令：<code>ps -ef | grep -i mysql</code></p><p><img src="https://img2018.cnblogs.com/blog/1411470/201909/1411470-20190929173649786-1102739601.png" alt="img"></p><p> 如果开着就运行关闭的命令：service mysqld stop</p><p><img src="https://img2018.cnblogs.com/blog/1411470/201909/1411470-20190929173858703-2071558955.png" alt="img"></p><p> <strong>2.修改mysql的配置文件my.conf</strong></p><p>一般在/etc目录下，运行命令：vi /etc/my.cnf，编辑文件</p><p><img src="https://img2018.cnblogs.com/blog/1411470/201909/1411470-20190930100829664-491241917.png" alt="img"></p><p> 在文件的<code>[mysqld]标签下添加一句：skip-grant-tables</code></p><p><img src="https://img2018.cnblogs.com/blog/1411470/201909/1411470-20190930161834995-303636370.png" alt="img"></p><p>然后wq!保存退出。</p><p> <strong>3.重启数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令：service mysqld restart</span><br></pre></td></tr></table></figure><p> <strong>5.进入到mysql数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令：mysql -u root </span><br></pre></td></tr></table></figure><p> <strong>6.进入到mysql数据库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令：mysql -u root </span><br></pre></td></tr></table></figure><p> <strong>7.修改密码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行语句：use mysql;</span><br><span class="line">继续运行语句：update mysql.user set authentication_string&#x3D;password(&#39;root_password&#39;) where user&#x3D;&#39;root&#39;;    </span><br><span class="line">root_password替换成你想要的密码</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p> <strong>8.把步骤2加的东西删除掉，在重启服务器，就可以使用刚才修改的密码登录进服务器了。</strong></p><p> <code>mysql -u root -p</code></p><p>到这一步已经全部结束。</p><h1 id="You-must-reset-your-password-using-ALTER-USER-statement-before-executing-this-statement"><a href="#You-must-reset-your-password-using-ALTER-USER-statement-before-executing-this-statement" class="headerlink" title="You must reset your password using ALTER USER statement before executing this statement"></a>You must reset your password using ALTER USER statement before executing this statement</h1><p>alter user user() identified by “root”;</p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h3 id="1、设置安全选项："><a href="#1、设置安全选项：" class="headerlink" title="1、设置安全选项："></a>1、设置安全选项：</h3><p>mysql_secure_installation</p><h3 id="2、关闭MySQL"><a href="#2、关闭MySQL" class="headerlink" title="2、关闭MySQL"></a>2、关闭MySQL</h3><p>systemctl stop mysqld </p><h3 id="3、重启MySQL"><a href="#3、重启MySQL" class="headerlink" title="3、重启MySQL"></a>3、重启MySQL</h3><p>systemctl restart mysqld </p><h3 id="4、查看MySQL运行状态"><a href="#4、查看MySQL运行状态" class="headerlink" title="4、查看MySQL运行状态"></a>4、查看MySQL运行状态</h3><p>systemctl status mysqld </p><h3 id="5、设置开机启动"><a href="#5、设置开机启动" class="headerlink" title="5、设置开机启动"></a>5、设置开机启动</h3><p>systemctl enable mysqld </p><h3 id="6、关闭开机启动"><a href="#6、关闭开机启动" class="headerlink" title="6、关闭开机启动"></a>6、关闭开机启动</h3><p>systemctl disable mysqld </p><h3 id="7、配置默认编码为utf8："><a href="#7、配置默认编码为utf8：" class="headerlink" title="7、配置默认编码为utf8："></a>7、配置默认编码为utf8：</h3><p>vi /etc/my.cnf #添加 [mysqld] character_set_server=utf8 init_connect=’SET NAMES utf8’</p><p>其他默认配置文件路径： </p><p>配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid</p><h3 id="8、查看版本"><a href="#8、查看版本" class="headerlink" title="8、查看版本"></a>8、查看版本</h3><p>select version();</p><h1 id="centos出现“FirewallD-is-not-running”怎么办"><a href="#centos出现“FirewallD-is-not-running”怎么办" class="headerlink" title="centos出现“FirewallD is not running”怎么办"></a>centos出现“FirewallD is not running”怎么办</h1><p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。</p><ol><li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running，如下图所示。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=1"><img src="https://imgsa.baidu.com/exp/w=500/sign=3783b5472134349b74066e85f9eb1521/7dd98d1001e939013391d96372ec54e737d196df.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=2"><img src="https://imgsa.baidu.com/exp/w=500/sign=0c6057bedc39b6004dce0fb7d9513526/55e736d12f2eb93882fe2eafdc628535e4dd6fdf.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=3"><img src="https://imgsa.baidu.com/exp/w=500/sign=32b9322ef2f2b211e42e854efa816511/e61190ef76c6a7efec9afc7bf4faaf51f3de662a.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=4"><img src="https://imgsa.baidu.com/exp/w=500/sign=79a4d13cf11986184147ef847aec2e69/503d269759ee3d6d9f44d3964a166d224e4adee9.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>5</p><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=5"><img src="https://imgsa.baidu.com/exp/w=500/sign=ce97d76d33f33a879e6d001af65d1018/2e2eb9389b504fc2cecce458ecdde71191ef6ddf.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>6</p><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=6"><img src="https://imgsa.baidu.com/exp/w=500/sign=9a524f1e82d4b31cf03c94bbb7d7276f/42166d224f4a20a4969c689a99529822730ed0e9.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p><p>END</p></li></ol><h1 id="报错2058-：连接-mysql-8-0-11-解决方法登录你的-mysql-数据库，然后-执行这条SQL："><a href="#报错2058-：连接-mysql-8-0-11-解决方法登录你的-mysql-数据库，然后-执行这条SQL：" class="headerlink" title="报错2058 ：连接 mysql 8.0.11 解决方法登录你的 mysql 数据库，然后 执行这条SQL："></a>报错2058 ：连接 mysql 8.0.11 解决方法登录你的 mysql 数据库，然后 执行这条SQL：</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure><p>#password 是你自己设置的root密码</p><p>localhost是允许登陆的主机, 允许所有则设置为 <code>%</code></p>]]></content>
    
    <summary type="html">
    
      linux安装和配置mysql的方式和注意事项
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="mysql" scheme="http://yoursite.com/categories/linux/mysql/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>linux使用yum安装jdk</title>
    <link href="http://yoursite.com/2020/12/04/linux%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85jdk/"/>
    <id>http://yoursite.com/2020/12/04/linux%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85jdk/</id>
    <published>2020-12-04T12:30:00.000Z</published>
    <updated>2020-12-04T12:39:27.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux使用yum安装jdk"><a href="#linux使用yum安装jdk" class="headerlink" title="linux使用yum安装jdk"></a>linux使用yum安装jdk</h1><h2 id="1-看Linux系统是否有自带的jdk："><a href="#1-看Linux系统是否有自带的jdk：" class="headerlink" title="1. 看Linux系统是否有自带的jdk："></a><strong>1. 看Linux系统是否有自带的jdk：</strong></h2><p>1、输入：java -version<br>2、发现有输入：rpm -qa | grep java 检测jdk的安装包，（注意：rpm命令符没有时记得下载一个输入：apt-get install +命令名称）<br>3、接着进行一个个删除包，输入：rpm -e –nodeps +包名<br>4、最后再次：rpm -qa | grep java检查是否删除完即可</p><h2 id="2、查询要安装jdk的版本"><a href="#2、查询要安装jdk的版本" class="headerlink" title="2、查询要安装jdk的版本"></a>2、查询要安装jdk的版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：yum -y list java*</span><br></pre></td></tr></table></figure><h2 id="3、安装所需版本"><a href="#3、安装所需版本" class="headerlink" title="3、安装所需版本"></a>3、安装所需版本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：yum install -y java-1.8.0-openjdk.devel.x86_64</span><br></pre></td></tr></table></figure><div class="note info">            <p>注意这里一定要安装devel版本, 否则会出现只安装了jre的情况导致无法使用javac命令</p>          </div><h2 id="4-查看是否安装成功"><a href="#4-查看是否安装成功" class="headerlink" title="4. 查看是否安装成功"></a>4. 查看是否安装成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac, java -version</span><br></pre></td></tr></table></figure><h1 id="javac命令报错bash-javac-command-not-found-yum-provide-javac"><a href="#javac命令报错bash-javac-command-not-found-yum-provide-javac" class="headerlink" title="javac命令报错bash:javac:command not found | yum provide javac"></a>javac命令报错bash:javac:command not found | yum provide javac</h1><p><strong>问题分析</strong>：自带的jdk默认只安装了运行环境（找到jdk的安装目录下，发现只有jre文件夹，没有bin、lib等文件夹）。</p><p><strong>自查方法</strong>：</p><p>（1）先找到jdk的安装目录</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">home</span>]<span class="comment"># which java</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">home</span>]<span class="comment"># ls -lrt /usr/bin/java</span></span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> root root <span class="number">22</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> /usr/bin/java -&gt; /etc/alternatives/java</span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">home</span>]<span class="comment"># ls -lrt /etc/alternatives/java</span></span><br><span class="line">lrwxrwxrwx. <span class="number">1</span> root root <span class="number">73</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> /etc/alternatives/java -&gt; /usr/lib/jvm/java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-1</span>.<span class="number">8.0</span>.<span class="number">242</span>.b08<span class="literal">-0</span>.el7_7.x86_64/jre/bin/java12345</span><br></pre></td></tr></table></figure><p>这就是jdk安装的文件夹：/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64</p><p>（2）打开这个文件夹，检查它的子文件夹。如果只有jre一个文件夹，那就是需要安装devel开发环境。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">home</span>]<span class="comment"># cd /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">java</span>-<span class="number">1.8</span><span class="type">.0</span>-<span class="type">openjdk</span>-<span class="number">1.8</span><span class="type">.0.242.b08</span>-<span class="number">0</span><span class="type">.el7_7.x86_64</span>]<span class="comment"># ll</span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">drwxr<span class="literal">-xr</span><span class="literal">-x</span>. <span class="number">4</span> root root   <span class="number">28</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> jre123</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：使用yum安装开发环境 devel。（注意下载对应的版本。所以最好用yum找到准确的devel版本名字，精准下载）</p><hr><p><strong>0</strong>. 检查自己的openjdk版本，发现是1.8.0<br>（如果没有安装openjdk,则用yum安装openjdk之后，再来安装一次devel即可）<br>【参考教程<a href="https://www.cnblogs.com/yaun1498078591/p/10368884.html">linux 上使用yum 安装openjdk1.8</a>】</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># java -version</span></span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_242&quot;</span></span><br><span class="line">OpenJDK Runtime Environment (build <span class="number">1.8</span>.<span class="number">0</span>_242<span class="literal">-b08</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM (build <span class="number">25.242</span><span class="literal">-b08</span>, mixed mode)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p><strong>1</strong>. 用yum查找可以安装的jdk：yum search java|grep jdk</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">java</span>-<span class="number">1.8</span><span class="type">.0</span>-<span class="type">openjdk</span>-<span class="number">1.8</span><span class="type">.0.102</span>-<span class="number">4</span><span class="type">.b14.el7.x86_64</span>]<span class="comment"># yum search java|grep jdk</span></span><br><span class="line">openjdk.x86_64 : OpenJDK Runtime Environment</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span>.i686 : OpenJDK Runtime Environment <span class="number">8</span></span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-accessibility</span>.i686 : OpenJDK accessibility connector</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-accessibility</span>.x86_64 : OpenJDK accessibility connector</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-accessibility</span><span class="literal">-debug</span>.i686 : OpenJDK <span class="number">8</span> accessibility connector</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-accessibility</span><span class="literal">-debug</span>.x86_64 : OpenJDK <span class="number">8</span> accessibility</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-debug</span>.i686 : OpenJDK Runtime Environment <span class="number">8</span> with full debug on</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-debug</span>.x86_64 : OpenJDK Runtime Environment <span class="number">8</span> with full debug</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-demo</span>.i686 : OpenJDK Demos <span class="number">8</span></span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-demo</span>.x86_64 : OpenJDK Demos <span class="number">8</span></span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-demo</span><span class="literal">-debug</span>.i686 : OpenJDK Demos <span class="number">8</span> with full debug on</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-demo</span><span class="literal">-debug</span>.x86_64 : OpenJDK Demos <span class="number">8</span> with full debug on</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-devel</span>.i686 : OpenJDK Development Environment <span class="number">8</span></span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-devel</span>.x86_64 : OpenJDK Development Environment <span class="number">8</span></span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-devel</span><span class="literal">-debug</span>.i686 : OpenJDK Development Environment <span class="number">8</span> with</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-devel</span><span class="literal">-debug</span>.x86_64 : OpenJDK Development Environment <span class="number">8</span> with</span><br><span class="line">java<span class="literal">-1</span>.<span class="number">8.0</span><span class="literal">-openjdk</span><span class="literal">-headless</span>.x86_64 : OpenJDK Runtime Environment1234567891011121314151617</span><br></pre></td></tr></table></figure><p>（有很多很多文件，这里删减了一部分）<br>找到了我需要的版本：java-1.8.0-openjdk-devel.x86_64。</p><p><strong>2</strong>. 安装java-1.8.0-openjdk-devel.x86_64：<br>yum install java-1.8.0-openjdk-devel.x86_64</p><p>这时候会有提示：Is this ok [y/d/N]:<br>输入y （y的意思是-下载并安装）。</p><p>然后静待下载…complete!</p><p>3.检查jdk目录下是否有了bin、lib等文件夹：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">home</span>]<span class="comment"># cd /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-0.el7_7.x86_64</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">java</span>-<span class="number">1.8</span><span class="type">.0</span>-<span class="type">openjdk</span>-<span class="number">1.8</span><span class="type">.0.242.b08</span>-<span class="number">0</span><span class="type">.el7_7.x86_64</span>]<span class="comment"># ll</span></span><br><span class="line">total <span class="number">4</span></span><br><span class="line">drwxr<span class="literal">-xr</span><span class="literal">-x</span>. <span class="number">2</span> root root <span class="number">4096</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> bin</span><br><span class="line">drwxr<span class="literal">-xr</span><span class="literal">-x</span>. <span class="number">3</span> root root  <span class="number">132</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> include</span><br><span class="line">drwxr<span class="literal">-xr</span><span class="literal">-x</span>. <span class="number">4</span> root root   <span class="number">28</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> jre</span><br><span class="line">drwxr<span class="literal">-xr</span><span class="literal">-x</span>. <span class="number">3</span> root root  <span class="number">144</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> lib</span><br><span class="line">drwxr<span class="literal">-xr</span><span class="literal">-x</span>. <span class="number">2</span> root root  <span class="number">204</span> Apr <span class="number">18</span> <span class="number">13</span>:<span class="number">09</span> tapset</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>有了！<br>再次输入javac，没有报错：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">jvm</span>]<span class="comment"># javac</span></span><br><span class="line">Usage: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line"><span class="built_in">where</span> possible options include:</span><br><span class="line">  <span class="literal">-g</span>                         Generate all debugging info</span><br><span class="line">  <span class="literal">-g</span>:none                    Generate no debugging info</span><br><span class="line">  <span class="literal">-g</span>:&#123;lines,vars,source&#125;     Generate only some debugging info</span><br><span class="line">  <span class="literal">-nowarn</span>                    Generate no warnings</span><br><span class="line">  <span class="literal">-verbose</span>                   Output messages about what the compiler is doing</span><br><span class="line">  <span class="literal">-deprecation</span>               Output source locations <span class="built_in">where</span> deprecated APIs are used</span><br><span class="line">  <span class="literal">-classpath</span> &lt;path&gt;          Specify <span class="built_in">where</span> to find user <span class="class"><span class="keyword">class</span> <span class="title">files</span> <span class="title">and</span> <span class="title">annotation</span> <span class="title">processors</span></span></span><br><span class="line"><span class="class">  -<span class="title">cp</span> &lt;<span class="title">path</span>&gt;                 <span class="title">Specify</span> <span class="title">where</span> <span class="title">to</span> <span class="title">find</span> <span class="title">user</span> <span class="title">class</span> <span class="title">files</span> <span class="title">and</span> <span class="title">annotation</span> <span class="title">processors</span></span></span><br><span class="line"><span class="class">  -<span class="title">sourcepath</span> &lt;<span class="title">path</span>&gt;         <span class="title">Specify</span> <span class="title">where</span> <span class="title">to</span> <span class="title">find</span> <span class="title">input</span> <span class="title">source</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">bootclasspath</span> &lt;<span class="title">path</span>&gt;      <span class="title">Override</span> <span class="title">location</span> <span class="title">of</span> <span class="title">bootstrap</span> <span class="title">class</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">extdirs</span> &lt;<span class="title">dirs</span>&gt;            <span class="title">Override</span> <span class="title">location</span> <span class="title">of</span> <span class="title">installed</span> <span class="title">extensions</span></span></span><br><span class="line"><span class="class">  -<span class="title">endorseddirs</span> &lt;<span class="title">dirs</span>&gt;       <span class="title">Override</span> <span class="title">location</span> <span class="title">of</span> <span class="title">endorsed</span> <span class="title">standards</span> <span class="title">path</span></span></span><br><span class="line"><span class="class">  -<span class="title">proc</span>:</span>&#123;none,only&#125;          Control whether annotation processing and/or compilation is done.</span><br><span class="line">  <span class="literal">-processor</span> &lt;class1&gt;[,&lt;<span class="type">class2</span>&gt;,&lt;<span class="type">class3</span>&gt;<span class="type">...</span>] Names of the annotation processors to run; bypasses default discovery <span class="keyword">process</span></span><br><span class="line">  <span class="literal">-processorpath</span> &lt;path&gt;      Specify <span class="built_in">where</span> to find annotation processors</span><br><span class="line">  <span class="literal">-parameters</span>                Generate metadata <span class="keyword">for</span> reflection on method parameters</span><br><span class="line">  <span class="literal">-d</span> &lt;directory&gt;             Specify <span class="built_in">where</span> to place generated <span class="class"><span class="keyword">class</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">s</span> &lt;<span class="title">directory</span>&gt;             <span class="title">Specify</span> <span class="title">where</span> <span class="title">to</span> <span class="title">place</span> <span class="title">generated</span> <span class="title">source</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">h</span> &lt;<span class="title">directory</span>&gt;             <span class="title">Specify</span> <span class="title">where</span> <span class="title">to</span> <span class="title">place</span> <span class="title">generated</span> <span class="title">native</span> <span class="title">header</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">implicit</span>:</span>&#123;none,<span class="class"><span class="keyword">class</span>&#125;     <span class="title">Specify</span> <span class="title">whether</span> <span class="title">or</span> <span class="title">not</span> <span class="title">to</span> <span class="title">generate</span> <span class="title">class</span> <span class="title">files</span> <span class="title">for</span> <span class="title">implicitly</span> <span class="title">referenced</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">encoding</span> &lt;<span class="title">encoding</span>&gt;       <span class="title">Specify</span> <span class="title">character</span> <span class="title">encoding</span> <span class="title">used</span> <span class="title">by</span> <span class="title">source</span> <span class="title">files</span></span></span><br><span class="line"><span class="class">  -<span class="title">source</span> &lt;<span class="title">release</span>&gt;          <span class="title">Provide</span> <span class="title">source</span> <span class="title">compatibility</span> <span class="title">with</span> <span class="title">specified</span> <span class="title">release</span></span></span><br><span class="line"><span class="class">  -<span class="title">target</span> &lt;<span class="title">release</span>&gt;          <span class="title">Generate</span> <span class="title">class</span> <span class="title">files</span> <span class="title">for</span> <span class="title">specific</span> <span class="title">VM</span> <span class="title">version</span></span></span><br><span class="line"><span class="class">  -<span class="title">profile</span> &lt;<span class="title">profile</span>&gt;         <span class="title">Check</span> <span class="title">that</span> <span class="title">API</span> <span class="title">used</span> <span class="title">is</span> <span class="title">available</span> <span class="title">in</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">profile</span></span></span><br><span class="line"><span class="class">  -<span class="title">version</span>                   <span class="title">Version</span> <span class="title">information</span></span></span><br><span class="line"><span class="class">  -<span class="title">help</span>                      <span class="title">Print</span> <span class="title">a</span> <span class="title">synopsis</span> <span class="title">of</span> <span class="title">standard</span> <span class="title">options</span></span></span><br><span class="line"><span class="class">  -<span class="title">Akey</span>[=<span class="title">value</span>]              <span class="title">Options</span> <span class="title">to</span> <span class="title">pass</span> <span class="title">to</span> <span class="title">annotation</span> <span class="title">processors</span></span></span><br><span class="line"><span class="class">  -<span class="title">X</span>                         <span class="title">Print</span> <span class="title">a</span> <span class="title">synopsis</span> <span class="title">of</span> <span class="title">nonstandard</span> <span class="title">options</span></span></span><br><span class="line"><span class="class">  -<span class="title">J</span>&lt;<span class="title">flag</span>&gt;                   <span class="title">Pass</span> &lt;<span class="title">flag</span>&gt; <span class="title">directly</span> <span class="title">to</span> <span class="title">the</span> <span class="title">runtime</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">  -<span class="title">Werror</span>                    <span class="title">Terminate</span> <span class="title">compilation</span> <span class="title">if</span> <span class="title">warnings</span> <span class="title">occur</span></span></span><br><span class="line"><span class="class">  @&lt;<span class="title">filename</span>&gt;                <span class="title">Read</span> <span class="title">options</span> <span class="title">and</span> <span class="title">filenames</span> <span class="title">from</span> <span class="title">file</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      linux使用yum安装jdk的方式和注意事项
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
      <category term="jdk" scheme="http://yoursite.com/categories/linux/jdk/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 文件上传 通过Content-Type和文件头判断文件类型</title>
    <link href="http://yoursite.com/2020/08/22/SpringBoot-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%80%9A%E8%BF%87Content-Type%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/22/SpringBoot-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%80%9A%E8%BF%87Content-Type%E5%92%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-08-22T08:43:15.000Z</published>
    <updated>2020-08-22T08:52:53.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-文件上传-通过Content-Type和文件头判断文件类型"><a href="#SpringBoot-文件上传-通过Content-Type和文件头判断文件类型" class="headerlink" title="SpringBoot 文件上传 通过Content-Type和文件头判断文件类型"></a>SpringBoot 文件上传 通过Content-Type和文件头判断文件类型</h1><h2 id="关于MIME"><a href="#关于MIME" class="headerlink" title="关于MIME"></a>关于MIME</h2><p><strong>MIME</strong>的全称是Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展，尽管读起来有些拗口，但大多数人可能都知道，<br>这是HTTP协议中用来定义文档性质及格式的标准。<a href="https://tools.ietf.org/html/rfc6838">IETF RFC 6838</a>，对HTTP传输内容类型进行了全面定义。<br>而<strong>IANA</strong>(互联网号码分配机构)是负责管理所有标准MIME类型的官方机构。可以<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">在这里</a>)找到所有的标准MIME</p><p><strong>服务器通过MIME告知响应内容类型，而浏览器则通过MIME类型来确定如何处理文档；</strong><br><strong>因此为传输内容(文档、图片等)设置正确的MIME非常重要</strong>。</p><p>通常Server会在HTTP响应中设置<strong>Content-Type</strong>，如下面的响应：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: Golfe2    </span><br><span class="line">Content-Length: 233</span><br><span class="line">Content-Type: application&#x2F;html</span><br><span class="line">Date: Sun, 28 Dec 2018 02:55:19 GMT</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>这表示服务端将返回html格式的文档，而同样客户端也可以在HTTP请求中设置<strong>Content-Type</strong>以告知服务器当前所发送内容的格式。<br>如下面的请求体：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8000</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko&#x2F;20100101 Firefox&#x2F;50.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 465</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><p>这表示客户端会发送application/json格式的数据到服务端，同时应该注意到<strong>Accept</strong>请求头，这个选项用于告知服务器应该返回什么样的数据格式(由客户端接收并完成解析)。</p><p><strong>MIME的格式</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type&#x2F;subtype</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这是一个两级的分类，比较容易理解，第一级分类通常包含：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>普通文本</td></tr><tr><td>image</td><td>某种图像</td></tr><tr><td>audio</td><td>某种音频文件</td></tr><tr><td>video</td><td>某种视频文件</td></tr><tr><td>application</td><td>应用数据</td></tr><tr><td>multi-part</td><td>复合内容</td></tr></tbody></table><p>而二级类型则非常多，以下是一些常用的MIME：</p><table><thead><tr><th>MIME</th><th>描述</th></tr></thead><tbody><tr><td>audio/wav</td><td>wave音频流媒体文件</td></tr><tr><td>audio/webm</td><td>webm 音频文件格式</td></tr><tr><td>audio/ogg</td><td>ogg多媒体文件格式的音频文件</td></tr><tr><td>audio/mpeg</td><td>mpeg多媒体文件格式的音频文件</td></tr><tr><td>image/gif</td><td>gif图片</td></tr><tr><td>image/jpeg</td><td>jpeg图片</td></tr><tr><td>image/png</td><td>png图片</td></tr><tr><td>image/svg+xml</td><td>svg矢量图片</td></tr><tr><td>application/json</td><td>json格式</td></tr><tr><td>application/xml</td><td>xml格式</td></tr><tr><td>application/xhtml+xml</td><td>扩展html格式</td></tr><tr><td>application/x-www-form-urlencoded</td><td>表单url内容编码</td></tr><tr><td>application/octet-stream</td><td>二进制格式</td></tr><tr><td>application/pdf</td><td>pdf文档</td></tr><tr><td>application/atom+xml</td><td>atom订阅feed流</td></tr><tr><td>multipart/form-data</td><td>多文档格式</td></tr><tr><td>text/plain</td><td>普通文本</td></tr><tr><td>text/html</td><td>html文档</td></tr><tr><td>text/css</td><td>css文件</td></tr><tr><td>text/javascript</td><td>javascript文件</td></tr><tr><td>text/markdown</td><td>markdown文档</td></tr><tr><td>video/mpeg</td><td>mpeg多媒体视频文件</td></tr><tr><td>video/quicktime</td><td>mov多媒体视频文件</td></tr></tbody></table><h4 id="MIME-Type-与-Content-Type-的关系"><a href="#MIME-Type-与-Content-Type-的关系" class="headerlink" title="MIME Type 与 Content-Type 的关系"></a>MIME Type 与 Content-Type 的关系</h4><p>首先看看tomcat服务器中默认的web.xml中的描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Default MIME Type Mappings &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; --&gt;</span><br><span class="line">&lt;!-- When serving static resources, Tomcat will automatically generate    --&gt;</span><br><span class="line">&lt;!-- a &quot;Content-Type&quot; header based on the resource&#39;s filename extension, --&gt;</span><br><span class="line">&lt;!-- based on these mappings. Additional mappings can be added here (to --&gt;</span><br><span class="line">&lt;!-- apply to all web applications), or in your own application&#39;s web.xml --&gt;</span><br><span class="line">&lt;!-- deployment descriptor.   --&gt;</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p>再看看apache服务器中mime.types的描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This file controls what Internet media types are sent to the client for</span><br><span class="line">given file extension(s). Sending the correct media type to the client</span><br><span class="line">is important so they know how to handle the content of the file.</span><br><span class="line">Extra types can either be added here or by using an AddType directive</span><br><span class="line">in your config files. For more information about Internet media types,</span><br><span class="line">please read RFC 2045, 2046, 2047, 2048, and 2077. The Internet media type registry is at http:&#x2F;&#x2F;www.iana.org&#x2F;assignments&#x2F;media-types&#x2F;.</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><strong>当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中找到对应的MIME Type，再根据MIME Type设置HTTP Response的Content-Type，然后浏览器根据Content-Type的值处理文件。</strong></p><p>也就是说, <strong>文件扩展名=&gt;MIME Type=&gt;Content-Type</strong></p><h2 id="通过文件头识别文件"><a href="#通过文件头识别文件" class="headerlink" title="通过文件头识别文件"></a>通过文件头识别文件</h2><p>不同的文件类型有不同的文件头, 而文件头部的几个字节被称为Magic Number, 通常用十六进制表示, 可用来判断文件类型.</p><p>比如png文件的文件头Magic Number是0x89504E开始的, java class文件Magic Number为Oxcafebabe</p><p>我们可以通过判断文件的文件头信息来判断文件的类型, 而且<strong>即使改变文件扩展名文件头信息也是不改变的</strong>.</p><p>通过java代码判断文件类型:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认判断文件头前三个字节内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> CHECK_BYTES_NUMBER = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, String&gt; FILE_TYPE_MAP = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileType</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        getAllFileType(); <span class="comment">//初始化文件类型信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Discription:[getAllFileType,常见文件头信息]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFileType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;ffd8ffe000104a464946&quot;</span>, <span class="string">&quot;jpg&quot;</span>); <span class="comment">//JPEG (jpg)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;89504e470d0a1a0a0000&quot;</span>, <span class="string">&quot;png&quot;</span>); <span class="comment">//PNG (png)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;47494638396126026f01&quot;</span>, <span class="string">&quot;gif&quot;</span>); <span class="comment">//GIF (gif)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;49492a00227105008037&quot;</span>, <span class="string">&quot;tif&quot;</span>); <span class="comment">//TIFF (tif)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;424d228c010000000000&quot;</span>, <span class="string">&quot;bmp&quot;</span>); <span class="comment">//16色位图(bmp)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;424d8240090000000000&quot;</span>, <span class="string">&quot;bmp&quot;</span>); <span class="comment">//24位位图(bmp)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;424d8e1b030000000000&quot;</span>, <span class="string">&quot;bmp&quot;</span>); <span class="comment">//256色位图(bmp)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;41433130313500000000&quot;</span>, <span class="string">&quot;dwg&quot;</span>); <span class="comment">//CAD (dwg)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;3c21444f435459504520&quot;</span>, <span class="string">&quot;html&quot;</span>); <span class="comment">//HTML (html)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;3c21646f637479706520&quot;</span>, <span class="string">&quot;htm&quot;</span>); <span class="comment">//HTM (htm)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;48544d4c207b0d0a0942&quot;</span>, <span class="string">&quot;css&quot;</span>); <span class="comment">//css</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;696b2e71623d696b2e71&quot;</span>, <span class="string">&quot;js&quot;</span>); <span class="comment">//js</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;7b5c727466315c616e73&quot;</span>, <span class="string">&quot;rtf&quot;</span>); <span class="comment">//Rich Text Format (rtf)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;38425053000100000000&quot;</span>, <span class="string">&quot;psd&quot;</span>); <span class="comment">//Photoshop (psd)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;46726f6d3a203d3f6762&quot;</span>, <span class="string">&quot;eml&quot;</span>); <span class="comment">//Email [Outlook Express 6] (eml)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;d0cf11e0a1b11ae10000&quot;</span>, <span class="string">&quot;doc&quot;</span>); <span class="comment">//MS Excel 注意：word、msi 和 excel的文件头一样</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;d0cf11e0a1b11ae10000&quot;</span>, <span class="string">&quot;vsd&quot;</span>); <span class="comment">//Visio 绘图</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;5374616E64617264204A&quot;</span>, <span class="string">&quot;mdb&quot;</span>); <span class="comment">//MS Access (mdb)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;252150532D41646F6265&quot;</span>, <span class="string">&quot;ps&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;255044462d312e350d0a&quot;</span>, <span class="string">&quot;pdf&quot;</span>); <span class="comment">//Adobe Acrobat (pdf)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;2e524d46000000120001&quot;</span>, <span class="string">&quot;rmvb&quot;</span>); <span class="comment">//rmvb/rm相同</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;464c5601050000000900&quot;</span>, <span class="string">&quot;flv&quot;</span>); <span class="comment">//flv与f4v相同</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;00000020667479706d70&quot;</span>, <span class="string">&quot;mp4&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;49443303000000002176&quot;</span>, <span class="string">&quot;mp3&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;000001ba210001000180&quot;</span>, <span class="string">&quot;mpg&quot;</span>); <span class="comment">//</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;3026b2758e66cf11a6d9&quot;</span>, <span class="string">&quot;wmv&quot;</span>); <span class="comment">//wmv与asf相同</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;52494646e27807005741&quot;</span>, <span class="string">&quot;wav&quot;</span>); <span class="comment">//Wave (wav)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;52494646d07d60074156&quot;</span>, <span class="string">&quot;avi&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;4d546864000000060001&quot;</span>, <span class="string">&quot;mid&quot;</span>); <span class="comment">//MIDI (mid)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;504b0304140000000800&quot;</span>, <span class="string">&quot;zip&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;526172211a0700cf9073&quot;</span>, <span class="string">&quot;rar&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;235468697320636f6e66&quot;</span>, <span class="string">&quot;ini&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;504b03040a0000000000&quot;</span>, <span class="string">&quot;jar&quot;</span>);</span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;4d5a9000030000000400&quot;</span>, <span class="string">&quot;exe&quot;</span>);<span class="comment">//可执行文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;3c25402070616765206c&quot;</span>, <span class="string">&quot;jsp&quot;</span>);<span class="comment">//jsp文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;4d616e69666573742d56&quot;</span>, <span class="string">&quot;mf&quot;</span>);<span class="comment">//MF文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;3c3f786d6c2076657273&quot;</span>, <span class="string">&quot;xml&quot;</span>);<span class="comment">//xml文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;494e5345525420494e54&quot;</span>, <span class="string">&quot;sql&quot;</span>);<span class="comment">//xml文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;7061636b616765207765&quot;</span>, <span class="string">&quot;java&quot;</span>);<span class="comment">//java文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;406563686f206f66660d&quot;</span>, <span class="string">&quot;bat&quot;</span>);<span class="comment">//bat文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;1f8b0800000000000000&quot;</span>, <span class="string">&quot;gz&quot;</span>);<span class="comment">//gz文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;6c6f67346a2e726f6f74&quot;</span>, <span class="string">&quot;properties&quot;</span>);<span class="comment">//bat文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;cafebabe0000002e0041&quot;</span>, <span class="string">&quot;class&quot;</span>);<span class="comment">//bat文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;49545346030000006000&quot;</span>, <span class="string">&quot;chm&quot;</span>);<span class="comment">//bat文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;04000000010000001300&quot;</span>, <span class="string">&quot;mxp&quot;</span>);<span class="comment">//bat文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;504b0304140006000800&quot;</span>, <span class="string">&quot;docx&quot;</span>);<span class="comment">//docx文件</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;d0cf11e0a1b11ae10000&quot;</span>, <span class="string">&quot;wps&quot;</span>);<span class="comment">//WPS文字wps、表格et、演示dps都是一样的</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;6431303a637265617465&quot;</span>, <span class="string">&quot;torrent&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;6D6F6F76&quot;</span>, <span class="string">&quot;mov&quot;</span>); <span class="comment">//Quicktime (mov)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;FF575043&quot;</span>, <span class="string">&quot;wpd&quot;</span>); <span class="comment">//WordPerfect (wpd)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;CFAD12FEC5FD746F&quot;</span>, <span class="string">&quot;dbx&quot;</span>); <span class="comment">//Outlook Express (dbx)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;2142444E&quot;</span>, <span class="string">&quot;pst&quot;</span>); <span class="comment">//Outlook (pst)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;AC9EBD8F&quot;</span>, <span class="string">&quot;qdf&quot;</span>); <span class="comment">//Quicken (qdf)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;E3828596&quot;</span>, <span class="string">&quot;pwl&quot;</span>); <span class="comment">//Windows Password (pwl)</span></span><br><span class="line">        FILE_TYPE_MAP.put(<span class="string">&quot;2E7261FD&quot;</span>, <span class="string">&quot;ram&quot;</span>); <span class="comment">//Real Audio (ram)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据制定文件的文件头判断其文件类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePaht</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFileType</span><span class="params">(String filePaht)</span></span>&#123;</span><br><span class="line">        String res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream is = <span class="keyword">new</span> FileInputStream(filePaht);</span><br><span class="line">            getFileType(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFileType</span><span class="params">(InputStream in)</span></span>&#123;</span><br><span class="line">        String res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[CHECK_BYTES_NUMBER];</span><br><span class="line">            in.read(b, <span class="number">0</span>, b.length);</span><br><span class="line">            String fileCode = bytesToHexString(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(fileCode);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这种方法在字典的头代码不够位数的时候可以用但是速度相对慢一点</span></span><br><span class="line">            Iterator&lt;String&gt; keyIter = FILE_TYPE_MAP.keySet().iterator();</span><br><span class="line">            <span class="keyword">while</span>(keyIter.hasNext())&#123;</span><br><span class="line">                String key = keyIter.next();</span><br><span class="line">                <span class="keyword">if</span>(key.toLowerCase().startsWith(fileCode.toLowerCase()) || fileCode.toLowerCase().startsWith(key.toLowerCase()))&#123;</span><br><span class="line">                    res = FILE_TYPE_MAP.get(key);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到上传文件的文件头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytesToHexString</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = src[i] &amp; <span class="number">0xFF</span>;</span><br><span class="line">            String hv = Integer.toHexString(v);</span><br><span class="line">            <span class="keyword">if</span> (hv.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                stringBuilder.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            stringBuilder.append(hv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCheckBytesNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CHECK_BYTES_NUMBER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCheckBytesNumber</span><span class="params">(<span class="keyword">int</span> checkBytesNumber)</span> </span>&#123;</span><br><span class="line">        CHECK_BYTES_NUMBER = checkBytesNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150</span></span><br></pre></td></tr></table></figure><p>常见文件头表示如下:</p><p>255044PDF<br>526563 EML<br>D0CF11 PPT<br>4D5AEE COM<br>E93B03 COM<br>4D5A90 EXE<br>424D3E BMP<br>49492A TIF<br>384250 PSD<br>C5D0D3 EPS<br>0A0501 PCS<br>89504E PNG<br>060500 RAW<br>000002 TGA<br>60EA27 ARJ<br>526172 RAR<br>504B03 ZIP<br>495363 CAB<br>1F9D8C Z<br>524946 WAV<br>435753 SWF<br>3026B2 WMV<br>3026B2 WMA<br>2E524D RM<br>00000F MOV<br>000077 MOV<br>000001 MPA<br>FFFB50 MP3<br>234558 m3u<br>3C2144 HTM<br>FFFE3C XSL<br>3C3F78 XML<br>3C3F78 MSC<br>4C0000 LNK<br>495453 CHM<br>805343 scm<br>D0CF11 XLS<br>31BE00 WRI<br>00FFFF MDF<br>4D4544 MDS<br>5B436C CCD<br>00FFFF IMG<br>FFFFFF SUB<br>17A150 PCB<br>2A5052 ECO<br>526563 PPC<br>000100 DDB<br>42494C LDB<br>2A7665 SCH<br>2A2420 LIB<br>434841 FNT<br>7B5C72 RTF<br>7B5072 GTD<br>234445 PRG<br>000007 PJT<br>202020 BAS<br>000002 TAG<br>4D5A90 dll<br>4D5A90 OCX<br>4D5A50 DPL<br>3F5F03 HLP<br>4D5A90 OLB<br>4D5A90 IMM<br>4D5A90 IME<br>3F5F03 LHP<br>C22020 NLS<br>5B5769 CPX<br>4D5A16 DRV<br>5B4144 PBK<br>24536F PLL<br>4E4553 NES<br>87F53E GBC<br>00FFFF SMD<br>584245 XBE<br>005001 XMV<br>000100 TTF<br>484802 PDG<br>000100 TST<br>414331 dwg<br>D0CF11 max</p><p>另外还有一些重要的文件，<strong>没有固定的文件头</strong>，如下：</p><p><strong>TXT 没固定文件头定义</strong><br>TMP 没固定文件头定义<br>INI 没固定文件头定义<br>BIN 没固定文件头定义<br>DBF 没固定文件头定义<br>C 没没固定文件头定义<br>CPP 没固定文件头定义<br>H 没固定文件头定义<br>BAT 没固定文件头定义</p><p>还有一些不同的文件有相同的文件头，最典型的就是下面：</p><p>4D5A90 EXE<br>4D5A90 dll<br>4D5A90 OCX<br>4D5A90 OLB<br>4D5A90 IMM<br>4D5A90 IME</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>当我们需要实现上传文件的时候, 为了安全起见, 我们需要判断上传文件的格式, 防止将病毒木马等有害的文件上传到服务器上.</p><p>判断文件类型的三种方式</p><ul><li><p>通过文件后缀名</p><p>这个方法只要修改后缀名就可以了</p></li><li><p>通过Content-Type判断</p><p>但是Content-Type取决于文件类型, 文件类型取决于文件扩展名, 所以改变了文件扩展名就改变了Content-Type</p></li><li><p>通过文件头判断文件, 即使文件扩展名改变了文件头也不会改变</p></li></ul><p>文件上传的思路: 先判断Content-Type, Content-Type符合条件的再判断文件头信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;validate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">validate</span><span class="params">(<span class="meta">@Validated(&#123;AllFiled.class&#125;)</span> UserInfo userInfo, BindingResult result)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        SpringValidatorAdapter adapter = (SpringValidatorAdapter)result;</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            List&lt;ObjectError&gt; list  = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError error :</span><br><span class="line">                    list) &#123;</span><br><span class="line">                FieldError fieldError = (FieldError)error;</span><br><span class="line">                String defaultMessage = fieldError.getDefaultMessage();</span><br><span class="line">                String field = fieldError.getField();</span><br><span class="line">                map.put(field, defaultMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    consumes = &#123;</span></span><br><span class="line"><span class="comment">//        MediaType.MULTIPART_FORM_DATA_VALUE &#125;, produces = MediaType.TEXT_PLAIN_VALUE</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;file&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">file</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String fileName = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//获取表单提交文件使用的字段</span></span><br><span class="line">        String partName = file.getName();</span><br><span class="line">        <span class="comment">//判断文件是否为空</span></span><br><span class="line">        <span class="keyword">boolean</span> empty = file.isEmpty();</span><br><span class="line">        <span class="comment">//获取ContentType</span></span><br><span class="line">        String contentType = file.getContentType();</span><br><span class="line">        <span class="comment">//获取文件直接数</span></span><br><span class="line">        Long size = file.getSize();</span><br><span class="line">        <span class="comment">//获取文件所有字节</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">        <span class="comment">//获取InputStream</span></span><br><span class="line">        InputStream in = file.getInputStream();</span><br><span class="line">        <span class="comment">//根据文件头获取文件类型</span></span><br><span class="line">        String type = FileType.getFileType(in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//业务.....</span></span><br><span class="line"></span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储文件</span></span><br><span class="line">        File root = <span class="keyword">new</span> File(<span class="string">&quot;D:/temp&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!root.isDirectory()) &#123;</span><br><span class="line">            root.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span> File(root, name));</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">&quot;Upload to %s&quot;</span>, fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Upload Failed&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot-文件上传-通过Content-Type和文件头判断文件类型&quot;&gt;&lt;a href=&quot;#SpringBoot-文件上传-通过Content-Type和文件头判断文件类型&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 文
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="文件上传" scheme="http://yoursite.com/categories/SpringBoot/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事件</title>
    <link href="http://yoursite.com/2020/08/22/Mysql%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/08/22/Mysql%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-08-22T08:38:48.000Z</published>
    <updated>2020-08-22T08:48:41.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、事件概述"><a href="#1、事件概述" class="headerlink" title="1、事件概述"></a>1、事件概述</h1><p>在MySQL 5.1中新增了一个特色功能事件调度器（Event Scheduler），简称事件。它可以作为定时任务调度器，取代部分原来只能用操作系统的计划任务才能执行的工作。另外，更值得一提的是，MySQL的事件可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下是非常实用的。</p><p>事件调度器是定时触发执行的，从这个角度上看也可以称作是“临时触发器”。但是它与触发器又有所区别，触发器只针对某个表产生的事件执行一些语句，而事件调度器则是在某一段（间隔）时间执行一些语句。</p><h2 id="1-1-查看事件调度器是否开启"><a href="#1-1-查看事件调度器是否开启" class="headerlink" title="1.1 查看事件调度器是否开启"></a>1.1 查看事件调度器是否开启</h2><p>事件由一个特定的线程来管理。启用事件调度器后，拥有SUPER权限的账户执行SHOW PROCESSLIST就可以看到这个线程了。</p><p><strong>示例：</strong>查看事件是否开启。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;event_scheduler&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @@event_scheduler;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</span><br></pre></td></tr></table></figure><h2 id="1-2-开启或关闭事件调度器"><a href="#1-2-开启或关闭事件调度器" class="headerlink" title="1.2 开启或关闭事件调度器"></a>1.2 开启或关闭事件调度器</h2><p>通过设定全局变量event_scheduler的值即可动态的控制事件调度器是否启用。开启MySQL的事件调度器，可以通过下面两种方式实现。</p><h3 id="1-2-1-通过设置全局参数"><a href="#1-2-1-通过设置全局参数" class="headerlink" title="1.2.1 通过设置全局参数"></a>1.2.1 通过设置全局参数</h3><p>使用SET GLOBAL命令可以开启或关闭事件。将event_scheduler参数的值设置为ON，则开启事件；如果设置为OFF，则关闭事件。</p><p><strong>示例：</strong>使用SET GLOBAL命令可以开启或关闭事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启事件调度器SET GLOBAL event_scheduler = ON;</span></span><br><span class="line"><span class="comment">-- 关闭事件调度器SET GLOBAL event_scheduler = OFF;</span></span><br><span class="line"><span class="comment">-- 查看事件调度器状态SHOW VARIABLES LIKE &#x27;event_scheduler&#x27;;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果想要始终开启事件，那么在使用SET GLOBAL开启事件后，还需要在my.ini（Windows系统）/my.cnf（Linux系统）中添加event_scheduler=on。因为如果没有添加，MySQL重启事件后又会回到原来的状态。</p><h3 id="1-2-2-通过更改配置文件"><a href="#1-2-2-通过更改配置文件" class="headerlink" title="1.2.2 通过更改配置文件"></a>1.2.2 通过更改配置文件</h3><p>在MySQL的配置文件my.ini（Windows系统）/my.cnf（Linux系统）中，找对[mysqld]，然后在下面添加以下代码开启事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 事件调度器启动状态event_scheduler = on</span></span><br></pre></td></tr></table></figure><p>在配置文件中添加代码并保存文件后，还需要重新启动MySQL服务器才能生效。通过该方法开启事件，重启MySQL服务器后，不恢复为系统默认的状态。</p><h1 id="2、创建事件"><a href="#2、创建事件" class="headerlink" title="2、创建事件"></a>2、创建事件</h1><p>在MySQL 5.1以上版本中，可以通过CREATE EVENT语句来创建事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>    [DEFINER=&#123;<span class="keyword">user</span> | <span class="keyword">CURRENT_USER</span>&#125;]    <span class="keyword">EVENT</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] event_name    </span><br><span class="line"><span class="keyword">ON</span> SCHEDULE schedule    </span><br><span class="line">[<span class="keyword">ON</span> COMPLETION [<span class="keyword">NOT</span>] <span class="keyword">PRESERVE</span>]    </span><br><span class="line">[<span class="keyword">ENABLE</span> | <span class="keyword">DISABLE</span> | <span class="keyword">DISABLE</span> <span class="keyword">ON</span> <span class="keyword">SLAVE</span>]    </span><br><span class="line">[<span class="keyword">COMMENT</span> <span class="string">&#x27;comment&#x27;</span>]    <span class="keyword">DO</span> event_body;</span><br></pre></td></tr></table></figure><p><strong>CREATE EVENT语句的子句：</strong></p><table><thead><tr><th align="left">子句</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">DEFINER</td><td align="left">可选，用于定义事件执行时检查权限的用户</td></tr><tr><td align="left">IF NOT EXISTS</td><td align="left">可选项，用于判断要创建的事件是否存在</td></tr><tr><td align="left">EVENT event_name</td><td align="left">必选，用于指定事件名，event_name的最大长度为64个字符，如果为指定event_name，则默认为当前的MySQL用户名（不区分大小写）</td></tr><tr><td align="left">ON SCHEDULE schedule</td><td align="left">必选，用于定义执行的时间和时间间隔</td></tr><tr><td align="left">ON COMPLETION [NOT] PRESERVE</td><td align="left">可选，用于定义事件是否循环执行，即是一次执行还是永久执行，默认为一次执行，即 NOT PRESERVE</td></tr><tr><td align="left">ENABLE | DISABLE | DISABLE ON SLAVE</td><td align="left">可选项，用于指定事件的一种属性。其中，关键字ENABLE表示该事件是活动的，也就是调度器检查事件是否必选调用；关键字DISABLE表示该事件是关闭的，也就是事件的声明存储到目录中，但是调度器不会检查它是否应该调用；关键字DISABLE ON SLAVE表示事件在从机中是关闭的。如果不指定这三个选择中的任意一个，则在一个事件创建之后，它立即变为活动的。</td></tr><tr><td align="left">COMMENT ‘comment’</td><td align="left">可选，用于定义事件的注释</td></tr><tr><td align="left">DO event_body</td><td align="left">必选，用于指定事件启动时所要执行的代码。可以是任何有效的SQL语句、存储过程或者一个计划执行的事件。如果包含多条语句，可以使用BEGIN…END复合结构</td></tr></tbody></table><p>在ON SCHEDULE子句中，参数schedule的值为一个AS子句，用于指定事件在某个时刻发生，其语法格式如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">AT timestamp [+ INTERVAL interval] ...  | EVERY interval    [STARTS timestamp [+ INTERVAL interval] ...]    [ENDS timestamp [+ INTERVAL interval] ...]</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p>（1）timestamp：表示一个具体的时间点，后面加上一个时间间隔，表示在这个时间间隔后事件发生。</p><p>（2）EVERY子句：用于表示事件在指定时间区间内每隔多长时间发生一次，其中 SELECT子句用于指定开始时间；ENDS子句用于指定结束时间。</p><p>（3）interval：表示一个从现在开始的时间，其值由一个数值和单位构成。例如，使用“4 WEEK”表示4周；使用“‘1:10’ HOUR_MINUTE”表示1小时10分钟。间隔的距离用DATE_ADD()函数来支配。</p><p>interval参数值的语法格式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">quantity &#123;YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |              </span><br><span class="line">WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |              </span><br><span class="line">DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND&#125;</span><br></pre></td></tr></table></figure><p><strong>一些常用的时间间隔设置：</strong></p><p>（1）每隔5秒钟执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ON SCHEDULE EVERY 5 SECOND</span><br></pre></td></tr></table></figure><p>（2）每隔1分钟执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ON SCHEDULE EVERY 1 MINUTE</span><br></pre></td></tr></table></figure><p>（3）每天凌晨1点执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ON SCHEDULE EVERY 1 DAY STARTS DATE_ADD(DATE_ADD(CURDATE(), INTERVAL 1 DAY), INTERVAL 1 HOUR)</span><br></pre></td></tr></table></figure><p>（4）每个月的第一天凌晨1点执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ON SCHEDULE EVERY 1 MONTH STARTS DATE_ADD(DATE_ADD(DATE_SUB(CURDATE(),INTERVAL DAY(CURDATE())-1 DAY),INTERVAL 1 MONTH),INTERVAL 1 HOUR)</span><br></pre></td></tr></table></figure><p>（5）每 3 个月，从现在起一周后开始</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ON SCHEDULE EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + 1 WEEK</span><br></pre></td></tr></table></figure><p>（6）每十二个小时，从现在起三十分钟后开始，并于现在起四个星期后结束</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ON SCHEDULE EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK</span><br></pre></td></tr></table></figure><p><strong>示例1：</strong>创建名称为event_user的事件，用于每隔5秒钟向数据表tb_user（用户信息表）中插入一条数据。</p><p>（1）首先创建tb_user（用户信息表）。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tb_user(    </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户编号&#x27;</span>,    </span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户姓名&#x27;</span>,    </span><br><span class="line">    create_time <span class="built_in">TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;创建时间&#x27;</span>) </span><br><span class="line"><span class="keyword">COMMENT</span> = <span class="string">&#x27;用户信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（2）创建事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建事件</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> event_userON </span><br><span class="line">SCHEDULE EVERY <span class="number">5</span> SECONDON </span><br><span class="line">COMPLETION PRESERVECOMMENT <span class="string">&#x27;新增用户信息定时任务&#x27;</span></span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user(<span class="keyword">name</span>,create_time) <span class="keyword">VALUES</span>(<span class="string">&#x27;pan_junbiao的博客&#x27;</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>创建一个事件，实现每个月的第一天凌晨1点统计一次已经注册的会员人数，并插入到统计表中。</p><p>（1）创建名称为p_total的存储过程，用于统计已经注册的会员人数，并插入到统计表tb_total中。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p_total()<span class="keyword">BEGIN</span>    <span class="keyword">DECLARE</span> n_total <span class="built_in">INT</span> <span class="keyword">default</span> <span class="number">0</span>;    </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> n_total <span class="keyword">FROM</span> db_database11.tb_user;    </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_total (userNumber,createtime) <span class="keyword">VALUES</span>(n_total,<span class="keyword">NOW</span>());<span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>（2）创建名称为e_autoTotal的事件，用于在每个月的第一天凌晨1点调用存储过程。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> e_autoTotal</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE EVERY <span class="number">1</span> <span class="keyword">MONTH</span> STARTS <span class="keyword">DATE_ADD</span>(<span class="keyword">DATE_ADD</span>(<span class="keyword">DATE_SUB</span>(<span class="keyword">CURDATE</span>(),<span class="built_in">INTERVAL</span> <span class="keyword">DAY</span>(<span class="keyword">CURDATE</span>())<span class="number">-1</span> <span class="keyword">DAY</span>),<span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>),<span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">HOUR</span>)</span><br><span class="line"><span class="keyword">ON</span> COMPLETION <span class="keyword">PRESERVE</span> ENABLEDO <span class="keyword">CALL</span> p_total();</span><br></pre></td></tr></table></figure><h1 id="3、查询事件"><a href="#3、查询事件" class="headerlink" title="3、查询事件"></a>3、查询事件</h1><p>在MySQL中可以通过查询information_schema.events表，查看已创建的事件。其语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.events; </span><br></pre></td></tr></table></figure><h1 id="4、修改事件"><a href="#4、修改事件" class="headerlink" title="4、修改事件"></a>4、修改事件</h1><p>在MySQL 5.1及以后版本中，事件被创建之后，还可以使用ALTER EVENT语句修改其定义和相关属性。其语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span>    [DEFINER=&#123;<span class="keyword">user</span> | <span class="keyword">CURRENT_USER</span>&#125;]    <span class="keyword">EVENT</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] event_name    <span class="keyword">ON</span> SCHEDULE schedule    [<span class="keyword">ON</span> COMPLETION [<span class="keyword">NOT</span>] <span class="keyword">PRESERVE</span>]    [<span class="keyword">ENABLE</span> | <span class="keyword">DISABLE</span> | <span class="keyword">DISABLE</span> <span class="keyword">ON</span> <span class="keyword">SLAVE</span>]    [<span class="keyword">COMMENT</span> <span class="string">&#x27;comment&#x27;</span>]    <span class="keyword">DO</span> event_body;</span><br></pre></td></tr></table></figure><p>ALTER EVENT语句与CREATE EVENT语句基本相同。另外ALTER EVENT语句还有一个用法就是让一个事件关闭或再次活动。</p><h1 id="5、启动与关闭事件"><a href="#5、启动与关闭事件" class="headerlink" title="5、启动与关闭事件"></a>5、启动与关闭事件</h1><p>另外ALTER EVENT语句还有一个用法就是让一个事件关闭或再次活动。</p><p><strong>示例：</strong>启动名称为event_user的事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">EVENT</span> event_user <span class="keyword">ENABLE</span>;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong>关闭名称为event_user的事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">EVENT</span> event_user <span class="keyword">DISABLE</span>;</span><br></pre></td></tr></table></figure><h1 id="6、删除事件"><a href="#6、删除事件" class="headerlink" title="6、删除事件"></a>6、删除事件</h1><p>在MySQL 5.1及以后版本中，删除已经创建的事件可以使用DROP EVENT语句来实现。</p><p><strong>示例：</strong>删除名称为event_user的事件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">EVENT</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> event_user;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Mysql事件的说明与使用
    
    </summary>
    
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>转载---并查集</title>
    <link href="http://yoursite.com/2020/08/09/%E8%BD%AC%E8%BD%BD-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/08/09/%E8%BD%AC%E8%BD%BD-%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-08-09T03:02:18.000Z</published>
    <updated>2020-08-09T03:20:16.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f2f6ade14195aa594b8b439.png"></p><p><img src="https://pic.downk.cc/item/5f2f6b4114195aa594b8d882.png"></p><p><img src="https://pic.downk.cc/item/5f2f6b4114195aa594b8d884.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f2f6ade14195aa594b8b439.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f2f6b4114195aa594b8d882.pn
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>转载---ThreadLocal的原理</title>
    <link href="http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-08T05:36:13.000Z</published>
    <updated>2020-08-08T06:27:32.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一针见血理解ThreadLocal类"><a href="#一针见血理解ThreadLocal类" class="headerlink" title="一针见血理解ThreadLocal类"></a><strong>一针见血理解ThreadLocal类</strong></h1><p><strong>ThreadLocal类具有两个维度：线程维度和变量维度。扔掉线程维度，保留并放大变量维度，虽然思想片面，但是给人的印象却是极深，才能用之出神入化。</strong> </p><p>ThreadLocal类是修饰变量的，<strong>重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了</strong>。很多开发语言在语言级别都提供这种作用域的变量类型。</p><p>根据变量的作用域，可以将变量分为全局变量，局部变量。简单的说，类里面定义的变量是全局变量，函数里面定义的变量是局部变量。</p><p>还有一种作用域是线程作用域，线程一般是跨越几个函数的。为了在几个函数之间共用一个变量，所以才出现：线程变量，这种变量在Java中就是ThreadLocal变量。</p><p>全局变量，范围很大；局部变量，范围很小。无论是大还是小，其实都是定死的。而线程变量，调用几个函数，则决定了它的作用域有多大。</p><p>ThreadLocal是跨函数的，虽然全局变量也是跨函数的，但是跨所有的函数，而且不是动态的。</p><p>ThreadLocal是跨函数的，但是跨哪些函数呢，由线程来定，更灵活。</p><p><a href="http://threadlocal.cn/"><strong>一针见血理解ThreadLocal类</strong> </a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>和Synchronized的区别</li><li>存储在jvm的哪个区域</li><li>真的只是当前线程可见吗</li><li>会导致内存泄漏么</li><li>为什么用Entry数组而不是Entry对象</li><li>你学习的开源框架哪些用到了ThreadLocal</li><li>ThreadLocal里的对象一定是线程安全的吗</li><li>笔试题</li></ol><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="官方术语"><a href="#官方术语" class="headerlink" title="官方术语"></a>官方术语</h2><p>ThreadLocal类是用来提供线程内部的局部变量。让这些变量在多线程环境下访问（get/set）时能保证各个线程里的变量相对独立于其他线程内的变量。</p><h2 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h2><p>ThreadLocal是一个关于创建线程局部变量的类。</p><p>通常情况下，我们创建的成员变量都是线程不安全的。因为他可能被多个线程同时修改，此变量对于多个线程之间彼此并不独立，是共享变量。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程无法访问和修改。也就是说：将线程公有化变成线程私有化。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>每个线程都需要一个独享的对象（比如工具类，典型的就是<code>SimpleDateFormat</code>，每次使用都new一个多浪费性能呀，直接放到成员变量里又是线程不安全，所以把他用<code>ThreadLocal</code>管理起来就完美了。）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: SimpleDateFormat就一份，不浪费资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TongWei.Chen 2020-07-10 14:00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest05</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStr</span><span class="params">(<span class="keyword">int</span> millisSeconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(millisSeconds);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                String date = dateToStr(j * <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 从结果中可以看出是线程安全的，时间没有重复的。</span></span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// java8的写法</span></span><br><span class="line"><span class="comment">//    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span></span><br><span class="line"><span class="comment">//            ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>细心的朋友已经发现了，这也是每个线程都创建一个<code>SimpleDateFormat</code>，跟直接在方法内部new没区别，错了，大错特错！1个请求进来是一个线程，他可能贯穿了N个方法，你这N个方法假设有3个都在使用<code>dateToStr()</code>，你直接new的话会产生三个<code>SimpleDateFormat</code>对象，而用<code>ThreadLocal</code>的话只会产生一个对象，一个线程一个。 </p>          </div><ul><li>每个线程内需要保存全局变量（比如在登录成功后将用户信息存到<code>ThreadLocal</code>里，然后当前线程操作的业务逻辑直接get取就完事了，有效的避免的参数来回传递的麻烦之处），一定层级上减少代码耦合度。 </li></ul><h1 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h1><h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><p>每个<code>Thread</code>对象中都持有一个<code>ThreadLocalMap</code>的成员变量。每个<code>ThreadLocalMap</code>内部又维护了N个<code>Entry</code>节点，也就是<code>Entry</code>数组，每个<code>Entry</code>代表一个完整的对象，key是<code>ThreadLocal</code>本身，value是<code>ThreadLocal</code>的泛型值。</p><p>核心源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Thread类里持有ThreadLocalMap的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java.lang.ThreadLocal有内部静态类ThreadLocalMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ThreadLocalMap内部有Entry类，Entry的key是ThreadLocal本身，value是泛型值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类关系图–-ThreadLocal内存结构图。"><a href="#类关系图–-ThreadLocal内存结构图。" class="headerlink" title="类关系图– ThreadLocal内存结构图。"></a>类关系图– ThreadLocal内存结构图。</h2><p><img src="https://pic.downk.cc/item/5f2e3ae414195aa594489736.png"></p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><ul><li><code>initialValue</code>：初始化。在<code>get</code>方法里懒加载的。</li><li><code>get</code>：得到这个线程对应的value。<em>如果调用get之前没set过，则get内部会执行<code>initialValue</code>方法进行初始化。</em></li><li><code>set</code>：为这个线程设置一个新值。</li><li><code>remove</code>：删除这个线程对应的值，防止内存泄露的最佳手段。</li></ul><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a><code>initialValue</code></h3><h4 id="什么意思"><a href="#什么意思" class="headerlink" title="什么意思"></a>什么意思</h4><p>见名知意，初始化一些value（泛型值）。懒加载的。</p><h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>调用<code>get</code>方法之前没有调用<code>set</code>方法，则<code>get</code>方法内部会触发<code>initialValue</code>，也就是说<code>get</code>的时候如果没拿到东西，则会触发<code>initialValue</code>。</p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul><li>通常，每个线程最多调用一次此方法。但是如果已经调用了<code>remove()</code>，然后再次调用<code>get()</code>的话，则可以再次触发<code>initialValue</code>。</li><li>如果要重写的话一般建议采取匿名内部类的方式重写此方法，否则默认返回的是null。</li></ul><p>比如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Java8的高逼格写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected的含义就是交给子类干的。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><h4 id="什么意思-1"><a href="#什么意思-1" class="headerlink" title="什么意思"></a>什么意思</h4><p>获取当前线程下的ThreadLocal中的值。</p><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过<code>threadLocalHashCode</code>来获取table[]中存放的Entry对象, 也就是ThreadLocal对象</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h3><h4 id="什么意思-2"><a href="#什么意思-2" class="headerlink" title="什么意思"></a>什么意思</h4><p>其实干的事和<code>initialValue</code>是一样的，都是set值，只是调用时机不同。set是想用就用，api摆在这里，你想用就调一下set方法。很自由。</p><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例，注意这里是将t传进去了，t是当前线程，就是说ThreadLocalMap是在线程里持有的引用。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h3><h4 id="什么意思-3"><a href="#什么意思-3" class="headerlink" title="什么意思"></a>什么意思</h4><p>将当前线程下的ThreadLocal的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</p><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 直接移除以当前ThreadLocal为key的value</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>为啥单独拿出来说下，我就是想强调一点：这个东西是归<code>Thread</code>类所有的。它的引用在<code>Thread</code>类里，这也证实了一个问题：<code>ThreadLocalMap</code>类内部为什么有<code>Entry</code>数组，而不是<code>Entry</code>对象？</p><p>因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为再说一次，<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p><p>核心源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在你调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span></span><br><span class="line"><span class="comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h1><h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地线程。Thread：线程。Local：本地</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始值，用来初始化值用的，比如：ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// 你想Integer value = count.get(); value++;这样是报错的，因为count现在还没值，取出来的是个null,所以你需要先重写此方法为value赋上初始值，本身方法是protected也代表就是为了子类重写的。</span></span><br><span class="line">    <span class="comment">// 此方法是一个延迟调用方法，在线程第一次调用get的时候才执行，下面具体分析源码就知道了。</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建ThreadLocalMap，ThreadLocal底层其实就是一个map来维护的。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回该当前线程对应的线程局部变量值。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取ThreadLocalMap</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置当前线程的线程局部变量的值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将当前线程局部变量的值删除，目的是为了减少内存占用。其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置初始值，调用initialValue</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 静态内部类，一个map来维护的！！！</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// ThreadLocalMap的静态内部类，继承了弱引用，这正是不会造成内存泄漏根本原因</span></span><br><span class="line">        <span class="comment">// Entry的key为ThreadLocal并且是弱引用。value是值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMap"><a href="#getMap" class="headerlink" title="getMap()"></a>getMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在你调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span></span><br><span class="line"><span class="comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-set"><a href="#map-set" class="headerlink" title="map.set()"></a>map.set()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不多BB，就和HashMap的set一个道理，只是赋值key,value。</span></span><br><span class="line"><span class="comment">// 需要注意的是这里key是ThreadLocal对象，value是值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="createMap"><a href="#createMap" class="headerlink" title="createMap()"></a>createMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ThreadLocalMap对象。</span></span><br><span class="line"><span class="comment"> * t.threadLocals在上面的getMap中详细介绍了。此处不BB。</span></span><br><span class="line"><span class="comment"> * 实例化ThreadLocalMap并且传入两个值，一个是当前ThreadLocal对象一个是value。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ThreadLocalMap构造器。</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 重点看这里！！！！！！</span></span><br><span class="line">    <span class="comment">// new了一个ThreadLocalMap的内部类Entry，且将key和value传入。</span></span><br><span class="line">    <span class="comment">// key是ThreadLocal对象。</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 到这里朋友们应该真相大白了，其实ThreadLocal就是内部维护一个ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 而ThreadLocalMap内部又维护了一个Entry对象。Entry对象是key-value形式，</span></span><br><span class="line"><span class="comment"> * key是ThreadLocal对象，value是传入的value</span></span><br><span class="line"><span class="comment"> * 所以我们对ThreadLocal的操作其实都是对内部的ThreadLocalMap.Entry的操作</span></span><br><span class="line"><span class="comment"> * 所以保证了线程之前互不干扰。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用初始值方法，由子类提供。</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 获取到了</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// set</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 没获取到。创建map并赋值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回初始值。</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initialValue-1"><a href="#initialValue-1" class="headerlink" title="initialValue()"></a>initialValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。</span></span><br><span class="line"><span class="comment"> * 其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>只要捋清楚如下几个类的关系，<code>ThreadLocal</code>将变得so easy！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread&#96;、&#96;ThreadLocal&#96;、&#96;ThreadLocalMap&#96;、&#96;Entry</span><br></pre></td></tr></table></figure><p>一句话总结就是：<code>Thread</code>维护了<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>里维护了<code>Entry</code>，而<code>Entry</code>里存的是以<code>ThreadLocal</code>为key，传入的值为value的键值对。</p><h1 id="答疑（面试题）"><a href="#答疑（面试题）" class="headerlink" title="答疑（面试题）"></a>答疑（面试题）</h1><h2 id="如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"><a href="#如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？" class="headerlink" title="如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"></a>如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个ThreadLocal对象，都有一个final修饰的int型的threadLocalHashCode不可变属性，对于基本数据类型，可以认为它在初始化后就不可以进行修改，所以可以唯一确定一个ThreadLocal对象。<br>　　但是如何保证两个同时实例化的ThreadLocal对象有不同的threadLocalHashCode属性：在ThreadLocal类中，还包含了一个static修饰的AtomicInteger（[əˈtɒmɪk]提供原子操作的Integer类）成员变量（即类变量）和一个static final修饰的常量（作为两个相邻nextHashCode的差值）。由于nextHashCode是类变量，所以每一次调用ThreadLocal类都可以保证nextHashCode被更新到新的值，并且下一次调用ThreadLocal类这个被更新的值仍然可用，同时AtomicInteger保证了nextHashCode自增的原子性。</p><h3 id="为什么不直接用线程id来作为ThreadLocalMap的key？"><a href="#为什么不直接用线程id来作为ThreadLocalMap的key？" class="headerlink" title="为什么不直接用线程id来作为ThreadLocalMap的key？"></a>为什么不直接用线程id来作为ThreadLocalMap的key？</h3><p>　　这一点很容易理解，因为直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？<br>　　而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个ThreadLocal对象都可以由这个对象的名字唯一区分，所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。</p><h2 id="和Synchronized的区别"><a href="#和Synchronized的区别" class="headerlink" title="和Synchronized的区别"></a>和Synchronized的区别</h2><p>问：他和线程同步机制（如：Synchronized）提供一样的功能，这个很吊啊。</p><p>答：放屁！同步机制保证的是多线程同时操作共享变量并且能正确的输出结果。ThreadLocal不行啊，他把共享变量变成线程私有了，每个线程都有独立的一个变量。举个通俗易懂的案例：网站计数器，你给变量count++的时候带上synchronized即可解决。ThreadLocal的话做不到啊，他没发统计，他只能说能统计每个线程登录了多少次。</p><h2 id="存储在jvm的哪个区域"><a href="#存储在jvm的哪个区域" class="headerlink" title="存储在jvm的哪个区域"></a>存储在jvm的哪个区域</h2><p>问：线程私有，那么就是说ThreadLocal的实例和他的值是放到栈上咯？</p><p>答：不是。还是在堆的。ThreadLocal对象也是对象，对象就在堆。只是JVM通过一些技巧将其可见性变成了线程可见。</p><h2 id="真的只是当前线程可见吗"><a href="#真的只是当前线程可见吗" class="headerlink" title="真的只是当前线程可见吗"></a>真的只是当前线程可见吗</h2><p>问：真的只是当前线程可见吗？</p><p>答：貌似不是，貌似通过<code>InheritableThreadLocal</code>类可以实现多个线程访问<code>ThreadLocal</code>的值，但是我没研究过，知道这码事就行了。</p><h2 id="会导致内存泄漏么"><a href="#会导致内存泄漏么" class="headerlink" title="会导致内存泄漏么"></a>会导致内存泄漏么</h2><p>问：会导致内存泄漏么？</p><p>答：分析一下：</p><ul><li>1、<code>ThreadLocalMap.Entry</code>的key会内存泄漏吗？</li><li>2、<code>ThreadLocalMap.Entry</code>的value会内存泄漏吗？</li></ul><p>先看下key-value的核心源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先看继承关系，发现是继承了弱引用，而且key直接是交给了父类处理<code>super(key)</code>，父类是个弱引用，所以key完全不存在内存泄漏问题，因为他不是强引用，它可以被GC回收的。 </p><div class="note info">            <p>弱引用的特点：如果这个对象只被弱引用关联，没有任何强引用关联，那么这个对象就可以被GC回收掉。弱引用不会阻止GC回收。这是jvm知识。 </p>          </div><p>看value，发现value是个强引用，但是想了下也没问题的呀，因为线程终止了，我管你强引用还是弱引用，都会被GC掉的，因为引用链断了（jvm用的可达性分析法，线程终止了，根节点就断了，下面的都会被回收）。</p><p>这么分析一点毛病都没有，但是忘了一个主要的角色，那就是<strong>线程池</strong>，线程池的存在核心线程是不会销毁的，只要创建出来他会反复利用，生命周期不会结束掉，但是key是弱引用会被GC回收掉，value强引用不会回收，所以形成了如下场面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value</span><br></pre></td></tr></table></figure><p>由于value和Thread还存在链路关系，还是可达的，所以不会被回收，这样越来越多的垃圾对象产生却无法回收，早晨内存泄漏，时间久了必定OOM。</p><p>解决方案<code>ThreadLocal</code>已经为我们想好了，提供了<code>remove()</code>方法，这个方法是将value移出去的。所以用完后记得<code>remove()</code>。</p><h2 id="为什么用Entry数组而不是Entry对象"><a href="#为什么用Entry数组而不是Entry对象" class="headerlink" title="为什么用Entry数组而不是Entry对象"></a>为什么用Entry数组而不是Entry对象</h2><p> 这个其实主要想考<code>ThreadLocalMap</code>是在<code>Thread</code>里持有的引用。 </p><p>：<code>ThreadLocalMap</code>内部的table为什么是数组而不是单个对象呢？</p><p>答：因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p><h2 id="你学习的开源框架哪些用到了ThreadLocal"><a href="#你学习的开源框架哪些用到了ThreadLocal" class="headerlink" title="你学习的开源框架哪些用到了ThreadLocal"></a>你学习的开源框架哪些用到了ThreadLocal</h2><p>Spring框架。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DateTimeContextHolder</span><br><span class="line">RequestContextHolder</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal里的对象一定是线程安全的吗"><a href="#ThreadLocal里的对象一定是线程安全的吗" class="headerlink" title="ThreadLocal里的对象一定是线程安全的吗"></a>ThreadLocal里的对象一定是线程安全的吗</h2><p>未必，如果在每个线程中<code>ThreadLocal.set()</code>进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的<code>ThreadLocal.get()</code>获取的还是这个共享对象本身，还是有并发访问线程不安全问题。</p><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><p>问：下面这段程序会输出什么？为什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocalNpe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            set();</span><br><span class="line">            System.out.println(get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 目的就是为了让子线程先运行完</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line"> at com.chentongwei.study.thread.TestThreadLocalNpe.get(TestThreadLocalNpe.java:<span class="number">16</span>)</span><br><span class="line"> at com.chentongwei.study.thread.TestThreadLocalNpe.main(TestThreadLocalNpe.java:<span class="number">26</span>)</span><br></pre></td></tr></table></figure><p>为什么？</p><p>为什么输出个1，然后空指针了？</p><p>首先输出1是没任何问题的，其次主线程空指针是为什么？</p><p>如果你这里回答</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>那我恭喜你，你连<code>ThreadLocal</code>都不知道是啥，这明显两个线程，子线程和主线程。子线程设置1，主线程肯定拿不到啊，<code>ThreadLocal</code>和线程是嘻嘻相关的。这个不多费口舌。</p><p>说说为什么是空指针？</p><p>因为你get方法用的long而不是Long，那也应该返回null啊，大哥，long是基本类型，默认值是0，没有null这一说法。<code>ThreadLocal</code>里的泛型是Long，get却是基本类型，这需要拆箱操作的，也就是会执行<code>null.longValue()</code>的操作，这绝逼空指针了。</p><blockquote><p>看似一道Javase的基础题目，实则隐藏了很多知识。</p></blockquote><h1 id="ThreadLocal工具类"><a href="#ThreadLocal工具类" class="headerlink" title="ThreadLocal工具类"></a>ThreadLocal工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.duoku.base.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NamedThreadLocal;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TongWei.Chen 2019-09-09 18:35:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;xxx-threadlocal&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Maps.newHashMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getThreadLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        <span class="comment">// todo:copy a new one</span></span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,T defaultValue)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key) == <span class="keyword">null</span> ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Map&lt;String, Object&gt; keyValueMap)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h1><p> <strong>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</strong>。下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用： </p><p><img src="https://pic.downk.cc/item/5f2e405c14195aa5944ad13d.png"></p><p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。<br>　　<br>　　ThreadLocalMap设计时的对上面问题的对策：<br>ThreadLocalMap的getEntry函数的流程大概为：</p><ol><li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (table.length-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li><li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。否则，如果key值为null，则擦除该位置的Entry，并继续向下一个位置查询。在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。<br>　　但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</li></ol><p>即：<br>1.使用ThreadLocal，建议用static修饰 static ThreadLocal headerLocal = new ThreadLocal();<br>2.使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</p><h1 id="Java中的四种引用类型（强、软、弱、虚）"><a href="#Java中的四种引用类型（强、软、弱、虚）" class="headerlink" title="Java中的四种引用类型（强、软、弱、虚）"></a><strong>Java中的四种引用类型（强、软、弱、虚）</strong></h1><p> 从Java 1.2开始，JVM开发团队发现，单一的强引用类型，无法很好的管理对象在JVM里面的生命周期，垃圾回收策略过于简单，无法适用绝大多数场景。为了更好的管理对象的内存，更好的进行垃圾回收，JVM团队扩展了引用类型，从最早的强引用类型增加到强、软、弱、虚四个引用类型。 </p><p>Strong Rerence为JVM内部实现。其他三类引用类型全部继承自Reference父类。如下图所示：</p><p><img src="http://threadlocal.cn/static/image/reference.jpg?v=f25eecc290e57663c98198e92c1ac67a" alt="img"></p><h5 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h5><p>Strong Rerence这个类并不存在，默认的对象都是强引用类型，因为有后来的新引用所衬托，所以才起了个名字叫”强引用”。</p><p>强引用使用示例如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String web &#x3D; &quot;www.threadlocal.cn&quot;;</span><br></pre></td></tr></table></figure><p>如果JVM垃圾回收器 GC 可达性分析结果为可达，表示引用类型仍然被引用着，这类对象始终不会被垃圾回收器回收，即使JVM发生OOM也不会回收。而如果 GC 的可达性分析结果为不可达，那么在GC时会被回收。</p><h5 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h5><p>软引用是一种比强引用生命周期稍弱的一种引用类型。在JVM内存充足的情况下，软引用并不会被垃圾回收器回收，只有在JVM内存不足的情况下，才会被垃圾回收器回收。所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p><p>软引用使用示例如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference &#x3D; new SoftReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;));</span><br><span class="line">String web &#x3D; softReference.get();</span><br></pre></td></tr></table></figure><h5 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h5><p>弱引用是一种比软引用生命周期更短的引用。它的生命周期很短，不论当前内存是否充足，都只能存活到下一次垃圾收集之前。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; weakReference &#x3D; new WeakReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;));</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">if(weakReference.get() &#x3D;&#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;weakReference已经被GC回收&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>weakReference已经被GC回收</p><h5 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h5><p>虚引用与前面的几种都不一样，这种引用类型不会影响对象的生命周期，所持有的引用就跟没持有一样，随时都能被GC回收。</p><p>需要注意的是，在使用虚引用时，必须和引用队列关联使用。在对象的垃圾回收过程中，如果GC发现一个对象还存在虚引用，则会把这个虚引用加入到与之关联的引用队列中。</p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p><p>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象内存被回收之前采取必要的行动防止被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; phantomReference &#x3D; new PhantomReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;), new ReferenceQueue&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">System.out.println(phantomReference.get());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一针见血理解ThreadLocal类&quot;&gt;&lt;a href=&quot;#一针见血理解ThreadLocal类&quot; class=&quot;headerlink&quot; title=&quot;一针见血理解ThreadLocal类&quot;&gt;&lt;/a&gt;&lt;strong&gt;一针见血理解ThreadLocal类&lt;/stro
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>PostMan的使用方法</title>
    <link href="http://yoursite.com/2020/08/05/Postman%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/05/Postman%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-05T14:09:55.000Z</published>
    <updated>2020-08-08T01:59:40.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求区域介绍"><a href="#请求区域介绍" class="headerlink" title="请求区域介绍"></a>请求区域介绍</h1><p><img src="https://pic.downk.cc/item/5f2e06f514195aa594353825.jpg"></p><p><strong>1</strong>  <strong>Authorization：</strong>身份验证，主要用来填写用户名密码，以及一些验签字段,postman有一个helpers可以帮助我们简化一些重复和复杂的任务。当前的一套helpers可以帮助你解决一些authentication protocols的问题。；</p><p><strong>2</strong>  <strong>Headers：</strong>请求的头部信息</p><p><strong>3</strong>  <strong>Body：</strong>post请求时必须要带的参数，里面放一些key-value键值对</p><p><strong>4</strong>  **Pre-requerst Script:**可以让你在 请求之前自定义请求数据，这个运行在请求之前，语法使用JavaScript语句。</p><p><strong>5</strong>  <strong>tests：</strong>tests标签功能比较强大，通常用来写测试，它是运行在请求之后。支持JavaScript语法。postman每次执行request的时候，会执行tests。测试结果会在tests的tab上面显示一个通过的数量以及对错情况。这个后面会进行详解，它也可以用来设计用例，比如要测试返回结果是否含有某一字符串</p><p><strong>6</strong>  <strong>form-data</strong>：,它将表单数据处理为一条消息，以标签为单元，用分隔符分开。既可以单独上传键值对，也可以直接上传文件（当上传字段是文件时，会有Content-Type来说明文件类型,但该文件不会作为历史保存，只能在每次需要发送请求的时候，重新添加文件。）；post请求里<strong>较常用的一种</strong></p><p><strong>7</strong>  <strong>x-www-form-urlencoded</strong>：对应信息头-application/x-www-from-urlencoded，会将表单内的数据转换为键值对；</p><p><strong>8</strong>  <strong>raw</strong>：可以上传任意类型的文本，比如text、json、xml等,所有填写的text都会随着请求发送；</p><p><strong>9</strong>  <strong>binary</strong>：对应信息头-Content-Type:application/octet-stream，只能上传二进制文件，且没有键值对，一次只能上传一个文件, 也不能保存历史，每次选择文件，提交；</p><h1 id="传递List集合参数"><a href="#传递List集合参数" class="headerlink" title="传递List集合参数"></a>传递List集合参数</h1><h2 id="后端为-RequestParam"><a href="#后端为-RequestParam" class="headerlink" title="后端为@RequestParam"></a>后端为@RequestParam</h2><ol><li>在URL中传递参数, 类似get请求的参数</li></ol><p><img src="https://pic.downk.cc/item/5f2d689d14195aa5940508e6.jpg"></p><ol start="2"><li><p>在form-data中传递参数</p><p><img src="https://pic.downk.cc/item/5f2d68e314195aa594052537.jpg"></p></li></ol><h2 id="后端为-RequestBody"><a href="#后端为-RequestBody" class="headerlink" title="后端为@RequestBody"></a>后端为@RequestBody</h2><p><img src="https://pic.downk.cc/item/5f2d697514195aa594055da1.jpg"></p><p>注意, 不能是如下写法:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;userIdList&quot;</span>: [<span class="number">90</span>,<span class="number">91</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同时传递List和其他类型的参数"><a href="#同时传递List和其他类型的参数" class="headerlink" title="同时传递List和其他类型的参数"></a>同时传递List和其他类型的参数</h1><p>比如同时传递List<Integer>和String参数, 可以使用Map集合来接收</Integer></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@RequestBody</span> HashMap&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = (List&lt;Integer&gt;)map.get(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postman在row中这样写</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [<span class="number">90</span>,<span class="number">91</span>], </span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;str&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不能这样去写, 接收不到参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Long&gt; userIdList, <span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [<span class="number">90</span>,<span class="number">91</span>], </span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;str&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Postman测试文件下载接口"><a href="#Postman测试文件下载接口" class="headerlink" title="Postman测试文件下载接口"></a>Postman测试文件下载接口</h1><p><img src="https://pic.downk.cc/item/5f2d6a0b14195aa5940595d6.jpg"></p><h1 id="Postman传递token参数"><a href="#Postman传递token参数" class="headerlink" title="Postman传递token参数"></a>Postman传递token参数</h1><h2 id="设置token为环境变量"><a href="#设置token为环境变量" class="headerlink" title="设置token为环境变量"></a>设置token为环境变量</h2><p>需求: 登录之后, 服务器返回给前端一个token, 在每次访问接口时都要携带token参数</p><ol><li>首先测试获取token的接口得到返回的token</li></ol><p><img src="https://pic.downk.cc/item/5f2ac0c114195aa5940a226e.jpg"></p><ol start="2"><li><p>将token放到postman的全局变量中, 之后每次测试接口的时候postman会自动带上它</p><p><img src="https://pic.downk.cc/item/5f2ac17614195aa5940a84cb.jpg"></p></li></ol><p>   <img src="https://pic.downk.cc/item/5f2ac1aa14195aa5940a9e72.jpg"></p><p>添加完成之后, 回到测试接口页面</p><ol start="3"><li><p>在接口对应的 <strong>Test</strong> 接口中, 添加以下代码</p><p><img src="https://pic.downk.cc/item/5f2ac29614195aa5940b1961.jpg"></p></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">var data = JSON.parse(responseBody);</span><br><span class="line">if (data.data.token) &#123;</span><br><span class="line">   tests[&quot;Body has token&quot;] = true;</span><br><span class="line">   postman.setEnvironmentVariable(&quot;token&quot;, data.data.token);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  tests[&quot;Body has token&quot;] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是设置刚才设置的全局变量</p><div class="note info">            <p>但是这里需要注意的是，data.token是和刚刚的返回token接口的返回结果中token的位置有关的</p>          </div><p> 如果返回结果中token位置为： </p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;Success&quot;</span>,</span><br><span class="line">   “data” :&#123; &quot;token&quot;:     &quot;QkxJVEtMUHhaU1NCRU1uRFM0SG1tZlVPS0JWR3FzcGJ3Vm9GMXBTOGlpdz06YWRtaW46NjM2ODI0NTE5MzAwODY3MDAw&quot;&#125;</span><br><span class="line">    &quot;username&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;The token was successfully generated with a valid time of 30 minutes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 那么代码就要写成 </p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">var data = JSON.parse(responseBody);</span><br><span class="line">if (data.token) &#123;</span><br><span class="line">  tests[&quot;Body has token&quot;] = true;</span><br><span class="line">   postman.setEnvironmentVariable(&quot;token&quot;, data.token);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  tests[&quot;Body has token&quot;] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>之后再一次请求返回token的接口, 如果没有错误的话, 会在如下位置看到postman已经为我们自动配置好了返回的token的值</li></ol><p><img src="https://pic.downk.cc/item/5f2ac3f414195aa5940bc71a.jpg"></p><ol start="5"><li>配置好之后, 在需要携带token的接口中配置Header</li></ol><p><img src="https://pic.downk.cc/item/5f2ac43614195aa5940be900.jpg"></p><p>这样就可以携带token来请求接口啦</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><p> 定义一个xxx，获取body中返回的所有参数,并转化为JSON格式 var xxx = JSON.parse(responseBody); </p><p> 把json字符串转化为对象。parse()会进行json格式的检查是一个安全的函数， 如：检查json中某个数组元素的个数 (这里检测programs的长度) </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; JSON.parse(responseBody);</span><br><span class="line">tests[&quot;program&#39;s lenght&quot;] &#x3D; data.programs.length &#x3D;&#x3D;&#x3D; 5;</span><br></pre></td></tr></table></figure><p>将返回中的值设置为一个环境变量  <code>pm.environment.set(&quot;key&quot;,xxx.data.value);</code>或者<code>postman.setEnvironmentVariable(&quot;key&quot;, &quot;value&quot;);</code></p><p>将返回中的值设置为一个全局变量，<code>pm.globals.set(&quot;key&quot;,xxx.data.value);</code>或者<code>postman.setGlobalVariable(&quot;key&quot;, &quot;value&quot;);</code></p><div class="note info">            <p>注意：Global后面不能加s，value值一定要指定到某个具体节点</p>          </div><h2 id="tests方法"><a href="#tests方法" class="headerlink" title="tests方法"></a>tests方法</h2><p> 在postman里，内置了一些常用的test方法： </p><p><img src="https://pic.downk.cc/item/5f2cb2d214195aa594b97af8.jpg"></p><p>其他常用方法</p><ol><li><p>测试response Headers中的某个元素是否存在 <code>tests[&quot;元素Content-Type是否存在&quot;] = postman.getResponseHeader(&quot;Content-Type&quot;);</code></p><p>//getResponseHeader()方法会返回header的值；</p></li></ol><p>定义一个xxx，获取headers值    <code>var.xxx = postman.getResponseHeader(&quot;key&quot;);</code></p><p>将Headers中的值设置为一个环境变量  <code>postman.setEnvironmentVariable(&quot;key&quot;,xxx);或者pm.environment.set(&quot;key&quot;,xxx);</code></p><ol start="2"><li><p>检查response的code值是否为200    <code>tests[&quot;Status code is 200&quot;] = responseCode.code === 200;</code></p><p>//    tests[“Status code is 200”]中的tests 是一个内置对象，</p></li></ol><p>​    tests[“Status code is 200”]是指为这个断言起个名称叫”Status code is 200”，这个名称可以自行修改。</p><p>​    responseCode.code === 200中的responseCode是内置对象，responseCode对象中有个属性是code，是指HTTP状态码的code，判断code是否为200.</p><p>​    综合起来，这句代码的意思是：名称为”Status code is 200”的断言中，判断responseCode对象的code属性值（HTTP状态码）是否为200。</p><ol start="3"><li><p>检查response的body中是否包含字符串    <code>tests[&quot;Body matches string&quot;] = responseBody.has(&quot;type&quot;);</code></p><p>//    tests[“Body matches string”]中的tests是一个内置对象，</p></li></ol><p>​    tests[“Body matches string”]是指为这个断言起个名称叫”Body matches string”，这个名称可以自行修改。</p><p>​    这句代码的意思是：名称为”Body matches string”的断言中判断响应正文中是否包含：type这个字段。type无论是key或者value，只要匹配就可以。多个类型可用“，”分割。</p><ol start="4"><li><p>检查Response Body是否等于字符串    <code>tests[&quot;测试点&quot;] = responseBody === &quot;Response Body返回的内容&quot;;</code></p><p>//这个可以用在接口返回内容为纯字符串时，直接检查整个返回结果的正确性</p></li></ol><ol start="5"><li>检查Response time 是否小于200ms    <code>tests[&quot;Response time 小于200毫秒&quot;] = responseTime &lt; 200;</code></li></ol><p>​    检查Response time 是否大于200ms    <code>tests[&quot;Response time 大于200毫秒&quot;] = responseTime &gt; 200;</code></p><ol start="6"><li><code>postman.setNextRequest(&#39;Request 4&#39;)</code></li></ol><p>//    postman.setNextRequest()是一个带有一个参数的函数，它是接下来要运行的请求的名称或ID。往往用来跳转至某个接口，只在运行该集合时有用，单独运行无效</p><ol start="7"><li><p><code> var jsonObject = xml2Json(responseBody);</code></p><p>//转换XML body为JSON对象</p></li></ol><ol start="8"><li><p>设置一个随机数变量    <code>pm.globals.set(&quot;type&quot;,parseInt(4*Math.random())+1);</code></p><p>//针对不同类型的课程类型，设置一个1到4的随机整数，字段名是type,parselnt 是强制转换为整数</p></li></ol><ol start="9"><li><p>校验接口返回是否有数据    <code>tests[&quot;获取第一个结果&quot;] = xxx.content.jieguo[0];</code></p><p>//我的程序设置的是如果当前没有数据，则只返回content[]，所以这句断言可以校验，如果content里还有数据，则视为返回不为空</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;请求区域介绍&quot;&gt;&lt;a href=&quot;#请求区域介绍&quot; class=&quot;headerlink&quot; title=&quot;请求区域介绍&quot;&gt;&lt;/a&gt;请求区域介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f2e06f514195aa594
      
    
    </summary>
    
    
      <category term="Postman" scheme="http://yoursite.com/categories/Postman/"/>
    
    
      <category term="Postman" scheme="http://yoursite.com/tags/Postman/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用SpringBoot完成文件的下载</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8SpringBoot%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8SpringBoot%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-08-03T14:24:39.000Z</published>
    <updated>2020-08-03T14:45:52.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件下载源代码"><a href="#文件下载源代码" class="headerlink" title="文件下载源代码"></a>文件下载源代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.slf4j.LoggerFactory.getLogger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(tags = &quot;下载文件&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download_excel_template&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadFile</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;file/七星区人事信息模板.xlsx&quot;</span>);</span><br><span class="line">            File file = resource.getFile();</span><br><span class="line">            String filename = resource.getFilename();</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//强制下载不打开</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            <span class="comment">//使用URLEncoder来防止文件名乱码或者读取错误</span></span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span>+ URLEncoder.encode(filename, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//当不写上一行代码时, 浏览器读到有后缀的文件时会尝试打开；即使下载也会命名为file。</span></span><br><span class="line">            <span class="comment">//加上设置大小下载下来的.xlsx文件打开时才不会报“Excel 已完成文件级验证和修复。此工作簿的某些部分可能已被修复或丢弃”</span></span><br><span class="line">            response.addHeader(<span class="string">&quot;Content-Length&quot;</span>, String.valueOf(file.length()));</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000000</span>];</span><br><span class="line">            <span class="keyword">while</span> (b != -<span class="number">1</span>) &#123;</span><br><span class="line">                b = inputStream.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(b!=-<span class="number">1</span>) out.write(buffer, <span class="number">0</span>, b);</span><br><span class="line">            &#125;</span><br><span class="line">            LOG.info(<span class="string">&quot;下载模板Excel成功&quot;</span>);</span><br><span class="line"><span class="comment">//            return new Response(200, &quot;下载成功&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"><span class="comment">//            return new Response(&quot;下载失败, 请重新下载&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">            out.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>如果下载方法有返回值的话, 会报错</p><p> <code>rg.springframework.http.converter.HttpMessageNotWritableException: No converter for [class java.lang.Boolean] with preset Content-Type &#39;application/octet-stream;charset=UTF-8&#39; </code></p><p><code>java.lang.IllegalStateException: Cannot call sendError() after the response has been committed</code></p><p>解决方法是去掉返回值, 或者return null;</p>          </div><h1 id="文件下载总结"><a href="#文件下载总结" class="headerlink" title="文件下载总结"></a>文件下载总结</h1><p>在文件下载功能中，一般都会借助于这两个 header 来达到效果，那么两个 header 的具体作用是什么呢？</p><ul><li>Content-Type：告诉浏览器当前的响应体是个什么类型的数据。当其为 application/octet-stream 的时候，就说明 body 里面是一堆不知道是啥的二进制数据。</li><li>Content-Disposition：用于向浏览器提供一些关于如何处理响应内容的额外的信息，同时也可以附带一些其它数据，比如在保存响应体到本地的时候应该使用什么样的文件名。</li></ul><p>细想一下， Content-Type 好像对于文件下载没什么作用？事实上的确如此。可是再想一下，如果浏览器不理会 Content-Disposition ，不下载文件怎么办？如果此时提供了 Content-Type ,至少浏览器还有机会根据具体的 Content-Type 对响应体进行处理。</p><p>可是为什么浏览器会不理会 Content-Disposition 呢？因为这个 Content-Disposition 头部并不是 HTTP 标准中的内容，只是被浏览器广泛实现的一个 header 而已。</p><p>话题转一转， Content-Disposition 的语法见<a href="https://tools.ietf.org/html/rfc6266#section-4.1">此处</a>，其中相对重要的点此处罗列一下：</p><ul><li>常用的 disponsition-type 有 <code>inline</code> 和 <code>attachment</code> ：<ul><li>inline：建议浏览器使用默认的行为处理响应体。</li><li>attachment：建议浏览器将响应体保存到本地，而不是正常处理响应体。</li></ul></li><li>Content-Disposition 中可以传入 filename 参数，有两种形式：<ul><li>filename=yourfilename.suffix：直接指明文件名和后缀。</li><li>filename*=utf-8’’yourfilename.suffix：指定了文件名编码。其中，编码后面那对单引号中还可以填入内容，此处不赘述，可参考<a href="https://tools.ietf.org/html/rfc6266">规范</a>。</li><li>有些浏览器不认识 <code>filename*=utf-8&#39;&#39;yourfilename.suffix</code> （估计因为这东西比较复杂），所以最好带上 <code>filename=yourfilename.suffix</code> 。</li></ul></li></ul><h1 id="使用PostMan测试文件下载接口"><a href="#使用PostMan测试文件下载接口" class="headerlink" title="使用PostMan测试文件下载接口"></a>使用PostMan测试文件下载接口</h1><p><img src="https://pic.downk.cc/item/5f2822dc14195aa594005455.jpg"></p><p>配不配置Header皆可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件下载源代码&quot;&gt;&lt;a href=&quot;#文件下载源代码&quot; class=&quot;headerlink&quot; title=&quot;文件下载源代码&quot;&gt;&lt;/a&gt;文件下载源代码&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="文件下载" scheme="http://yoursite.com/categories/SpringBoot/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="文件下载" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>使用EasyExcel导出Excel文件</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-03T12:37:13.000Z</published>
    <updated>2020-08-07T05:21:20.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最简单的写"><a href="#最简单的写" class="headerlink" title="最简单的写"></a>最简单的写</h1><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ColumnWidth;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ContentRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.HeadRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.metadata.BaseRowModel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ContentRowHeight(15)</span> <span class="comment">//设定每一行的高度,不包含表头</span></span><br><span class="line"><span class="meta">@HeadRowHeight(30)</span>  <span class="comment">//设置 表头 高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelData</span> <span class="keyword">extends</span> <span class="title">BaseRowModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@ColumnWidth(15)</span>  <span class="comment">//列宽</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ColumnWidth(15)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;出生日期&quot;)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span> <span class="comment">// &quot;yyyy/MM/dd&quot; &quot;yyyy年MM月dd日HH时mm分ss秒&quot; 等等格式都可以</span></span><br><span class="line">    <span class="keyword">private</span> String birth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnWidth(15)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;工资&quot;)</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;.##&quot;)</span>  <span class="comment">//#代表任意数字, 注意这里的日期格式和数字格式都必须是字符串类型的</span></span><br><span class="line">    <span class="keyword">private</span> String salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定写入的列"><a href="#指定写入的列" class="headerlink" title="指定写入的列"></a>指定写入的列</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/553000/1584454018383-00194644-06a8-4e89-9d2f-99005652d4d4.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;字符串标题&quot;, index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;日期标题&quot;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里设置3 会导致第二列空的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;数字标题&quot;, index = 3)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂头写入"><a href="#复杂头写入" class="headerlink" title="复杂头写入"></a>复杂头写入</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/553000/1584454030244-62eccf86-d33b-4dac-93ec-397821957565.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexHeadData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;字符串标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;日期标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;数字标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="EasyExcelUtil"><a href="#EasyExcelUtil" class="headerlink" title="EasyExcelUtil"></a>EasyExcelUtil</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.EasyExcel;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.support.ExcelTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.write.metadata.style.WriteCellStyle;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.write.metadata.style.WriteFont;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.write.style.HorizontalCellStyleStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.HorizontalAlignment;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.IndexedColors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 版本2.1.7 工具类(仅导出)中可自定义样式格式等</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyExcelUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出 Excel ：一个 sheet，带表头.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据 list，每个元素为一个 BaseRowModel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName  导出的文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName 导入文件的 sheet 名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model     映射实体类，Excel 模型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExcel</span><span class="params">(HttpServletResponse response, List&lt;? extends Object&gt; data, String fileName, String sheetName, Class model)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头的策略</span></span><br><span class="line">        WriteCellStyle headWriteCellStyle = <span class="keyword">new</span> WriteCellStyle();</span><br><span class="line">        <span class="comment">//设置表头居中对齐</span></span><br><span class="line">        headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        <span class="comment">// 颜色</span></span><br><span class="line">        headWriteCellStyle.setFillForegroundColor(IndexedColors.PALE_BLUE.getIndex());</span><br><span class="line">        WriteFont headWriteFont = <span class="keyword">new</span> WriteFont();</span><br><span class="line">        headWriteFont.setFontHeightInPoints((<span class="keyword">short</span>) <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 字体</span></span><br><span class="line">        headWriteCellStyle.setWriteFont(headWriteFont);</span><br><span class="line">        headWriteCellStyle.setWrapped(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 内容的策略</span></span><br><span class="line">        WriteCellStyle contentWriteCellStyle = <span class="keyword">new</span> WriteCellStyle();</span><br><span class="line">        <span class="comment">//设置内容靠中对齐</span></span><br><span class="line">        contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        <span class="comment">// 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现</span></span><br><span class="line">        HorizontalCellStyleStrategy horizontalCellStyleStrategy = <span class="keyword">new</span> HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);</span><br><span class="line">        <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">        EasyExcel.write(getOutputStream(fileName, response), model).excelType(ExcelTypeEnum.XLSX).sheet(sheetName).registerWriteHandler(horizontalCellStyleStrategy)</span><br><span class="line">                <span class="comment">//最大长度自适应 目前没有对应算法优化 建议注释掉不用 会出bug</span></span><br><span class="line"><span class="comment">//                .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())</span></span><br><span class="line">                .doWrite(data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出文件时为Writer生成OutputStream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> OutputStream <span class="title">getOutputStream</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileName = URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;public&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">            response.addHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;导出excel表格失败!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(tags = &quot;数据导出--Excel&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/export&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EasyExcelUtil excelUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;数据导出&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/exportExcel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportSysSystemExcel</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询总数并封装相关变量</span></span><br><span class="line">            Integer totalRowCount = (<span class="keyword">int</span>) userMapper.selectNormalUserCount();</span><br><span class="line">            Integer pageSize = ExcelConstant.PER_WRITE_ROW_COUNT;</span><br><span class="line">            Integer writeCount = totalRowCount % pageSize == <span class="number">0</span> ? (totalRowCount / pageSize) : (totalRowCount / pageSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; writeCount; i++) &#123;</span><br><span class="line">                List&lt;List&lt;String&gt;&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//查询并封装数据</span></span><br><span class="line">                PageHelper.startPage(i + <span class="number">1</span>, pageSize);</span><br><span class="line"></span><br><span class="line">                List&lt;User&gt; userList = userMapper.selectNormalUser();</span><br><span class="line">                <span class="keyword">if</span> (!CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">                    userList.forEach(item -&gt; &#123;</span><br><span class="line">                        dataList.add(Arrays.asList(</span><br><span class="line">                                user.getBirthday() == <span class="keyword">null</span>? <span class="string">&quot;无&quot;</span> : user.getBirthday(),</span><br><span class="line">                                user.getBirthday() == <span class="keyword">null</span>? <span class="string">&quot;无&quot;</span> : user.getBirthday(),</span><br><span class="line">                                user.getSalary() == <span class="keyword">null</span>? <span class="string">&quot;无&quot;</span> : user.getSalary()</span><br><span class="line">                        ));</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                excelUtil.writeExcel(response, dataList, <span class="string">&quot;文件名称&quot;</span>, <span class="string">&quot;sheet1&quot;</span>, ExcelData.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用阿里的开源框架实现导出Excel的功能
    
    </summary>
    
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="EasyExcel" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/EasyExcel/"/>
    
    
      <category term="EasyExcel" scheme="http://yoursite.com/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>使用EasyExcel导入Excel文件</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%85%A5Excel%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%85%A5Excel%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-03T08:10:34.000Z</published>
    <updated>2020-09-12T03:10:44.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里开源EXCEL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Excel实体类"><a href="#Excel实体类" class="headerlink" title="Excel实体类"></a>Excel实体类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ColumnWidth;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ContentRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.HeadRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.metadata.BaseRowModel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelData</span> <span class="keyword">extends</span> <span class="title">BaseRowModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;职务&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String postName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;籍贯&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String birthPlace;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;出生日期&quot;)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span> <span class="comment">// &quot;yyyy/MM/dd&quot; &quot;yyyy年MM月dd日HH时mm分ss秒&quot; 等等格式都可以</span></span><br><span class="line">    <span class="keyword">private</span> String birth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;工资&quot;)</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;.##&quot;)</span>  <span class="comment">//#代表任意数字, 注意这里的日期格式和数字格式都必须是字符串类型的</span></span><br><span class="line">    <span class="keyword">private</span> String salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@ExcelProperty(value = String[], index = int):<br>设置表头信息<br>value: 表名称<br>index: 列号</li></ol><div class="note warning">            <p>可以根据名字或者Index去匹配。当然也可以不写，默认第一个字段就是index=0，以此类推。千万注意，要么全部不写，要么全部用index，要么全部用名字去匹配。千万别三个混着用，除非你非常了解源代码中三个混着用怎么去排序的。 </p>          </div><p><code>ExcelIgnore</code> 默认所有字段都会和excel去匹配，加了这个注解会忽略该字段</p><ol start="2"><li><p><strong>DateTimeFormat</strong> 日期转换，用<code>String</code>去接收excel日期格式的数据会调用这个注解。里面的value参照<code>java.text.SimpleDateFormat</code></p></li><li><p><strong>ExcelIgnoreUnannotated</strong>  默认不加<code>ExcelProperty</code> 的注解的都会参与读写，加了不会参与</p></li><li><p><strong>NumberFormat</strong>  数字转换，用<code>String</code>去接收excel数字格式的数据会调用这个注解。里面的value参照<code>java.text.DecimalFormat</code></p></li></ol><h1 id="监听器-每读取一行都会调用invoke方法"><a href="#监听器-每读取一行都会调用invoke方法" class="headerlink" title="监听器(每读取一行都会调用invoke方法)"></a>监听器(每读取一行都会调用invoke方法)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glriverside.qixing.personnel.listener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 *** 重点</span></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.config.ErrorMsg;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.common.ExcelData;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.model.Education;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.model.Post;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.model.User;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.EducationService;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.PostService;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.UserPostService;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.slf4j.LoggerFactory.getLogger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析监听器，</span></span><br><span class="line"><span class="comment"> * 每解析一行会回调invoke()方法。</span></span><br><span class="line"><span class="comment"> * 整个excel解析结束会执行doAfterAllAnalysed()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelListener</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_COUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储错误信息的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ErrorMsg&gt; errorMsgList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法传递spring(目的是传递需要的参数进来)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelListener</span><span class="params">(UserService userService, List&lt;ErrorMsg&gt; errorMsgList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">        <span class="keyword">this</span>.errorMsgList = errorMsgList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义存储表格数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义存储标题结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T titleMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(T result, AnalysisContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前行号</span></span><br><span class="line">        Integer rowIndex = context.readRowHolder().getRowIndex();</span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.titleMap = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据存储到list，供批量处理，或后续自己业务逻辑处理。</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExcelData)</span><br><span class="line">            &#123;</span><br><span class="line">                ExcelData excelData = (ExcelData)result;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> nameLength = excelData.getUserName().length();</span><br><span class="line">                <span class="keyword">if</span>(excelData.getUserName() != <span class="keyword">null</span> &amp;&amp; nameLength &lt; <span class="number">5</span> &amp;&amp; nameLength &gt; <span class="number">1</span>)</span><br><span class="line">                    user.setName(excelData.getUserName());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (excelData.getUserName() == <span class="keyword">null</span> )&#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;数据为空! 第&#123;&#125;行, userName&quot;</span>, rowIndex);</span><br><span class="line">                    errorMsgList.add(<span class="keyword">new</span> ErrorMsg(rowIndex, <span class="string">&quot;姓名为空&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                userService.addUser(user, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">&quot;解析数据第&#123;&#125;行，数据为：&#123;&#125;&quot;</span>, rowIndex, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;导入Excel完成&quot;</span>);</span><br><span class="line">        saveData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, list.size());</span><br><span class="line">        demoDAO.save(list);</span><br><span class="line">        LOG.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取表头数据-需要的话在监听器中重写此方法即可"><a href="#读取表头数据-需要的话在监听器中重写此方法即可" class="headerlink" title="读取表头数据(需要的话在监听器中重写此方法即可)"></a>读取表头数据(需要的话在监听器中重写此方法即可)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里会一行行的返回头</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> headMap</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;解析到一条头数据:&#123;&#125;&quot;</span>, JSON.toJSONString(headMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h1><h2 id="读取单个Sheet"><a href="#读取单个Sheet" class="headerlink" title="读取单个Sheet"></a>读取单个Sheet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/import&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/importExcel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importExcel</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExcelListener excelListener = <span class="keyword">new</span> ExcelListener&lt;ExcelData&gt;();</span><br><span class="line"></span><br><span class="line">            EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream()),excelListener).head(ExcelData.class).sheet().doReadSync();</span><br><span class="line">            <span class="comment">//其他写法</span></span><br><span class="line">            <span class="comment">//EasyExcel.read(new BufferedInputStream(file.getInputStream()), ExcelData.class, excelListener).sheet().doReadSync();</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取多个Sheet"><a href="#读取多个Sheet" class="headerlink" title="读取多个Sheet"></a>读取多个Sheet</h2><h3 id="一次性读取"><a href="#一次性读取" class="headerlink" title="一次性读取"></a>一次性读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream()), ExcelData.class, excelListener).doReadAll();</span><br><span class="line">                        </span><br><span class="line"><span class="comment">//其他写法</span></span><br><span class="line">EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream()),excelListener).head(ExcelData.class).doReadAll();</span><br></pre></td></tr></table></figure><h3 id="分批读取"><a href="#分批读取" class="headerlink" title="分批读取"></a>分批读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/import&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/importExcel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importExcel</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        ExcelReader excelReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excelReader = EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream())).build();</span><br><span class="line"></span><br><span class="line">            ReadSheet readSheet1 =</span><br><span class="line">                    EasyExcel.readSheet(<span class="number">0</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> ExcelListener()).build();</span><br><span class="line">            <span class="comment">//其他写法</span></span><br><span class="line">            ReadSheet readSheet2 =</span><br><span class="line">                    EasyExcel.readSheet(<span class="number">1</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> ExcelListener()).build();</span><br><span class="line">            <span class="comment">// 这里注意 一定要把sheet1 sheet2 一起传进去，不然有个问题就是03版的excel 会读取多次，浪费性能</span></span><br><span class="line">            excelReader.read(readSheet1, readSheet2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(e.getMessage(),e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (excelReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">                excelReader.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式重构监听器-增加监听器的可扩展性"><a href="#Lambda表达式重构监听器-增加监听器的可扩展性" class="headerlink" title="Lambda表达式重构监听器(增加监听器的可扩展性)"></a>Lambda表达式重构监听器(增加监听器的可扩展性)</h1><p><img src="https://pic.downk.cc/item/5f27fbd514195aa594f47a13.png"></p>]]></content>
    
    <summary type="html">
    
      使用阿里的开源框架实现导入Excel的功能
    
    </summary>
    
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="EasyExcel" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/EasyExcel/"/>
    
    
      <category term="EasyExcel" scheme="http://yoursite.com/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客插入图片的方法</title>
    <link href="http://yoursite.com/2020/08/03/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/03/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-03T07:37:45.000Z</published>
    <updated>2020-08-03T07:53:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客插入图片的方法"><a href="#Hexo博客插入图片的方法" class="headerlink" title="Hexo博客插入图片的方法"></a>Hexo博客插入图片的方法</h1><h2 id="绝对引用"><a href="#绝对引用" class="headerlink" title="绝对引用"></a>绝对引用</h2><p> 少量使用图片的时候使用, 将文件放在 <em>/source/images</em> 文件夹下, 使用 markdown 语法 <code>![Lena](/images/lena.png)</code> 可以实现图片显示, 但是这种引用在本地markdown 编辑器中会无法预览,因为相对路径不一致,找不到文件, 不过在首页内容和文章正文中都能正常显示,十分方便 </p><p><img src="/.com//1.jpg" alt="图片"></p><p> 但是存在一个问题,后续可能维护起来麻烦, 不知道哪里引用了哪个图片,导致文章删除但是图片仍在</p><h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><ol><li><p><strong>设置站点配置<code>_config.yml</code></strong>:将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code></p></li><li><p><strong>安装插件</strong>:<code>npm install https://github.com/CodeFalling/hexo-asset-image -- save</code></p></li><li><p><strong>运行<code>hexo new post &quot;aaa&quot;</code></strong>,生成aaa.md博文时就会在<code>/source/_posts</code>目录下生成aaa的文件夹，将你想在aaa博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。</p></li><li><p><strong>添加图片</strong>:在想添加的位置写入<code>![](aaa/图片名字.图片格式)</code>,例如<code>![](aaa/1.png)</code>。</p><p><img src="/.com//1.jpg" alt="图片"></p></li></ol><h2 id="在线引用"><a href="#在线引用" class="headerlink" title="在线引用"></a>在线引用</h2><p>如果要引用的图片已经存在于网络上, 直接引用该图片的地址即可</p><p>  <code>![百度图片--lena](http://images2018.cnblogs.com/blog/1003156/201806/1003156-20180604175546711-227291592.png )</code></p><p>如果不存在于网络上,  可以使用在线图床上传之后得到链接使用, </p><p>比如使用  <a href="https://sm.ms/">sm.ms</a></p>]]></content>
    
    <summary type="html">
    
      Hexo博客插入图片的几种方法
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/categories/Hexo/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>基于github pages + Hexo 搭建自己的博客</title>
    <link href="http://yoursite.com/2020/08/02/2020-8-2-%E5%9F%BA%E4%BA%8Egithub-pages-+-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/08/02/2020-8-2-%E5%9F%BA%E4%BA%8Egithub-pages-+-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2020-08-02T08:42:21.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h1><p> GitHub Page 是github网站提供给用户,  并可以用来托管个人的静态网站, 用它来搭建个人博客可以省去购买服务器, 配置域名等操作</p><h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><ol><li><p>首先, 注册一个github账号</p></li><li><p>注册完成之后, 首先在右上角个人头像的左侧, 点击加号, 选择 <strong>New repository</strong> </p></li></ol><p>跳转页面之后, 来到创建仓库页面</p><p><img src="https://i.loli.net/2020/08/02/L9FvgXYZRQa7GwO.png" alt="post1_1.png"></p><div class="note info">            <p>这里的仓库名一定要为 xxx.github.io, 其中xxx为你的github用户名, 且要以”.”来做分割</p><p>比如我的仓库名就为 nopoetry.github.io</p>          </div><p>勾选下边的” Initialize this repository with a README “</p><ol start="3"><li><p>创建好仓库之后, 找到仓库的最右边的Setting按钮</p><p> <img src="https://i.loli.net/2020/08/02/tbFkHjZ3ErB1vRV.png" alt="post_2.png"> </p></li></ol><p>点击之后拉到最下边, 找到Github Pages这一项配置</p><p> <img src="https://i.loli.net/2020/08/02/p7g5hJqdkzV3MSG.png" alt="post_3.png"> </p><p>如果显示这样的信息, 就说明github已经为你自动生成了属于你的网页, 点击即可访问</p><h1 id="搭建Hexo环境"><a href="#搭建Hexo环境" class="headerlink" title="搭建Hexo环境"></a>搭建Hexo环境</h1><h2 id="安装git-和Node-js"><a href="#安装git-和Node-js" class="headerlink" title="安装git 和Node.js"></a>安装git 和Node.js</h2><p>我们需要用git把hexo生成的博客网页推送到刚刚创建的github仓库中</p><p><a href="https://blog.csdn.net/sanxd/article/details/82624127">安装git教程</a></p><p><a href="https://www.cnblogs.com/minxiang-luo/p/12490526.html">安装Node.js教程</a></p><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><p> Hexo 是一个基于<a href="http://www.oschina.net/p/nodejs">node.js</a> 的静态博客网站生成器 </p><p>特点：</p><ul><li>不可思议的快速 ─ 只要一眨眼静态文件即生成完成</li><li>支持 <a href="http://daringfireball.net/projects/markdown/">Markdown</a></li><li>仅需一道指令即可部署到 <a href="http://pages.github.com/">GitHub Pages</a> 和 <a href="http://heroku.com/">Heroku</a></li><li>已移植 <a href="http://octopress.org/">Octopress</a> 插件</li><li>高扩展性、自订性</li><li>兼容于 Windows, Mac &amp; Linux</li></ul><p>首先在电脑中创建一个存放Hexo的文件夹</p><p>在该路径中打开cmd窗口</p><p>利用刚刚安装好的Node.js和npm安装Hexo</p><ol><li><p>输入npm install hexo-cli -g, 安装Hexo脚手架, 如果报错</p><p>则输入 npm install hexo-cli -g –force</p></li><li><p>输入hexo -v验证是否安装成功</p></li><li><p>输入hexo init, 初始化该文件夹的Hexo环境</p></li><li><p>输入npm install安装所需要的组件</p></li><li><p>输入npm g生成搭建博客需要的静态文件</p></li><li><p>输入npm s启动本地服务器, 启动成功后, 在浏览器中输入localhost:4000即可访问最原始的博客网站了</p><div class="note info">            <p>如果4000端口号被占用, 可以在_config.yml文件内加以下代码</p><p>server:</p><p>​    port: 4001(任意没被占用的端口号)</p><p>​    conpress: true</p><p>​    header: true</p>          </div></li></ol><h1 id="Hexo静态文件作用"><a href="#Hexo静态文件作用" class="headerlink" title="Hexo静态文件作用"></a>Hexo静态文件作用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。</span><br><span class="line"></span><br><span class="line">&gt;package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 --save 保存进去。</span><br><span class="line"></span><br><span class="line">&gt;scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;layout(布局)&gt; &lt;title&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。</span><br><span class="line"></span><br><span class="line">&gt;source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件下。</span><br><span class="line"></span><br><span class="line">&gt;public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用 </span><br><span class="line">&gt;hexo clean 清除 db.json 和 public 文件夹下的所有文件。</span><br><span class="line"></span><br><span class="line">&gt;themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。</span><br><span class="line"></span><br><span class="line">&gt;.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init &lt;folder&gt; 也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。</span><br></pre></td></tr></table></figure><p><strong>打开配置文档_config.yml，修改deploy值（在末尾）:</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:nopoetry/nopoetry.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>输入 npm install hexo-deployer-git –save  , 安装hexo上传到git的扩展工具</p><p>在博客文件夹的根目录下(也就是最开始你创建并安装Hexo的那个文件夹下), 打开cmd窗口或git bash窗口</p><p>打开后输入hexo new post “博客名”</p><p>这时文件夹source/_posts文件夹里会出现<strong>博客名.md</strong>的博客文章源文件</p><p>文件是<strong>markdown</strong>格式, 如果不想学习格式书写规范的话, 直接下载<strong>Typora</strong>这个软件就好了</p><p>如果使用Typora编辑工具, 在Typora写好博客内容后将文件复制粘贴到<strong>source/_posts</strong>文件夹下即可</p><p>编辑好博客内容后, 依次执行</p><p>hexo g 生成静态文件<br>hexo d 部署到Github Pages </p><p>完成后, 等待一段时间, 刷新博客网站即可看到自己的博客</p><h1 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h1><p>当然, 默认的博客主题着实是丑了点, 我们还可以在 <a href="https://hexo.io/themes/">Hexo官网</a> 上挑选好看的主题使用</p><p>一般来说被挑选为Hexo推荐的主题博客, 里边都会有对于该主题如何使用的教程</p><p>比如我们选择了<a href="https://demo.jerryc.me/">butterfly主题</a></p><p>在博客的根目录下打开cmd或git bash, 输入</p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/butterfly</p><p>clone完成后, 会保存在你博客目录的theme文件夹下, </p><p><img src="https://i.loli.net/2020/08/02/XSuxBhfZJAWPcjp.png" alt="post_4.png"></p><p>其中<strong>_config.yml</strong>就是该主题的配置文件, 我们可以根据主题的使用教程对该主题进行个性化配置</p><p>之后在<strong>博客的根目录</strong>下找到打开博客的配置文件<strong>_config.yml</strong></p><div class="note info">            <p>注意跟主题的配置文件进行区分</p>          </div><p>修改theme: landscape为</p><p>theme: butterfly</p><p>然后打开cmd或git bash 窗口, 清除之前的文件并重新生成和部署, 即可完成主题的切换</p><p>hexo clean(最好在每次上传博客或切换主题的 时候都clean一下)</p><p>hexo g</p><p>hexo d</p><p>如果完成上述操作之后, 打开博客网站只显示  </p><p>extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial </p><p>那么执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><p>执行完成之后再重新执行上述三条命令即可</p>]]></content>
    
    <summary type="html">
    
      使用github 和 Hexo 搭建不需要服务器和域名的博客网站
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="搭建博客教程" scheme="http://yoursite.com/categories/Hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
