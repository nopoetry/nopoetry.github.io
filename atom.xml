<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Li buyan Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-09T03:20:16.155Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Li buyan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>转载---并查集</title>
    <link href="http://yoursite.com/2020/08/09/%E8%BD%AC%E8%BD%BD-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/08/09/%E8%BD%AC%E8%BD%BD-%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-08-09T03:02:18.000Z</published>
    <updated>2020-08-09T03:20:16.155Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic.downk.cc/item/5f2f6ade14195aa594b8b439.png"></p><p><img src="https://pic.downk.cc/item/5f2f6b4114195aa594b8d882.png"></p><p><img src="https://pic.downk.cc/item/5f2f6b4114195aa594b8d884.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f2f6ade14195aa594b8b439.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f2f6b4114195aa594b8d882.pn
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="http://yoursite.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>转载---ThreadLocal的原理</title>
    <link href="http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-08T05:36:13.000Z</published>
    <updated>2020-08-08T06:27:32.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一针见血理解ThreadLocal类"><a href="#一针见血理解ThreadLocal类" class="headerlink" title="一针见血理解ThreadLocal类"></a><strong>一针见血理解ThreadLocal类</strong></h1><p><strong>ThreadLocal类具有两个维度：线程维度和变量维度。扔掉线程维度，保留并放大变量维度，虽然思想片面，但是给人的印象却是极深，才能用之出神入化。</strong> </p><p>ThreadLocal类是修饰变量的，<strong>重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了</strong>。很多开发语言在语言级别都提供这种作用域的变量类型。</p><p>根据变量的作用域，可以将变量分为全局变量，局部变量。简单的说，类里面定义的变量是全局变量，函数里面定义的变量是局部变量。</p><p>还有一种作用域是线程作用域，线程一般是跨越几个函数的。为了在几个函数之间共用一个变量，所以才出现：线程变量，这种变量在Java中就是ThreadLocal变量。</p><p>全局变量，范围很大；局部变量，范围很小。无论是大还是小，其实都是定死的。而线程变量，调用几个函数，则决定了它的作用域有多大。</p><p>ThreadLocal是跨函数的，虽然全局变量也是跨函数的，但是跨所有的函数，而且不是动态的。</p><p>ThreadLocal是跨函数的，但是跨哪些函数呢，由线程来定，更灵活。</p><p><a href="http://threadlocal.cn/"><strong>一针见血理解ThreadLocal类</strong> </a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>和Synchronized的区别</li><li>存储在jvm的哪个区域</li><li>真的只是当前线程可见吗</li><li>会导致内存泄漏么</li><li>为什么用Entry数组而不是Entry对象</li><li>你学习的开源框架哪些用到了ThreadLocal</li><li>ThreadLocal里的对象一定是线程安全的吗</li><li>笔试题</li></ol><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="官方术语"><a href="#官方术语" class="headerlink" title="官方术语"></a>官方术语</h2><p>ThreadLocal类是用来提供线程内部的局部变量。让这些变量在多线程环境下访问（get/set）时能保证各个线程里的变量相对独立于其他线程内的变量。</p><h2 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h2><p>ThreadLocal是一个关于创建线程局部变量的类。</p><p>通常情况下，我们创建的成员变量都是线程不安全的。因为他可能被多个线程同时修改，此变量对于多个线程之间彼此并不独立，是共享变量。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程无法访问和修改。也就是说：将线程公有化变成线程私有化。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>每个线程都需要一个独享的对象（比如工具类，典型的就是<code>SimpleDateFormat</code>，每次使用都new一个多浪费性能呀，直接放到成员变量里又是线程不安全，所以把他用<code>ThreadLocal</code>管理起来就完美了。）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: SimpleDateFormat就一份，不浪费资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TongWei.Chen 2020-07-10 14:00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest05</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStr</span><span class="params">(<span class="keyword">int</span> millisSeconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(millisSeconds);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                String date = dateToStr(j * <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 从结果中可以看出是线程安全的，时间没有重复的。</span></span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// java8的写法</span></span><br><span class="line"><span class="comment">//    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span></span><br><span class="line"><span class="comment">//            ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>细心的朋友已经发现了，这也是每个线程都创建一个<code>SimpleDateFormat</code>，跟直接在方法内部new没区别，错了，大错特错！1个请求进来是一个线程，他可能贯穿了N个方法，你这N个方法假设有3个都在使用<code>dateToStr()</code>，你直接new的话会产生三个<code>SimpleDateFormat</code>对象，而用<code>ThreadLocal</code>的话只会产生一个对象，一个线程一个。 </p>          </div><ul><li>每个线程内需要保存全局变量（比如在登录成功后将用户信息存到<code>ThreadLocal</code>里，然后当前线程操作的业务逻辑直接get取就完事了，有效的避免的参数来回传递的麻烦之处），一定层级上减少代码耦合度。 </li></ul><h1 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h1><h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><p>每个<code>Thread</code>对象中都持有一个<code>ThreadLocalMap</code>的成员变量。每个<code>ThreadLocalMap</code>内部又维护了N个<code>Entry</code>节点，也就是<code>Entry</code>数组，每个<code>Entry</code>代表一个完整的对象，key是<code>ThreadLocal</code>本身，value是<code>ThreadLocal</code>的泛型值。</p><p>核心源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Thread类里持有ThreadLocalMap的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java.lang.ThreadLocal有内部静态类ThreadLocalMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ThreadLocalMap内部有Entry类，Entry的key是ThreadLocal本身，value是泛型值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类关系图–-ThreadLocal内存结构图。"><a href="#类关系图–-ThreadLocal内存结构图。" class="headerlink" title="类关系图– ThreadLocal内存结构图。"></a>类关系图– ThreadLocal内存结构图。</h2><p><img src="https://pic.downk.cc/item/5f2e3ae414195aa594489736.png"></p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><ul><li><code>initialValue</code>：初始化。在<code>get</code>方法里懒加载的。</li><li><code>get</code>：得到这个线程对应的value。<em>如果调用get之前没set过，则get内部会执行<code>initialValue</code>方法进行初始化。</em></li><li><code>set</code>：为这个线程设置一个新值。</li><li><code>remove</code>：删除这个线程对应的值，防止内存泄露的最佳手段。</li></ul><h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a><code>initialValue</code></h3><h4 id="什么意思"><a href="#什么意思" class="headerlink" title="什么意思"></a>什么意思</h4><p>见名知意，初始化一些value（泛型值）。懒加载的。</p><h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>调用<code>get</code>方法之前没有调用<code>set</code>方法，则<code>get</code>方法内部会触发<code>initialValue</code>，也就是说<code>get</code>的时候如果没拿到东西，则会触发<code>initialValue</code>。</p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul><li>通常，每个线程最多调用一次此方法。但是如果已经调用了<code>remove()</code>，然后再次调用<code>get()</code>的话，则可以再次触发<code>initialValue</code>。</li><li>如果要重写的话一般建议采取匿名内部类的方式重写此方法，否则默认返回的是null。</li></ul><p>比如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Java8的高逼格写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected的含义就是交给子类干的。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><h4 id="什么意思-1"><a href="#什么意思-1" class="headerlink" title="什么意思"></a>什么意思</h4><p>获取当前线程下的ThreadLocal中的值。</p><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通过<code>threadLocalHashCode</code>来获取table[]中存放的Entry对象, 也就是ThreadLocal对象</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h3><h4 id="什么意思-2"><a href="#什么意思-2" class="headerlink" title="什么意思"></a>什么意思</h4><p>其实干的事和<code>initialValue</code>是一样的，都是set值，只是调用时机不同。set是想用就用，api摆在这里，你想用就调一下set方法。很自由。</p><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例，注意这里是将t传进去了，t是当前线程，就是说ThreadLocalMap是在线程里持有的引用。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h3><h4 id="什么意思-3"><a href="#什么意思-3" class="headerlink" title="什么意思"></a>什么意思</h4><p>将当前线程下的ThreadLocal的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</p><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 直接移除以当前ThreadLocal为key的value</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>为啥单独拿出来说下，我就是想强调一点：这个东西是归<code>Thread</code>类所有的。它的引用在<code>Thread</code>类里，这也证实了一个问题：<code>ThreadLocalMap</code>类内部为什么有<code>Entry</code>数组，而不是<code>Entry</code>对象？</p><p>因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为再说一次，<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p><p>核心源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在你调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span></span><br><span class="line"><span class="comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h1><h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地线程。Thread：线程。Local：本地</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始值，用来初始化值用的，比如：ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// 你想Integer value = count.get(); value++;这样是报错的，因为count现在还没值，取出来的是个null,所以你需要先重写此方法为value赋上初始值，本身方法是protected也代表就是为了子类重写的。</span></span><br><span class="line">    <span class="comment">// 此方法是一个延迟调用方法，在线程第一次调用get的时候才执行，下面具体分析源码就知道了。</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建ThreadLocalMap，ThreadLocal底层其实就是一个map来维护的。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回该当前线程对应的线程局部变量值。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取ThreadLocalMap</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置当前线程的线程局部变量的值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将当前线程局部变量的值删除，目的是为了减少内存占用。其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置初始值，调用initialValue</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 静态内部类，一个map来维护的！！！</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// ThreadLocalMap的静态内部类，继承了弱引用，这正是不会造成内存泄漏根本原因</span></span><br><span class="line">        <span class="comment">// Entry的key为ThreadLocal并且是弱引用。value是值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMap"><a href="#getMap" class="headerlink" title="getMap()"></a>getMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在你调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span></span><br><span class="line"><span class="comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map-set"><a href="#map-set" class="headerlink" title="map.set()"></a>map.set()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不多BB，就和HashMap的set一个道理，只是赋值key,value。</span></span><br><span class="line"><span class="comment">// 需要注意的是这里key是ThreadLocal对象，value是值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="createMap"><a href="#createMap" class="headerlink" title="createMap()"></a>createMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ThreadLocalMap对象。</span></span><br><span class="line"><span class="comment"> * t.threadLocals在上面的getMap中详细介绍了。此处不BB。</span></span><br><span class="line"><span class="comment"> * 实例化ThreadLocalMap并且传入两个值，一个是当前ThreadLocal对象一个是value。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ThreadLocalMap构造器。</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 重点看这里！！！！！！</span></span><br><span class="line">    <span class="comment">// new了一个ThreadLocalMap的内部类Entry，且将key和value传入。</span></span><br><span class="line">    <span class="comment">// key是ThreadLocal对象。</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 到这里朋友们应该真相大白了，其实ThreadLocal就是内部维护一个ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 而ThreadLocalMap内部又维护了一个Entry对象。Entry对象是key-value形式，</span></span><br><span class="line"><span class="comment"> * key是ThreadLocal对象，value是传入的value</span></span><br><span class="line"><span class="comment"> * 所以我们对ThreadLocal的操作其实都是对内部的ThreadLocalMap.Entry的操作</span></span><br><span class="line"><span class="comment"> * 所以保证了线程之前互不干扰。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用初始值方法，由子类提供。</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 获取到了</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// set</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 没获取到。创建map并赋值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回初始值。</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initialValue-1"><a href="#initialValue-1" class="headerlink" title="initialValue()"></a>initialValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。</span></span><br><span class="line"><span class="comment"> * 其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>只要捋清楚如下几个类的关系，<code>ThreadLocal</code>将变得so easy！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread&#96;、&#96;ThreadLocal&#96;、&#96;ThreadLocalMap&#96;、&#96;Entry</span><br></pre></td></tr></table></figure><p>一句话总结就是：<code>Thread</code>维护了<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>里维护了<code>Entry</code>，而<code>Entry</code>里存的是以<code>ThreadLocal</code>为key，传入的值为value的键值对。</p><h1 id="答疑（面试题）"><a href="#答疑（面试题）" class="headerlink" title="答疑（面试题）"></a>答疑（面试题）</h1><h2 id="如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"><a href="#如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？" class="headerlink" title="如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"></a>如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个ThreadLocal对象，都有一个final修饰的int型的threadLocalHashCode不可变属性，对于基本数据类型，可以认为它在初始化后就不可以进行修改，所以可以唯一确定一个ThreadLocal对象。<br>　　但是如何保证两个同时实例化的ThreadLocal对象有不同的threadLocalHashCode属性：在ThreadLocal类中，还包含了一个static修饰的AtomicInteger（[əˈtɒmɪk]提供原子操作的Integer类）成员变量（即类变量）和一个static final修饰的常量（作为两个相邻nextHashCode的差值）。由于nextHashCode是类变量，所以每一次调用ThreadLocal类都可以保证nextHashCode被更新到新的值，并且下一次调用ThreadLocal类这个被更新的值仍然可用，同时AtomicInteger保证了nextHashCode自增的原子性。</p><h3 id="为什么不直接用线程id来作为ThreadLocalMap的key？"><a href="#为什么不直接用线程id来作为ThreadLocalMap的key？" class="headerlink" title="为什么不直接用线程id来作为ThreadLocalMap的key？"></a>为什么不直接用线程id来作为ThreadLocalMap的key？</h3><p>　　这一点很容易理解，因为直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？<br>　　而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个ThreadLocal对象都可以由这个对象的名字唯一区分，所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。</p><h2 id="和Synchronized的区别"><a href="#和Synchronized的区别" class="headerlink" title="和Synchronized的区别"></a>和Synchronized的区别</h2><p>问：他和线程同步机制（如：Synchronized）提供一样的功能，这个很吊啊。</p><p>答：放屁！同步机制保证的是多线程同时操作共享变量并且能正确的输出结果。ThreadLocal不行啊，他把共享变量变成线程私有了，每个线程都有独立的一个变量。举个通俗易懂的案例：网站计数器，你给变量count++的时候带上synchronized即可解决。ThreadLocal的话做不到啊，他没发统计，他只能说能统计每个线程登录了多少次。</p><h2 id="存储在jvm的哪个区域"><a href="#存储在jvm的哪个区域" class="headerlink" title="存储在jvm的哪个区域"></a>存储在jvm的哪个区域</h2><p>问：线程私有，那么就是说ThreadLocal的实例和他的值是放到栈上咯？</p><p>答：不是。还是在堆的。ThreadLocal对象也是对象，对象就在堆。只是JVM通过一些技巧将其可见性变成了线程可见。</p><h2 id="真的只是当前线程可见吗"><a href="#真的只是当前线程可见吗" class="headerlink" title="真的只是当前线程可见吗"></a>真的只是当前线程可见吗</h2><p>问：真的只是当前线程可见吗？</p><p>答：貌似不是，貌似通过<code>InheritableThreadLocal</code>类可以实现多个线程访问<code>ThreadLocal</code>的值，但是我没研究过，知道这码事就行了。</p><h2 id="会导致内存泄漏么"><a href="#会导致内存泄漏么" class="headerlink" title="会导致内存泄漏么"></a>会导致内存泄漏么</h2><p>问：会导致内存泄漏么？</p><p>答：分析一下：</p><ul><li>1、<code>ThreadLocalMap.Entry</code>的key会内存泄漏吗？</li><li>2、<code>ThreadLocalMap.Entry</code>的value会内存泄漏吗？</li></ul><p>先看下key-value的核心源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 先看继承关系，发现是继承了弱引用，而且key直接是交给了父类处理<code>super(key)</code>，父类是个弱引用，所以key完全不存在内存泄漏问题，因为他不是强引用，它可以被GC回收的。 </p><div class="note info">            <p>弱引用的特点：如果这个对象只被弱引用关联，没有任何强引用关联，那么这个对象就可以被GC回收掉。弱引用不会阻止GC回收。这是jvm知识。 </p>          </div><p>看value，发现value是个强引用，但是想了下也没问题的呀，因为线程终止了，我管你强引用还是弱引用，都会被GC掉的，因为引用链断了（jvm用的可达性分析法，线程终止了，根节点就断了，下面的都会被回收）。</p><p>这么分析一点毛病都没有，但是忘了一个主要的角色，那就是<strong>线程池</strong>，线程池的存在核心线程是不会销毁的，只要创建出来他会反复利用，生命周期不会结束掉，但是key是弱引用会被GC回收掉，value强引用不会回收，所以形成了如下场面：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value</span><br></pre></td></tr></table></figure><p>由于value和Thread还存在链路关系，还是可达的，所以不会被回收，这样越来越多的垃圾对象产生却无法回收，早晨内存泄漏，时间久了必定OOM。</p><p>解决方案<code>ThreadLocal</code>已经为我们想好了，提供了<code>remove()</code>方法，这个方法是将value移出去的。所以用完后记得<code>remove()</code>。</p><h2 id="为什么用Entry数组而不是Entry对象"><a href="#为什么用Entry数组而不是Entry对象" class="headerlink" title="为什么用Entry数组而不是Entry对象"></a>为什么用Entry数组而不是Entry对象</h2><p> 这个其实主要想考<code>ThreadLocalMap</code>是在<code>Thread</code>里持有的引用。 </p><p>：<code>ThreadLocalMap</code>内部的table为什么是数组而不是单个对象呢？</p><p>答：因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p><h2 id="你学习的开源框架哪些用到了ThreadLocal"><a href="#你学习的开源框架哪些用到了ThreadLocal" class="headerlink" title="你学习的开源框架哪些用到了ThreadLocal"></a>你学习的开源框架哪些用到了ThreadLocal</h2><p>Spring框架。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DateTimeContextHolder</span><br><span class="line">RequestContextHolder</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal里的对象一定是线程安全的吗"><a href="#ThreadLocal里的对象一定是线程安全的吗" class="headerlink" title="ThreadLocal里的对象一定是线程安全的吗"></a>ThreadLocal里的对象一定是线程安全的吗</h2><p>未必，如果在每个线程中<code>ThreadLocal.set()</code>进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的<code>ThreadLocal.get()</code>获取的还是这个共享对象本身，还是有并发访问线程不安全问题。</p><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><p>问：下面这段程序会输出什么？为什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocalNpe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            set();</span><br><span class="line">            System.out.println(get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 目的就是为了让子线程先运行完</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line"> at com.chentongwei.study.thread.TestThreadLocalNpe.get(TestThreadLocalNpe.java:<span class="number">16</span>)</span><br><span class="line"> at com.chentongwei.study.thread.TestThreadLocalNpe.main(TestThreadLocalNpe.java:<span class="number">26</span>)</span><br></pre></td></tr></table></figure><p>为什么？</p><p>为什么输出个1，然后空指针了？</p><p>首先输出1是没任何问题的，其次主线程空指针是为什么？</p><p>如果你这里回答</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>那我恭喜你，你连<code>ThreadLocal</code>都不知道是啥，这明显两个线程，子线程和主线程。子线程设置1，主线程肯定拿不到啊，<code>ThreadLocal</code>和线程是嘻嘻相关的。这个不多费口舌。</p><p>说说为什么是空指针？</p><p>因为你get方法用的long而不是Long，那也应该返回null啊，大哥，long是基本类型，默认值是0，没有null这一说法。<code>ThreadLocal</code>里的泛型是Long，get却是基本类型，这需要拆箱操作的，也就是会执行<code>null.longValue()</code>的操作，这绝逼空指针了。</p><blockquote><p>看似一道Javase的基础题目，实则隐藏了很多知识。</p></blockquote><h1 id="ThreadLocal工具类"><a href="#ThreadLocal工具类" class="headerlink" title="ThreadLocal工具类"></a>ThreadLocal工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.duoku.base.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NamedThreadLocal;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TongWei.Chen 2019-09-09 18:35:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;xxx-threadlocal&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Maps.newHashMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getThreadLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        <span class="comment">// todo:copy a new one</span></span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,T defaultValue)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key) == <span class="keyword">null</span> ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Map&lt;String, Object&gt; keyValueMap)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h1><p> <strong>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</strong>。下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用： </p><p><img src="https://pic.downk.cc/item/5f2e405c14195aa5944ad13d.png"></p><p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。<br>　　<br>　　ThreadLocalMap设计时的对上面问题的对策：<br>ThreadLocalMap的getEntry函数的流程大概为：</p><ol><li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (table.length-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li><li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。否则，如果key值为null，则擦除该位置的Entry，并继续向下一个位置查询。在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。<br>　　但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</li></ol><p>即：<br>1.使用ThreadLocal，建议用static修饰 static ThreadLocal headerLocal = new ThreadLocal();<br>2.使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</p><h1 id="Java中的四种引用类型（强、软、弱、虚）"><a href="#Java中的四种引用类型（强、软、弱、虚）" class="headerlink" title="Java中的四种引用类型（强、软、弱、虚）"></a><strong>Java中的四种引用类型（强、软、弱、虚）</strong></h1><p> 从Java 1.2开始，JVM开发团队发现，单一的强引用类型，无法很好的管理对象在JVM里面的生命周期，垃圾回收策略过于简单，无法适用绝大多数场景。为了更好的管理对象的内存，更好的进行垃圾回收，JVM团队扩展了引用类型，从最早的强引用类型增加到强、软、弱、虚四个引用类型。 </p><p>Strong Rerence为JVM内部实现。其他三类引用类型全部继承自Reference父类。如下图所示：</p><p><img src="http://threadlocal.cn/static/image/reference.jpg?v=f25eecc290e57663c98198e92c1ac67a" alt="img"></p><h5 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h5><p>Strong Rerence这个类并不存在，默认的对象都是强引用类型，因为有后来的新引用所衬托，所以才起了个名字叫”强引用”。</p><p>强引用使用示例如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String web &#x3D; &quot;www.threadlocal.cn&quot;;</span><br></pre></td></tr></table></figure><p>如果JVM垃圾回收器 GC 可达性分析结果为可达，表示引用类型仍然被引用着，这类对象始终不会被垃圾回收器回收，即使JVM发生OOM也不会回收。而如果 GC 的可达性分析结果为不可达，那么在GC时会被回收。</p><h5 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h5><p>软引用是一种比强引用生命周期稍弱的一种引用类型。在JVM内存充足的情况下，软引用并不会被垃圾回收器回收，只有在JVM内存不足的情况下，才会被垃圾回收器回收。所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p><p>软引用使用示例如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference &#x3D; new SoftReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;));</span><br><span class="line">String web &#x3D; softReference.get();</span><br></pre></td></tr></table></figure><h5 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h5><p>弱引用是一种比软引用生命周期更短的引用。它的生命周期很短，不论当前内存是否充足，都只能存活到下一次垃圾收集之前。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; weakReference &#x3D; new WeakReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;));</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">if(weakReference.get() &#x3D;&#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;weakReference已经被GC回收&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>weakReference已经被GC回收</p><h5 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h5><p>虚引用与前面的几种都不一样，这种引用类型不会影响对象的生命周期，所持有的引用就跟没持有一样，随时都能被GC回收。</p><p>需要注意的是，在使用虚引用时，必须和引用队列关联使用。在对象的垃圾回收过程中，如果GC发现一个对象还存在虚引用，则会把这个虚引用加入到与之关联的引用队列中。</p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p><p>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象内存被回收之前采取必要的行动防止被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; phantomReference &#x3D; new PhantomReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;), new ReferenceQueue&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">System.out.println(phantomReference.get());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一针见血理解ThreadLocal类&quot;&gt;&lt;a href=&quot;#一针见血理解ThreadLocal类&quot; class=&quot;headerlink&quot; title=&quot;一针见血理解ThreadLocal类&quot;&gt;&lt;/a&gt;&lt;strong&gt;一针见血理解ThreadLocal类&lt;/stro
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>PostMan的使用方法</title>
    <link href="http://yoursite.com/2020/08/05/Postman%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/05/Postman%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-05T14:09:55.000Z</published>
    <updated>2020-08-08T01:59:40.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求区域介绍"><a href="#请求区域介绍" class="headerlink" title="请求区域介绍"></a>请求区域介绍</h1><p><img src="https://pic.downk.cc/item/5f2e06f514195aa594353825.jpg"></p><p><strong>1</strong>  <strong>Authorization：</strong>身份验证，主要用来填写用户名密码，以及一些验签字段,postman有一个helpers可以帮助我们简化一些重复和复杂的任务。当前的一套helpers可以帮助你解决一些authentication protocols的问题。；</p><p><strong>2</strong>  <strong>Headers：</strong>请求的头部信息</p><p><strong>3</strong>  <strong>Body：</strong>post请求时必须要带的参数，里面放一些key-value键值对</p><p><strong>4</strong>  **Pre-requerst Script:**可以让你在 请求之前自定义请求数据，这个运行在请求之前，语法使用JavaScript语句。</p><p><strong>5</strong>  <strong>tests：</strong>tests标签功能比较强大，通常用来写测试，它是运行在请求之后。支持JavaScript语法。postman每次执行request的时候，会执行tests。测试结果会在tests的tab上面显示一个通过的数量以及对错情况。这个后面会进行详解，它也可以用来设计用例，比如要测试返回结果是否含有某一字符串</p><p><strong>6</strong>  <strong>form-data</strong>：,它将表单数据处理为一条消息，以标签为单元，用分隔符分开。既可以单独上传键值对，也可以直接上传文件（当上传字段是文件时，会有Content-Type来说明文件类型,但该文件不会作为历史保存，只能在每次需要发送请求的时候，重新添加文件。）；post请求里<strong>较常用的一种</strong></p><p><strong>7</strong>  <strong>x-www-form-urlencoded</strong>：对应信息头-application/x-www-from-urlencoded，会将表单内的数据转换为键值对；</p><p><strong>8</strong>  <strong>raw</strong>：可以上传任意类型的文本，比如text、json、xml等,所有填写的text都会随着请求发送；</p><p><strong>9</strong>  <strong>binary</strong>：对应信息头-Content-Type:application/octet-stream，只能上传二进制文件，且没有键值对，一次只能上传一个文件, 也不能保存历史，每次选择文件，提交；</p><h1 id="传递List集合参数"><a href="#传递List集合参数" class="headerlink" title="传递List集合参数"></a>传递List集合参数</h1><h2 id="后端为-RequestParam"><a href="#后端为-RequestParam" class="headerlink" title="后端为@RequestParam"></a>后端为@RequestParam</h2><ol><li>在URL中传递参数, 类似get请求的参数</li></ol><p><img src="https://pic.downk.cc/item/5f2d689d14195aa5940508e6.jpg"></p><ol start="2"><li><p>在form-data中传递参数</p><p><img src="https://pic.downk.cc/item/5f2d68e314195aa594052537.jpg"></p></li></ol><h2 id="后端为-RequestBody"><a href="#后端为-RequestBody" class="headerlink" title="后端为@RequestBody"></a>后端为@RequestBody</h2><p><img src="https://pic.downk.cc/item/5f2d697514195aa594055da1.jpg"></p><p>注意, 不能是如下写法:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;userIdList&quot;</span>: [<span class="number">90</span>,<span class="number">91</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同时传递List和其他类型的参数"><a href="#同时传递List和其他类型的参数" class="headerlink" title="同时传递List和其他类型的参数"></a>同时传递List和其他类型的参数</h1><p>比如同时传递List<Integer>和String参数, 可以使用Map集合来接收</Integer></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@RequestBody</span> HashMap&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = (List&lt;Integer&gt;)map.get(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postman在row中这样写</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [<span class="number">90</span>,<span class="number">91</span>], </span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;str&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不能这样去写, 接收不到参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;Long&gt; userIdList, <span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [<span class="number">90</span>,<span class="number">91</span>], </span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;str&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Postman测试文件下载接口"><a href="#Postman测试文件下载接口" class="headerlink" title="Postman测试文件下载接口"></a>Postman测试文件下载接口</h1><p><img src="https://pic.downk.cc/item/5f2d6a0b14195aa5940595d6.jpg"></p><h1 id="Postman传递token参数"><a href="#Postman传递token参数" class="headerlink" title="Postman传递token参数"></a>Postman传递token参数</h1><h2 id="设置token为环境变量"><a href="#设置token为环境变量" class="headerlink" title="设置token为环境变量"></a>设置token为环境变量</h2><p>需求: 登录之后, 服务器返回给前端一个token, 在每次访问接口时都要携带token参数</p><ol><li>首先测试获取token的接口得到返回的token</li></ol><p><img src="https://pic.downk.cc/item/5f2ac0c114195aa5940a226e.jpg"></p><ol start="2"><li><p>将token放到postman的全局变量中, 之后每次测试接口的时候postman会自动带上它</p><p><img src="https://pic.downk.cc/item/5f2ac17614195aa5940a84cb.jpg"></p></li></ol><p>   <img src="https://pic.downk.cc/item/5f2ac1aa14195aa5940a9e72.jpg"></p><p>添加完成之后, 回到测试接口页面</p><ol start="3"><li><p>在接口对应的 <strong>Test</strong> 接口中, 添加以下代码</p><p><img src="https://pic.downk.cc/item/5f2ac29614195aa5940b1961.jpg"></p></li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">var data = JSON.parse(responseBody);</span><br><span class="line">if (data.data.token) &#123;</span><br><span class="line">   tests[&quot;Body has token&quot;] = true;</span><br><span class="line">   postman.setEnvironmentVariable(&quot;token&quot;, data.data.token);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  tests[&quot;Body has token&quot;] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是设置刚才设置的全局变量</p><div class="note info">            <p>但是这里需要注意的是，data.token是和刚刚的返回token接口的返回结果中token的位置有关的</p>          </div><p> 如果返回结果中token位置为： </p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;Success&quot;</span>,</span><br><span class="line">   “data” :&#123; &quot;token&quot;:     &quot;QkxJVEtMUHhaU1NCRU1uRFM0SG1tZlVPS0JWR3FzcGJ3Vm9GMXBTOGlpdz06YWRtaW46NjM2ODI0NTE5MzAwODY3MDAw&quot;&#125;</span><br><span class="line">    &quot;username&quot;: &quot;admin&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;The token was successfully generated with a valid time of 30 minutes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 那么代码就要写成 </p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">var data = JSON.parse(responseBody);</span><br><span class="line">if (data.token) &#123;</span><br><span class="line">  tests[&quot;Body has token&quot;] = true;</span><br><span class="line">   postman.setEnvironmentVariable(&quot;token&quot;, data.token);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  tests[&quot;Body has token&quot;] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>之后再一次请求返回token的接口, 如果没有错误的话, 会在如下位置看到postman已经为我们自动配置好了返回的token的值</li></ol><p><img src="https://pic.downk.cc/item/5f2ac3f414195aa5940bc71a.jpg"></p><ol start="5"><li>配置好之后, 在需要携带token的接口中配置Header</li></ol><p><img src="https://pic.downk.cc/item/5f2ac43614195aa5940be900.jpg"></p><p>这样就可以携带token来请求接口啦</p><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><p> 定义一个xxx，获取body中返回的所有参数,并转化为JSON格式 var xxx = JSON.parse(responseBody); </p><p> 把json字符串转化为对象。parse()会进行json格式的检查是一个安全的函数， 如：检查json中某个数组元素的个数 (这里检测programs的长度) </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; JSON.parse(responseBody);</span><br><span class="line">tests[&quot;program&#39;s lenght&quot;] &#x3D; data.programs.length &#x3D;&#x3D;&#x3D; 5;</span><br></pre></td></tr></table></figure><p>将返回中的值设置为一个环境变量  <code>pm.environment.set(&quot;key&quot;,xxx.data.value);</code>或者<code>postman.setEnvironmentVariable(&quot;key&quot;, &quot;value&quot;);</code></p><p>将返回中的值设置为一个全局变量，<code>pm.globals.set(&quot;key&quot;,xxx.data.value);</code>或者<code>postman.setGlobalVariable(&quot;key&quot;, &quot;value&quot;);</code></p><div class="note info">            <p>注意：Global后面不能加s，value值一定要指定到某个具体节点</p>          </div><h2 id="tests方法"><a href="#tests方法" class="headerlink" title="tests方法"></a>tests方法</h2><p> 在postman里，内置了一些常用的test方法： </p><p><img src="https://pic.downk.cc/item/5f2cb2d214195aa594b97af8.jpg"></p><p>其他常用方法</p><ol><li><p>测试response Headers中的某个元素是否存在 <code>tests[&quot;元素Content-Type是否存在&quot;] = postman.getResponseHeader(&quot;Content-Type&quot;);</code></p><p>//getResponseHeader()方法会返回header的值；</p></li></ol><p>定义一个xxx，获取headers值    <code>var.xxx = postman.getResponseHeader(&quot;key&quot;);</code></p><p>将Headers中的值设置为一个环境变量  <code>postman.setEnvironmentVariable(&quot;key&quot;,xxx);或者pm.environment.set(&quot;key&quot;,xxx);</code></p><ol start="2"><li><p>检查response的code值是否为200    <code>tests[&quot;Status code is 200&quot;] = responseCode.code === 200;</code></p><p>//    tests[“Status code is 200”]中的tests 是一个内置对象，</p></li></ol><p>​    tests[“Status code is 200”]是指为这个断言起个名称叫”Status code is 200”，这个名称可以自行修改。</p><p>​    responseCode.code === 200中的responseCode是内置对象，responseCode对象中有个属性是code，是指HTTP状态码的code，判断code是否为200.</p><p>​    综合起来，这句代码的意思是：名称为”Status code is 200”的断言中，判断responseCode对象的code属性值（HTTP状态码）是否为200。</p><ol start="3"><li><p>检查response的body中是否包含字符串    <code>tests[&quot;Body matches string&quot;] = responseBody.has(&quot;type&quot;);</code></p><p>//    tests[“Body matches string”]中的tests是一个内置对象，</p></li></ol><p>​    tests[“Body matches string”]是指为这个断言起个名称叫”Body matches string”，这个名称可以自行修改。</p><p>​    这句代码的意思是：名称为”Body matches string”的断言中判断响应正文中是否包含：type这个字段。type无论是key或者value，只要匹配就可以。多个类型可用“，”分割。</p><ol start="4"><li><p>检查Response Body是否等于字符串    <code>tests[&quot;测试点&quot;] = responseBody === &quot;Response Body返回的内容&quot;;</code></p><p>//这个可以用在接口返回内容为纯字符串时，直接检查整个返回结果的正确性</p></li></ol><ol start="5"><li>检查Response time 是否小于200ms    <code>tests[&quot;Response time 小于200毫秒&quot;] = responseTime &lt; 200;</code></li></ol><p>​    检查Response time 是否大于200ms    <code>tests[&quot;Response time 大于200毫秒&quot;] = responseTime &gt; 200;</code></p><ol start="6"><li><code>postman.setNextRequest(&#39;Request 4&#39;)</code></li></ol><p>//    postman.setNextRequest()是一个带有一个参数的函数，它是接下来要运行的请求的名称或ID。往往用来跳转至某个接口，只在运行该集合时有用，单独运行无效</p><ol start="7"><li><p><code> var jsonObject = xml2Json(responseBody);</code></p><p>//转换XML body为JSON对象</p></li></ol><ol start="8"><li><p>设置一个随机数变量    <code>pm.globals.set(&quot;type&quot;,parseInt(4*Math.random())+1);</code></p><p>//针对不同类型的课程类型，设置一个1到4的随机整数，字段名是type,parselnt 是强制转换为整数</p></li></ol><ol start="9"><li><p>校验接口返回是否有数据    <code>tests[&quot;获取第一个结果&quot;] = xxx.content.jieguo[0];</code></p><p>//我的程序设置的是如果当前没有数据，则只返回content[]，所以这句断言可以校验，如果content里还有数据，则视为返回不为空</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;请求区域介绍&quot;&gt;&lt;a href=&quot;#请求区域介绍&quot; class=&quot;headerlink&quot; title=&quot;请求区域介绍&quot;&gt;&lt;/a&gt;请求区域介绍&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic.downk.cc/item/5f2e06f514195aa594
      
    
    </summary>
    
    
      <category term="Postman" scheme="http://yoursite.com/categories/Postman/"/>
    
    
      <category term="Postman" scheme="http://yoursite.com/tags/Postman/"/>
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用SpringBoot完成文件的下载</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8SpringBoot%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8SpringBoot%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-08-03T14:24:39.000Z</published>
    <updated>2020-08-03T14:45:52.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件下载源代码"><a href="#文件下载源代码" class="headerlink" title="文件下载源代码"></a>文件下载源代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.slf4j.LoggerFactory.getLogger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(tags = &quot;下载文件&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download_excel_template&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadFile</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;file/七星区人事信息模板.xlsx&quot;</span>);</span><br><span class="line">            File file = resource.getFile();</span><br><span class="line">            String filename = resource.getFilename();</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//强制下载不打开</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">            out = response.getOutputStream();</span><br><span class="line">            <span class="comment">//使用URLEncoder来防止文件名乱码或者读取错误</span></span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span>+ URLEncoder.encode(filename, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//当不写上一行代码时, 浏览器读到有后缀的文件时会尝试打开；即使下载也会命名为file。</span></span><br><span class="line">            <span class="comment">//加上设置大小下载下来的.xlsx文件打开时才不会报“Excel 已完成文件级验证和修复。此工作簿的某些部分可能已被修复或丢弃”</span></span><br><span class="line">            response.addHeader(<span class="string">&quot;Content-Length&quot;</span>, String.valueOf(file.length()));</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000000</span>];</span><br><span class="line">            <span class="keyword">while</span> (b != -<span class="number">1</span>) &#123;</span><br><span class="line">                b = inputStream.read(buffer);</span><br><span class="line">                <span class="keyword">if</span>(b!=-<span class="number">1</span>) out.write(buffer, <span class="number">0</span>, b);</span><br><span class="line">            &#125;</span><br><span class="line">            LOG.info(<span class="string">&quot;下载模板Excel成功&quot;</span>);</span><br><span class="line"><span class="comment">//            return new Response(200, &quot;下载成功&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"><span class="comment">//            return new Response(&quot;下载失败, 请重新下载&quot;);</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">            out.close();</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>如果下载方法有返回值的话, 会报错</p><p> <code>rg.springframework.http.converter.HttpMessageNotWritableException: No converter for [class java.lang.Boolean] with preset Content-Type &#39;application/octet-stream;charset=UTF-8&#39; </code></p><p><code>java.lang.IllegalStateException: Cannot call sendError() after the response has been committed</code></p><p>解决方法是去掉返回值, 或者return null;</p>          </div><h1 id="文件下载总结"><a href="#文件下载总结" class="headerlink" title="文件下载总结"></a>文件下载总结</h1><p>在文件下载功能中，一般都会借助于这两个 header 来达到效果，那么两个 header 的具体作用是什么呢？</p><ul><li>Content-Type：告诉浏览器当前的响应体是个什么类型的数据。当其为 application/octet-stream 的时候，就说明 body 里面是一堆不知道是啥的二进制数据。</li><li>Content-Disposition：用于向浏览器提供一些关于如何处理响应内容的额外的信息，同时也可以附带一些其它数据，比如在保存响应体到本地的时候应该使用什么样的文件名。</li></ul><p>细想一下， Content-Type 好像对于文件下载没什么作用？事实上的确如此。可是再想一下，如果浏览器不理会 Content-Disposition ，不下载文件怎么办？如果此时提供了 Content-Type ,至少浏览器还有机会根据具体的 Content-Type 对响应体进行处理。</p><p>可是为什么浏览器会不理会 Content-Disposition 呢？因为这个 Content-Disposition 头部并不是 HTTP 标准中的内容，只是被浏览器广泛实现的一个 header 而已。</p><p>话题转一转， Content-Disposition 的语法见<a href="https://tools.ietf.org/html/rfc6266#section-4.1">此处</a>，其中相对重要的点此处罗列一下：</p><ul><li>常用的 disponsition-type 有 <code>inline</code> 和 <code>attachment</code> ：<ul><li>inline：建议浏览器使用默认的行为处理响应体。</li><li>attachment：建议浏览器将响应体保存到本地，而不是正常处理响应体。</li></ul></li><li>Content-Disposition 中可以传入 filename 参数，有两种形式：<ul><li>filename=yourfilename.suffix：直接指明文件名和后缀。</li><li>filename*=utf-8’’yourfilename.suffix：指定了文件名编码。其中，编码后面那对单引号中还可以填入内容，此处不赘述，可参考<a href="https://tools.ietf.org/html/rfc6266">规范</a>。</li><li>有些浏览器不认识 <code>filename*=utf-8&#39;&#39;yourfilename.suffix</code> （估计因为这东西比较复杂），所以最好带上 <code>filename=yourfilename.suffix</code> 。</li></ul></li></ul><h1 id="使用PostMan测试文件下载接口"><a href="#使用PostMan测试文件下载接口" class="headerlink" title="使用PostMan测试文件下载接口"></a>使用PostMan测试文件下载接口</h1><p><img src="https://pic.downk.cc/item/5f2822dc14195aa594005455.jpg"></p><p>配不配置Header皆可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件下载源代码&quot;&gt;&lt;a href=&quot;#文件下载源代码&quot; class=&quot;headerlink&quot; title=&quot;文件下载源代码&quot;&gt;&lt;/a&gt;文件下载源代码&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
      <category term="文件下载" scheme="http://yoursite.com/categories/SpringBoot/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="文件下载" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>使用EasyExcel导出Excel文件</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-03T12:37:13.000Z</published>
    <updated>2020-08-07T05:21:20.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最简单的写"><a href="#最简单的写" class="headerlink" title="最简单的写"></a>最简单的写</h1><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ColumnWidth;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ContentRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.HeadRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.metadata.BaseRowModel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ContentRowHeight(15)</span> <span class="comment">//设定每一行的高度,不包含表头</span></span><br><span class="line"><span class="meta">@HeadRowHeight(30)</span>  <span class="comment">//设置 表头 高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelData</span> <span class="keyword">extends</span> <span class="title">BaseRowModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@ColumnWidth(15)</span>  <span class="comment">//列宽</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ColumnWidth(15)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;出生日期&quot;)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span> <span class="comment">// &quot;yyyy/MM/dd&quot; &quot;yyyy年MM月dd日HH时mm分ss秒&quot; 等等格式都可以</span></span><br><span class="line">    <span class="keyword">private</span> String birth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnWidth(15)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;工资&quot;)</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;.##&quot;)</span>  <span class="comment">//#代表任意数字, 注意这里的日期格式和数字格式都必须是字符串类型的</span></span><br><span class="line">    <span class="keyword">private</span> String salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定写入的列"><a href="#指定写入的列" class="headerlink" title="指定写入的列"></a>指定写入的列</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/553000/1584454018383-00194644-06a8-4e89-9d2f-99005652d4d4.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;字符串标题&quot;, index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;日期标题&quot;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里设置3 会导致第二列空的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;数字标题&quot;, index = 3)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂头写入"><a href="#复杂头写入" class="headerlink" title="复杂头写入"></a>复杂头写入</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/553000/1584454030244-62eccf86-d33b-4dac-93ec-397821957565.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexHeadData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;字符串标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;日期标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    <span class="meta">@ExcelProperty(&#123;&quot;主标题&quot;, &quot;数字标题&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="EasyExcelUtil"><a href="#EasyExcelUtil" class="headerlink" title="EasyExcelUtil"></a>EasyExcelUtil</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.EasyExcel;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.support.ExcelTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.write.metadata.style.WriteCellStyle;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.write.metadata.style.WriteFont;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.write.style.HorizontalCellStyleStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.HorizontalAlignment;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.IndexedColors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 版本2.1.7 工具类(仅导出)中可自定义样式格式等</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyExcelUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出 Excel ：一个 sheet，带表头.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      数据 list，每个元素为一个 BaseRowModel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName  导出的文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheetName 导入文件的 sheet 名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model     映射实体类，Excel 模型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExcel</span><span class="params">(HttpServletResponse response, List&lt;? extends Object&gt; data, String fileName, String sheetName, Class model)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 头的策略</span></span><br><span class="line">        WriteCellStyle headWriteCellStyle = <span class="keyword">new</span> WriteCellStyle();</span><br><span class="line">        <span class="comment">//设置表头居中对齐</span></span><br><span class="line">        headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        <span class="comment">// 颜色</span></span><br><span class="line">        headWriteCellStyle.setFillForegroundColor(IndexedColors.PALE_BLUE.getIndex());</span><br><span class="line">        WriteFont headWriteFont = <span class="keyword">new</span> WriteFont();</span><br><span class="line">        headWriteFont.setFontHeightInPoints((<span class="keyword">short</span>) <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 字体</span></span><br><span class="line">        headWriteCellStyle.setWriteFont(headWriteFont);</span><br><span class="line">        headWriteCellStyle.setWrapped(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 内容的策略</span></span><br><span class="line">        WriteCellStyle contentWriteCellStyle = <span class="keyword">new</span> WriteCellStyle();</span><br><span class="line">        <span class="comment">//设置内容靠中对齐</span></span><br><span class="line">        contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        <span class="comment">// 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现</span></span><br><span class="line">        HorizontalCellStyleStrategy horizontalCellStyleStrategy = <span class="keyword">new</span> HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);</span><br><span class="line">        <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">        EasyExcel.write(getOutputStream(fileName, response), model).excelType(ExcelTypeEnum.XLSX).sheet(sheetName).registerWriteHandler(horizontalCellStyleStrategy)</span><br><span class="line">                <span class="comment">//最大长度自适应 目前没有对应算法优化 建议注释掉不用 会出bug</span></span><br><span class="line"><span class="comment">//                .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())</span></span><br><span class="line">                .doWrite(data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出文件时为Writer生成OutputStream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> OutputStream <span class="title">getOutputStream</span><span class="params">(String fileName, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileName = URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/vnd.ms-excel&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + fileName + <span class="string">&quot;.xls&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;public&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">            response.addHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;max-age=0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> response.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;导出excel表格失败!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(tags = &quot;数据导出--Excel&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/export&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExportController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EasyExcelUtil excelUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;数据导出&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/exportExcel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportSysSystemExcel</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询总数并封装相关变量</span></span><br><span class="line">            Integer totalRowCount = (<span class="keyword">int</span>) userMapper.selectNormalUserCount();</span><br><span class="line">            Integer pageSize = ExcelConstant.PER_WRITE_ROW_COUNT;</span><br><span class="line">            Integer writeCount = totalRowCount % pageSize == <span class="number">0</span> ? (totalRowCount / pageSize) : (totalRowCount / pageSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; writeCount; i++) &#123;</span><br><span class="line">                List&lt;List&lt;String&gt;&gt; dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//查询并封装数据</span></span><br><span class="line">                PageHelper.startPage(i + <span class="number">1</span>, pageSize);</span><br><span class="line"></span><br><span class="line">                List&lt;User&gt; userList = userMapper.selectNormalUser();</span><br><span class="line">                <span class="keyword">if</span> (!CollectionUtils.isEmpty(userList)) &#123;</span><br><span class="line">                    userList.forEach(item -&gt; &#123;</span><br><span class="line">                        dataList.add(Arrays.asList(</span><br><span class="line">                                user.getBirthday() == <span class="keyword">null</span>? <span class="string">&quot;无&quot;</span> : user.getBirthday(),</span><br><span class="line">                                user.getBirthday() == <span class="keyword">null</span>? <span class="string">&quot;无&quot;</span> : user.getBirthday(),</span><br><span class="line">                                user.getSalary() == <span class="keyword">null</span>? <span class="string">&quot;无&quot;</span> : user.getSalary()</span><br><span class="line">                        ));</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                excelUtil.writeExcel(response, dataList, <span class="string">&quot;文件名称&quot;</span>, <span class="string">&quot;sheet1&quot;</span>, ExcelData.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用阿里的开源框架实现导出Excel的功能
    
    </summary>
    
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="EasyExcel" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/EasyExcel/"/>
    
    
      <category term="EasyExcel" scheme="http://yoursite.com/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>使用EasyExcel导入Excel文件</title>
    <link href="http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%85%A5Excel%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/08/03/%E4%BD%BF%E7%94%A8EasyExcel%E5%AF%BC%E5%85%A5Excel%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-03T08:10:34.000Z</published>
    <updated>2020-08-07T05:18:10.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导入Maven依赖"><a href="#导入Maven依赖" class="headerlink" title="导入Maven依赖"></a>导入Maven依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里开源EXCEL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Excel实体类"><a href="#Excel实体类" class="headerlink" title="Excel实体类"></a>Excel实体类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ColumnWidth;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.ContentRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.write.style.HeadRowHeight;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.metadata.BaseRowModel;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelData</span> <span class="keyword">extends</span> <span class="title">BaseRowModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;职务&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String postName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;籍贯&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String birthPlace;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;出生日期&quot;)</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span> <span class="comment">// &quot;yyyy/MM/dd&quot; &quot;yyyy年MM月dd日HH时mm分ss秒&quot; 等等格式都可以</span></span><br><span class="line">    <span class="keyword">private</span> String birth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;工资&quot;)</span></span><br><span class="line">    <span class="meta">@NumberFormat(&quot;.##&quot;)</span>  <span class="comment">//#代表任意数字, 注意这里的日期格式和数字格式都必须是字符串类型的</span></span><br><span class="line">    <span class="keyword">private</span> String salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@ExcelProperty(value = String[], index = int):<br>设置表头信息<br>value: 表名称<br>index: 列号</li></ol><div class="note warning">            <p>可以根据名字或者Index去匹配。当然也可以不写，默认第一个字段就是index=0，以此类推。千万注意，要么全部不写，要么全部用index，要么全部用名字去匹配。千万别三个混着用，除非你非常了解源代码中三个混着用怎么去排序的。 </p>          </div><p><code>ExcelIgnore</code> 默认所有字段都会和excel去匹配，加了这个注解会忽略该字段</p><ol start="2"><li><p><strong>DateTimeFormat</strong> 日期转换，用<code>String</code>去接收excel日期格式的数据会调用这个注解。里面的value参照<code>java.text.SimpleDateFormat</code></p></li><li><p><strong>ExcelIgnoreUnannotated</strong>  默认不加<code>ExcelProperty</code> 的注解的都会参与读写，加了不会参与</p></li><li><p><strong>NumberFormat</strong>  数字转换，用<code>String</code>去接收excel数字格式的数据会调用这个注解。里面的value参照<code>java.text.DecimalFormat</code></p></li></ol><h1 id="监听器-每读取一行都会调用invoke方法"><a href="#监听器-每读取一行都会调用invoke方法" class="headerlink" title="监听器(每读取一行都会调用invoke方法)"></a>监听器(每读取一行都会调用invoke方法)</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glriverside.qixing.personnel.listener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 *** 重点</span></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.config.ErrorMsg;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.common.ExcelData;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.model.Education;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.model.Post;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.model.User;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.EducationService;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.PostService;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.UserPostService;</span><br><span class="line"><span class="keyword">import</span> com.glriverside.qixing.personnel.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.slf4j.LoggerFactory.getLogger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析监听器，</span></span><br><span class="line"><span class="comment"> * 每解析一行会回调invoke()方法。</span></span><br><span class="line"><span class="comment"> * 整个excel解析结束会执行doAfterAllAnalysed()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelListener</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_COUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储错误信息的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ErrorMsg&gt; errorMsgList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法传递spring(目的是传递需要的参数进来)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelListener</span><span class="params">(UserService userService, List&lt;ErrorMsg&gt; errorMsgList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">        <span class="keyword">this</span>.errorMsgList = errorMsgList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义存储表格数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义存储标题结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T titleMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(T result, AnalysisContext context)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前行号</span></span><br><span class="line">        Integer rowIndex = context.readRowHolder().getRowIndex();</span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.titleMap = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据存储到list，供批量处理，或后续自己业务逻辑处理。</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExcelData)</span><br><span class="line">            &#123;</span><br><span class="line">                ExcelData excelData = (ExcelData)result;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> nameLength = excelData.getUserName().length();</span><br><span class="line">                <span class="keyword">if</span>(excelData.getUserName() != <span class="keyword">null</span> &amp;&amp; nameLength &lt; <span class="number">5</span> &amp;&amp; nameLength &gt; <span class="number">1</span>)</span><br><span class="line">                    user.setName(excelData.getUserName());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (excelData.getUserName() == <span class="keyword">null</span> )&#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;数据为空! 第&#123;&#125;行, userName&quot;</span>, rowIndex);</span><br><span class="line">                    errorMsgList.add(<span class="keyword">new</span> ErrorMsg(rowIndex, <span class="string">&quot;姓名为空&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                userService.addUser(user, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">&quot;解析数据第&#123;&#125;行，数据为：&#123;&#125;&quot;</span>, rowIndex, result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;导入Excel完成&quot;</span>);</span><br><span class="line">        saveData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, list.size());</span><br><span class="line">        demoDAO.save(list);</span><br><span class="line">        LOG.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取表头数据-需要的话在监听器中重写此方法即可"><a href="#读取表头数据-需要的话在监听器中重写此方法即可" class="headerlink" title="读取表头数据(需要的话在监听器中重写此方法即可)"></a>读取表头数据(需要的话在监听器中重写此方法即可)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里会一行行的返回头</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> headMap</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">&quot;解析到一条头数据:&#123;&#125;&quot;</span>, JSON.toJSONString(headMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h1><h2 id="读取单个Sheet"><a href="#读取单个Sheet" class="headerlink" title="读取单个Sheet"></a>读取单个Sheet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/import&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/importExcel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importExcel</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ExcelListener excelListener = <span class="keyword">new</span> ExcelListener&lt;ExcelData&gt;();</span><br><span class="line"></span><br><span class="line">            EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream()),excelListener).head(ExcelData.class).sheet().doReadSync();</span><br><span class="line">            <span class="comment">//其他写法</span></span><br><span class="line">            <span class="comment">//EasyExcel.read(new BufferedInputStream(file.getInputStream()), ExcelData.class, excelListener).sheet().doReadSync();</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取多个Sheet"><a href="#读取多个Sheet" class="headerlink" title="读取多个Sheet"></a>读取多个Sheet</h2><h3 id="一次性读取"><a href="#一次性读取" class="headerlink" title="一次性读取"></a>一次性读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream()), ExcelData.class, excelListener).doReadAll();</span><br><span class="line">                        </span><br><span class="line"><span class="comment">//其他写法</span></span><br><span class="line">EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream()),excelListener).head(ExcelData.class).doReadAll();</span><br></pre></td></tr></table></figure><h3 id="分批读取"><a href="#分批读取" class="headerlink" title="分批读取"></a>分批读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/import&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = getLogger(lookup().lookupClass());</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/importExcel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importExcel</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        ExcelReader excelReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            excelReader = EasyExcel.read(<span class="keyword">new</span> BufferedInputStream(file.getInputStream())).build();</span><br><span class="line"></span><br><span class="line">            ReadSheet readSheet1 =</span><br><span class="line">                    EasyExcel.readSheet(<span class="number">0</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> ExcelListener()).build();</span><br><span class="line">            ReadSheet readSheet2 =</span><br><span class="line">                    EasyExcel.readSheet(<span class="number">1</span>).head(ExcelData.class).registerReadListener(<span class="keyword">new</span> ExcelListener()).build();</span><br><span class="line">            <span class="comment">// 这里注意 一定要把sheet1 sheet2 一起传进去，不然有个问题就是03版的excel 会读取多次，浪费性能</span></span><br><span class="line">            excelReader.read(readSheet1, readSheet2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.error(e.getMessage(),e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (excelReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的</span></span><br><span class="line">                excelReader.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda表达式重构监听器-增加监听器的可扩展性"><a href="#Lambda表达式重构监听器-增加监听器的可扩展性" class="headerlink" title="Lambda表达式重构监听器(增加监听器的可扩展性)"></a>Lambda表达式重构监听器(增加监听器的可扩展性)</h1><p><img src="https://pic.downk.cc/item/5f27fbd514195aa594f47a13.png"></p>]]></content>
    
    <summary type="html">
    
      使用阿里的开源框架实现导入Excel的功能
    
    </summary>
    
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="EasyExcel" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/EasyExcel/"/>
    
    
      <category term="EasyExcel" scheme="http://yoursite.com/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客插入图片的方法</title>
    <link href="http://yoursite.com/2020/08/03/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/08/03/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-08-03T07:37:45.000Z</published>
    <updated>2020-08-03T07:53:26.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客插入图片的方法"><a href="#Hexo博客插入图片的方法" class="headerlink" title="Hexo博客插入图片的方法"></a>Hexo博客插入图片的方法</h1><h2 id="绝对引用"><a href="#绝对引用" class="headerlink" title="绝对引用"></a>绝对引用</h2><p> 少量使用图片的时候使用, 将文件放在 <em>/source/images</em> 文件夹下, 使用 markdown 语法 <code>![Lena](/images/lena.png)</code> 可以实现图片显示, 但是这种引用在本地markdown 编辑器中会无法预览,因为相对路径不一致,找不到文件, 不过在首页内容和文章正文中都能正常显示,十分方便 </p><p><img src="/.com//1.jpg" alt="图片"></p><p> 但是存在一个问题,后续可能维护起来麻烦, 不知道哪里引用了哪个图片,导致文章删除但是图片仍在</p><h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><ol><li><p><strong>设置站点配置<code>_config.yml</code></strong>:将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code></p></li><li><p><strong>安装插件</strong>:<code>npm install https://github.com/CodeFalling/hexo-asset-image -- save</code></p></li><li><p><strong>运行<code>hexo new post &quot;aaa&quot;</code></strong>,生成aaa.md博文时就会在<code>/source/_posts</code>目录下生成aaa的文件夹，将你想在aaa博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。</p></li><li><p><strong>添加图片</strong>:在想添加的位置写入<code>![](aaa/图片名字.图片格式)</code>,例如<code>![](aaa/1.png)</code>。</p><p><img src="/.com//1.jpg" alt="图片"></p></li></ol><h2 id="在线引用"><a href="#在线引用" class="headerlink" title="在线引用"></a>在线引用</h2><p>如果要引用的图片已经存在于网络上, 直接引用该图片的地址即可</p><p>  <code>![百度图片--lena](http://images2018.cnblogs.com/blog/1003156/201806/1003156-20180604175546711-227291592.png )</code></p><p>如果不存在于网络上,  可以使用在线图床上传之后得到链接使用, </p><p>比如使用  <a href="https://sm.ms/">sm.ms</a></p>]]></content>
    
    <summary type="html">
    
      Hexo博客插入图片的几种方法
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/categories/Hexo/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>基于github pages + Hexo 搭建自己的博客</title>
    <link href="http://yoursite.com/2020/08/02/2020-8-2-%E5%9F%BA%E4%BA%8Egithub-pages-+-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/08/02/2020-8-2-%E5%9F%BA%E4%BA%8Egithub-pages-+-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2020-08-02T08:42:21.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h1><p> GitHub Page 是github网站提供给用户,  并可以用来托管个人的静态网站, 用它来搭建个人博客可以省去购买服务器, 配置域名等操作</p><h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><ol><li><p>首先, 注册一个github账号</p></li><li><p>注册完成之后, 首先在右上角个人头像的左侧, 点击加号, 选择 <strong>New repository</strong> </p></li></ol><p>跳转页面之后, 来到创建仓库页面</p><p><img src="https://i.loli.net/2020/08/02/L9FvgXYZRQa7GwO.png" alt="post1_1.png"></p><div class="note info">            <p>这里的仓库名一定要为 xxx.github.io, 其中xxx为你的github用户名, 且要以”.”来做分割</p><p>比如我的仓库名就为 nopoetry.github.io</p>          </div><p>勾选下边的” Initialize this repository with a README “</p><ol start="3"><li><p>创建好仓库之后, 找到仓库的最右边的Setting按钮</p><p> <img src="https://i.loli.net/2020/08/02/tbFkHjZ3ErB1vRV.png" alt="post_2.png"> </p></li></ol><p>点击之后拉到最下边, 找到Github Pages这一项配置</p><p> <img src="https://i.loli.net/2020/08/02/p7g5hJqdkzV3MSG.png" alt="post_3.png"> </p><p>如果显示这样的信息, 就说明github已经为你自动生成了属于你的网页, 点击即可访问</p><h1 id="搭建Hexo环境"><a href="#搭建Hexo环境" class="headerlink" title="搭建Hexo环境"></a>搭建Hexo环境</h1><h2 id="安装git-和Node-js"><a href="#安装git-和Node-js" class="headerlink" title="安装git 和Node.js"></a>安装git 和Node.js</h2><p>我们需要用git把hexo生成的博客网页推送到刚刚创建的github仓库中</p><p><a href="https://blog.csdn.net/sanxd/article/details/82624127">安装git教程</a></p><p><a href="https://www.cnblogs.com/minxiang-luo/p/12490526.html">安装Node.js教程</a></p><h2 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h2><p> Hexo 是一个基于<a href="http://www.oschina.net/p/nodejs">node.js</a> 的静态博客网站生成器 </p><p>特点：</p><ul><li>不可思议的快速 ─ 只要一眨眼静态文件即生成完成</li><li>支持 <a href="http://daringfireball.net/projects/markdown/">Markdown</a></li><li>仅需一道指令即可部署到 <a href="http://pages.github.com/">GitHub Pages</a> 和 <a href="http://heroku.com/">Heroku</a></li><li>已移植 <a href="http://octopress.org/">Octopress</a> 插件</li><li>高扩展性、自订性</li><li>兼容于 Windows, Mac &amp; Linux</li></ul><p>首先在电脑中创建一个存放Hexo的文件夹</p><p>在该路径中打开cmd窗口</p><p>利用刚刚安装好的Node.js和npm安装Hexo</p><ol><li><p>输入npm install hexo-cli -g, 安装Hexo脚手架, 如果报错</p><p>则输入 npm install hexo-cli -g –force</p></li><li><p>输入hexo -v验证是否安装成功</p></li><li><p>输入hexo init, 初始化该文件夹的Hexo环境</p></li><li><p>输入npm install安装所需要的组件</p></li><li><p>输入npm g生成搭建博客需要的静态文件</p></li><li><p>输入npm s启动本地服务器, 启动成功后, 在浏览器中输入localhost:4000即可访问最原始的博客网站了</p><div class="note info">            <p>如果4000端口号被占用, 可以在_config.yml文件内加以下代码</p><p>server:</p><p>​    port: 4001(任意没被占用的端口号)</p><p>​    conpress: true</p><p>​    header: true</p>          </div></li></ol><h1 id="Hexo静态文件作用"><a href="#Hexo静态文件作用" class="headerlink" title="Hexo静态文件作用"></a>Hexo静态文件作用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;_config.yml：网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。</span><br><span class="line"></span><br><span class="line">&gt;package.json：框架的基本参数信息和它所依赖的插件，在 npm 安装时使用 --save 保存进去。</span><br><span class="line"></span><br><span class="line">&gt;scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new &lt;layout(布局)&gt; &lt;title&gt; 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。</span><br><span class="line"></span><br><span class="line">&gt;source：正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下(_posts)。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件下。</span><br><span class="line"></span><br><span class="line">&gt;public：参考 source 文件夹，在初始化后是没有 public 文件夹的，除非 hexo g 编译生成静态文件后，public 文件夹会自动生成。使用 </span><br><span class="line">&gt;hexo clean 清除 db.json 和 public 文件夹下的所有文件。</span><br><span class="line"></span><br><span class="line">&gt;themes：主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。</span><br><span class="line"></span><br><span class="line">&gt;.gitignore：.gitignore 文件作用是声明不被 git 记录的文件，hexo init &lt;folder&gt; 也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。</span><br></pre></td></tr></table></figure><p><strong>打开配置文档_config.yml，修改deploy值（在末尾）:</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:nopoetry/nopoetry.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>输入 npm install hexo-deployer-git –save  , 安装hexo上传到git的扩展工具</p><p>在博客文件夹的根目录下(也就是最开始你创建并安装Hexo的那个文件夹下), 打开cmd窗口或git bash窗口</p><p>打开后输入hexo new post “博客名”</p><p>这时文件夹source/_posts文件夹里会出现<strong>博客名.md</strong>的博客文章源文件</p><p>文件是<strong>markdown</strong>格式, 如果不想学习格式书写规范的话, 直接下载<strong>Typora</strong>这个软件就好了</p><p>如果使用Typora编辑工具, 在Typora写好博客内容后将文件复制粘贴到<strong>source/_posts</strong>文件夹下即可</p><p>编辑好博客内容后, 依次执行</p><p>hexo g 生成静态文件<br>hexo d 部署到Github Pages </p><p>完成后, 等待一段时间, 刷新博客网站即可看到自己的博客</p><h1 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h1><p>当然, 默认的博客主题着实是丑了点, 我们还可以在 <a href="https://hexo.io/themes/">Hexo官网</a> 上挑选好看的主题使用</p><p>一般来说被挑选为Hexo推荐的主题博客, 里边都会有对于该主题如何使用的教程</p><p>比如我们选择了<a href="https://demo.jerryc.me/">butterfly主题</a></p><p>在博客的根目录下打开cmd或git bash, 输入</p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/butterfly</p><p>clone完成后, 会保存在你博客目录的theme文件夹下, </p><p><img src="https://i.loli.net/2020/08/02/XSuxBhfZJAWPcjp.png" alt="post_4.png"></p><p>其中<strong>_config.yml</strong>就是该主题的配置文件, 我们可以根据主题的使用教程对该主题进行个性化配置</p><p>之后在<strong>博客的根目录</strong>下找到打开博客的配置文件<strong>_config.yml</strong></p><div class="note info">            <p>注意跟主题的配置文件进行区分</p>          </div><p>修改theme: landscape为</p><p>theme: butterfly</p><p>然后打开cmd或git bash 窗口, 清除之前的文件并重新生成和部署, 即可完成主题的切换</p><p>hexo clean(最好在每次上传博客或切换主题的 时候都clean一下)</p><p>hexo g</p><p>hexo d</p><p>如果完成上述操作之后, 打开博客网站只显示  </p><p>extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial </p><p>那么执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><p>执行完成之后再重新执行上述三条命令即可</p>]]></content>
    
    <summary type="html">
    
      使用github 和 Hexo 搭建不需要服务器和域名的博客网站
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="搭建博客教程" scheme="http://yoursite.com/categories/Hexo/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Butterfly 主题页面配置</title>
    <link href="http://yoursite.com/2020/08/01/Butterfly-%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/08/01/Butterfly-%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE/</id>
    <published>2020-08-01T13:34:00.000Z</published>
    <updated>2020-08-02T03:23:59.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h2><div class="note info">            <p>如果标注可选的参数，可根据自己需要添加，不用全部都写在 markdown 里</p>          </div><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">aplayer：</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面创建日期</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块 (默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments：</span></span><br><span class="line"><span class="emphasis">cover:  </span></span><br><span class="line"><span class="emphasis">toc:  </span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">auto<span class="emphasis">_open:</span></span><br><span class="line"><span class="emphasis">copyright:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author:</span><br><span class="line">copyright<span class="emphasis">_author_</span>href:</span><br><span class="line">copyright<span class="emphasis">_url:</span></span><br><span class="line"><span class="emphasis">copyright_</span>info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer：</span><br><span class="line">highlight<span class="emphasis">_shrink：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图 (如果没有设置 top_img, 文章页顶部将显示缩略图，可设为 false / 图片地址 / 留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块 (默认 true)</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块 (默认为设置中 post_copyright 的 enable 配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</td></tr></tbody></table><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><div class="note default">            <p>default 提示块标籤</p>          </div><div class="note primary no-icon">            <p>primary 提示块标籤</p>          </div><div class="note success">            <p>success 提示块标籤</p>          </div><div class="note info">            <p>info 提示块标籤</p>          </div><div class="note warning">            <p>warning 提示块标籤</p>          </div><div class="note danger">            <p>danger 提示块标籤</p>          </div><h1 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h1><p>顶部图有 2 种配置：具体 url 和（留空，true 和 false，三个效果一样）</p><h2 id="page页"><a href="#page页" class="headerlink" title="page页"></a>page页</h2><h3 id="当具体url时"><a href="#当具体url时" class="headerlink" title="当具体url时"></a>当具体url时</h3><p>主页的顶部图可以在 Butterfly.yml 设置 index_img</p><p>archives 页的顶部图可以在 Butterfly.yml 设置 archive_img</p><p>其他 page 页的顶部图可以在各自的 md 页面设置 front-matter 中的 top_img</p><div class="note info">            <p>页面如果没有设置各自的 top_img，则会显示 default_top_img 图片</p>          </div><h3 id="当顶部图留空，true-和-false"><a href="#当顶部图留空，true-和-false" class="headerlink" title="当顶部图留空，true 和 false"></a>当顶部图留空，true 和 false</h3><p>主页会显示纯颜色的顶部图</p><p>其他 page 的顶部图没有设置时，也会显示纯颜色的顶部图</p><h2 id="post页"><a href="#post页" class="headerlink" title="post页"></a>post页</h2><p>post 页的顶部图会优先显示各自 front-matter 中的 top_img, 如果没有设置，则会缩略图（即各自 front-matter 中的 cover)，如果没有则会显示显示 default_top_img 图片</p><h1 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h1><p>要为文章置顶，你需要安装插件 (hexo-generator-index-pin-top 或者 hexo-generator-indexed)</p><p>如果使用 hexo-generator-index-pin-top, 需要先卸载掉 hexo-generator-index，然后在文章的 front-matter 区域里添加 top: true 属性来把这篇文章置顶</p><p>如果使用 hexo-generator-indexed, 需要先卸载掉 hexo-generator-index，然后在文章的 front-matter 区域里添加 sticky: 1 属性来把这篇文章置顶。数值越大，置顶的优先级越大</p><h1 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h1><p>文章的 markdown 文档上，在 Front-matter 添加 cover, 并填上要显示的图片地址。<br>如果不配置 cover, 可以设置显示默认的 cover.</p><p>如果不想在首页显示 cover, 可以设置为 false</p><p>配置 butterfly.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span> </span><br></pre></td></tr></table></figure><p>当配置多张图片时，会随机选择一张作为 cover. 此时写法应为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      主题页面相关配置
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="Buttefly" scheme="http://yoursite.com/categories/Hexo/Buttefly/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="主题" scheme="http://yoursite.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="Butterfly" scheme="http://yoursite.com/tags/Butterfly/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/08/01/hello-world/"/>
    <id>http://yoursite.com/2020/08/01/hello-world/</id>
    <published>2020-08-01T12:36:47.052Z</published>
    <updated>2020-08-01T12:36:47.052Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
