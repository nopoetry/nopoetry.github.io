<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>转载---ThreadLocal的原理 | Li buyan Blog</title><meta name="description" content="一针见血理解ThreadLocal类ThreadLocal类具有两个维度：线程维度和变量维度。扔掉线程维度，保留并放大变量维度，虽然思想片面，但是给人的印象却是极深，才能用之出神入化。  ThreadLocal类是修饰变量的，重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了。很多开发语言在语言级别都提供这种作用域的变量类型。 根"><meta name="keywords" content="Java, ThreadLocal"><meta name="author" content="Li buyan"><meta name="copyright" content="Li buyan"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="转载---ThreadLocal的原理"><meta property="og:url" content="http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="Li buyan Blog"><meta property="og:description" content="一针见血理解ThreadLocal类ThreadLocal类具有两个维度：线程维度和变量维度。扔掉线程维度，保留并放大变量维度，虽然思想片面，但是给人的印象却是极深，才能用之出神入化。  ThreadLocal类是修饰变量的，重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了。很多开发语言在语言级别都提供这种作用域的变量类型。 根"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-08-08T05:36:13.000Z"><meta property="article:modified_time" content="2020-08-08T06:27:32.540Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-08 14:27:32'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="Li buyan Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E9%92%88%E8%A7%81%E8%A1%80%E7%90%86%E8%A7%A3ThreadLocal%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">一针见血理解ThreadLocal类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.1.</span> <span class="toc-text">官方术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E7%99%BD%E8%AF%9D"><span class="toc-number">3.2.</span> <span class="toc-text">大白话</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86"><span class="toc-number">5.</span> <span class="toc-text">核心知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">5.1.</span> <span class="toc-text">类关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE%E2%80%93-ThreadLocal%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">类关系图– ThreadLocal内存结构图。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initialValue"><span class="toc-number">5.3.1.</span> <span class="toc-text">initialValue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">什么意思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">触发时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">补充说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">5.3.1.4.</span> <span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-number">5.3.2.</span> <span class="toc-text">get</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-1"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">什么意思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-1"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getEntry"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">getEntry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">5.3.3.</span> <span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-2"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">什么意思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-2"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove"><span class="toc-number">5.3.4.</span> <span class="toc-text">remove</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D-3"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">什么意思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-3"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalMap"><span class="toc-number">5.4.</span> <span class="toc-text">ThreadLocalMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">完整源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">核心源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-1"><span class="toc-number">6.2.</span> <span class="toc-text">set()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getMap"><span class="toc-number">6.3.</span> <span class="toc-text">getMap()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-set"><span class="toc-number">6.4.</span> <span class="toc-text">map.set()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createMap"><span class="toc-number">6.5.</span> <span class="toc-text">createMap()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-1"><span class="toc-number">6.6.</span> <span class="toc-text">get()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setInitialValue"><span class="toc-number">6.7.</span> <span class="toc-text">setInitialValue()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initialValue-1"><span class="toc-number">6.8.</span> <span class="toc-text">initialValue()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remove-1"><span class="toc-number">6.9.</span> <span class="toc-text">remove()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.10.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%94%E7%96%91%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">答疑（面试题）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%A4%9A%E4%B8%AAThreadLocal%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AAThreadLocal%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%BA%BF%E7%A8%8Bid%E6%9D%A5%E4%BD%9C%E4%B8%BAThreadLocalMap%E7%9A%84key%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">为什么不直接用线程id来作为ThreadLocalMap的key？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8CSynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">和Synchronized的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9C%A8jvm%E7%9A%84%E5%93%AA%E4%B8%AA%E5%8C%BA%E5%9F%9F"><span class="toc-number">7.3.</span> <span class="toc-text">存储在jvm的哪个区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E7%9A%84%E5%8F%AA%E6%98%AF%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E5%90%97"><span class="toc-number">7.4.</span> <span class="toc-text">真的只是当前线程可见吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B9%88"><span class="toc-number">7.5.</span> <span class="toc-text">会导致内存泄漏么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Entry%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AFEntry%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.6.</span> <span class="toc-text">为什么用Entry数组而不是Entry对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%93%AA%E4%BA%9B%E7%94%A8%E5%88%B0%E4%BA%86ThreadLocal"><span class="toc-number">7.7.</span> <span class="toc-text">你学习的开源框架哪些用到了ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E9%87%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">7.8.</span> <span class="toc-text">ThreadLocal里的对象一定是线程安全的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">7.9.</span> <span class="toc-text">笔试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">ThreadLocal工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">ThreadLocal的内存泄露问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">Java中的四种引用类型（强、软、弱、虚）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">10.0.0.0.1.</span> <span class="toc-text">强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-number">10.0.0.0.2.</span> <span class="toc-text">软引用（Soft Reference）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-number">10.0.0.0.3.</span> <span class="toc-text">弱引用（Weak Reference）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88PhantomReference%EF%BC%89"><span class="toc-number">10.0.0.0.4.</span> <span class="toc-text">虚引用（PhantomReference）</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Li buyan Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">转载---ThreadLocal的原理</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-08T05:36:13.000Z" title="发表于 2020-08-08 13:36:13">2020-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-08T06:27:32.540Z" title="更新于 2020-08-08 14:27:32">2020-08-08</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="一针见血理解ThreadLocal类"><a href="#一针见血理解ThreadLocal类" class="headerlink" title="一针见血理解ThreadLocal类"></a><strong>一针见血理解ThreadLocal类</strong></h1><p><strong>ThreadLocal类具有两个维度：线程维度和变量维度。扔掉线程维度，保留并放大变量维度，虽然思想片面，但是给人的印象却是极深，才能用之出神入化。</strong> </p>
<p>ThreadLocal类是修饰变量的，<strong>重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了</strong>。很多开发语言在语言级别都提供这种作用域的变量类型。</p>
<p>根据变量的作用域，可以将变量分为全局变量，局部变量。简单的说，类里面定义的变量是全局变量，函数里面定义的变量是局部变量。</p>
<p>还有一种作用域是线程作用域，线程一般是跨越几个函数的。为了在几个函数之间共用一个变量，所以才出现：线程变量，这种变量在Java中就是ThreadLocal变量。</p>
<p>全局变量，范围很大；局部变量，范围很小。无论是大还是小，其实都是定死的。而线程变量，调用几个函数，则决定了它的作用域有多大。</p>
<p>ThreadLocal是跨函数的，虽然全局变量也是跨函数的，但是跨所有的函数，而且不是动态的。</p>
<p>ThreadLocal是跨函数的，但是跨哪些函数呢，由线程来定，更灵活。</p>
<p><a target="_blank" rel="noopener" href="http://threadlocal.cn/"><strong>一针见血理解ThreadLocal类</strong> </a></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>和Synchronized的区别</li>
<li>存储在jvm的哪个区域</li>
<li>真的只是当前线程可见吗</li>
<li>会导致内存泄漏么</li>
<li>为什么用Entry数组而不是Entry对象</li>
<li>你学习的开源框架哪些用到了ThreadLocal</li>
<li>ThreadLocal里的对象一定是线程安全的吗</li>
<li>笔试题</li>
</ol>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="官方术语"><a href="#官方术语" class="headerlink" title="官方术语"></a>官方术语</h2><p>ThreadLocal类是用来提供线程内部的局部变量。让这些变量在多线程环境下访问（get/set）时能保证各个线程里的变量相对独立于其他线程内的变量。</p>
<h2 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h2><p>ThreadLocal是一个关于创建线程局部变量的类。</p>
<p>通常情况下，我们创建的成员变量都是线程不安全的。因为他可能被多个线程同时修改，此变量对于多个线程之间彼此并不独立，是共享变量。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程无法访问和修改。也就是说：将线程公有化变成线程私有化。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>每个线程都需要一个独享的对象（比如工具类，典型的就是<code>SimpleDateFormat</code>，每次使用都new一个多浪费性能呀，直接放到成员变量里又是线程不安全，所以把他用<code>ThreadLocal</code>管理起来就完美了。）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: SimpleDateFormat就一份，不浪费资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TongWei.Chen 2020-07-10 14:00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest05</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStr</span><span class="params">(<span class="keyword">int</span> millisSeconds)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date(millisSeconds);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                String date = dateToStr(j * <span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 从结果中可以看出是线程安全的，时间没有重复的。</span></span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// java8的写法</span></span><br><span class="line"><span class="comment">//    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span></span><br><span class="line"><span class="comment">//            ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>细心的朋友已经发现了，这也是每个线程都创建一个<code>SimpleDateFormat</code>，跟直接在方法内部new没区别，错了，大错特错！1个请求进来是一个线程，他可能贯穿了N个方法，你这N个方法假设有3个都在使用<code>dateToStr()</code>，你直接new的话会产生三个<code>SimpleDateFormat</code>对象，而用<code>ThreadLocal</code>的话只会产生一个对象，一个线程一个。 </p>
          </div>

<ul>
<li>每个线程内需要保存全局变量（比如在登录成功后将用户信息存到<code>ThreadLocal</code>里，然后当前线程操作的业务逻辑直接get取就完事了，有效的避免的参数来回传递的麻烦之处），一定层级上减少代码耦合度。 </li>
</ul>
<h1 id="核心知识"><a href="#核心知识" class="headerlink" title="核心知识"></a>核心知识</h1><h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><p>每个<code>Thread</code>对象中都持有一个<code>ThreadLocalMap</code>的成员变量。每个<code>ThreadLocalMap</code>内部又维护了N个<code>Entry</code>节点，也就是<code>Entry</code>数组，每个<code>Entry</code>代表一个完整的对象，key是<code>ThreadLocal</code>本身，value是<code>ThreadLocal</code>的泛型值。</p>
<p>核心源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Thread类里持有ThreadLocalMap的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// java.lang.ThreadLocal有内部静态类ThreadLocalMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ThreadLocalMap内部有Entry类，Entry的key是ThreadLocal本身，value是泛型值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类关系图–-ThreadLocal内存结构图。"><a href="#类关系图–-ThreadLocal内存结构图。" class="headerlink" title="类关系图– ThreadLocal内存结构图。"></a>类关系图– ThreadLocal内存结构图。</h2><p><img src="https://pic.downk.cc/item/5f2e3ae414195aa594489736.png"></p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><ul>
<li><code>initialValue</code>：初始化。在<code>get</code>方法里懒加载的。</li>
<li><code>get</code>：得到这个线程对应的value。<em>如果调用get之前没set过，则get内部会执行<code>initialValue</code>方法进行初始化。</em></li>
<li><code>set</code>：为这个线程设置一个新值。</li>
<li><code>remove</code>：删除这个线程对应的值，防止内存泄露的最佳手段。</li>
</ul>
<h3 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a><code>initialValue</code></h3><h4 id="什么意思"><a href="#什么意思" class="headerlink" title="什么意思"></a>什么意思</h4><p>见名知意，初始化一些value（泛型值）。懒加载的。</p>
<h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><p>调用<code>get</code>方法之前没有调用<code>set</code>方法，则<code>get</code>方法内部会触发<code>initialValue</code>，也就是说<code>get</code>的时候如果没拿到东西，则会触发<code>initialValue</code>。</p>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul>
<li>通常，每个线程最多调用一次此方法。但是如果已经调用了<code>remove()</code>，然后再次调用<code>get()</code>的话，则可以再次触发<code>initialValue</code>。</li>
<li>如果要重写的话一般建议采取匿名内部类的方式重写此方法，否则默认返回的是null。</li>
</ul>
<p>比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = <span class="keyword">new</span> ThreadLocal() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Java8的高逼格写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected的含义就是交给子类干的。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a><code>get</code></h3><h4 id="什么意思-1"><a href="#什么意思-1" class="headerlink" title="什么意思"></a>什么意思</h4><p>获取当前线程下的ThreadLocal中的值。</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>threadLocalHashCode</code>来获取table[]中存放的Entry对象, 也就是ThreadLocal对象</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h3><h4 id="什么意思-2"><a href="#什么意思-2" class="headerlink" title="什么意思"></a>什么意思</h4><p>其实干的事和<code>initialValue</code>是一样的，都是set值，只是调用时机不同。set是想用就用，api摆在这里，你想用就调一下set方法。很自由。</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例，注意这里是将t传进去了，t是当前线程，就是说ThreadLocalMap是在线程里持有的引用。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a><code>remove</code></h3><h4 id="什么意思-3"><a href="#什么意思-3" class="headerlink" title="什么意思"></a>什么意思</h4><p>将当前线程下的ThreadLocal的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。主要目的是防止内存泄漏。内存泄漏问题下面会说。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 直接移除以当前ThreadLocal为key的value</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>为啥单独拿出来说下，我就是想强调一点：这个东西是归<code>Thread</code>类所有的。它的引用在<code>Thread</code>类里，这也证实了一个问题：<code>ThreadLocalMap</code>类内部为什么有<code>Entry</code>数组，而不是<code>Entry</code>对象？</p>
<p>因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为再说一次，<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p>
<p>核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在你调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span></span><br><span class="line"><span class="comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h1><h2 id="核心源码"><a href="#核心源码" class="headerlink" title="核心源码"></a>核心源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地线程。Thread：线程。Local：本地</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始值，用来初始化值用的，比如：ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// 你想Integer value = count.get(); value++;这样是报错的，因为count现在还没值，取出来的是个null,所以你需要先重写此方法为value赋上初始值，本身方法是protected也代表就是为了子类重写的。</span></span><br><span class="line">    <span class="comment">// 此方法是一个延迟调用方法，在线程第一次调用get的时候才执行，下面具体分析源码就知道了。</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建ThreadLocalMap，ThreadLocal底层其实就是一个map来维护的。</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回该当前线程对应的线程局部变量值。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取ThreadLocalMap</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置当前线程的线程局部变量的值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将当前线程局部变量的值删除，目的是为了减少内存占用。其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置初始值，调用initialValue</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 静态内部类，一个map来维护的！！！</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// ThreadLocalMap的静态内部类，继承了弱引用，这正是不会造成内存泄漏根本原因</span></span><br><span class="line">        <span class="comment">// Entry的key为ThreadLocal并且是弱引用。value是值</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-1"><a href="#set-1" class="headerlink" title="set()"></a>set()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的线程局部变量的值</span></span><br><span class="line"><span class="comment"> * 实际上ThreadLocal的值是放入了当前线程的一个ThreadLocalMap实例中，所以只能在本线程中访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap实例</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若当前线程有对应的ThreadLocalMap实例，则将当前ThreadLocal对象作为key，value做为值存到ThreadLocalMap的entry里。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 若当前线程没有对应的ThreadLocalMap实例，则创建ThreadLocalMap，并将此线程与之绑定</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getMap"><a href="#getMap" class="headerlink" title="getMap()"></a>getMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在你调用ThreadLocal.get()方法的时候就会调用这个方法，它的返回是当前线程里的threadLocals的引用。</span></span><br><span class="line"><span class="comment">// 这个引用指向的是ThreadLocal里的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ThreadLocal.ThreadLocalMap</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map-set"><a href="#map-set" class="headerlink" title="map.set()"></a>map.set()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不多BB，就和HashMap的set一个道理，只是赋值key,value。</span></span><br><span class="line"><span class="comment">// 需要注意的是这里key是ThreadLocal对象，value是值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="createMap"><a href="#createMap" class="headerlink" title="createMap()"></a>createMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ThreadLocalMap对象。</span></span><br><span class="line"><span class="comment"> * t.threadLocals在上面的getMap中详细介绍了。此处不BB。</span></span><br><span class="line"><span class="comment"> * 实例化ThreadLocalMap并且传入两个值，一个是当前ThreadLocal对象一个是value。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ThreadLocalMap构造器。</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 重点看这里！！！！！！</span></span><br><span class="line">    <span class="comment">// new了一个ThreadLocalMap的内部类Entry，且将key和value传入。</span></span><br><span class="line">    <span class="comment">// key是ThreadLocal对象。</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 到这里朋友们应该真相大白了，其实ThreadLocal就是内部维护一个ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 而ThreadLocalMap内部又维护了一个Entry对象。Entry对象是key-value形式，</span></span><br><span class="line"><span class="comment"> * key是ThreadLocal对象，value是传入的value</span></span><br><span class="line"><span class="comment"> * 所以我们对ThreadLocal的操作其实都是对内部的ThreadLocalMap.Entry的操作</span></span><br><span class="line"><span class="comment"> * 所以保证了线程之前互不干扰。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程下的entry里的value值。</span></span><br><span class="line"><span class="comment"> * 先获取当前线程下的ThreadLocalMap，</span></span><br><span class="line"><span class="comment"> * 然后以当前ThreadLocal为key取出map中的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程对应的ThreadLocalMap对象。</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 若获取到了。则获取此ThreadLocalMap下的entry对象，若entry也获取到了，那么直接获取entry对应的value返回即可。</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取此ThreadLocalMap下的entry对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 若entry也获取到了</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 直接获取entry对应的value返回。</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若没获取到ThreadLocalMap或没获取到Entry，则设置初始值。</span></span><br><span class="line">    <span class="comment">// 知识点：我早就说了，初始值方法是延迟加载，只有在get才会用到，这下看到了吧，只有在这获取没获取到才会初始化，下次就肯定有值了，所以只会执行一次！！！</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue()"></a>setInitialValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用初始值方法，由子类提供。</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 获取到了</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// set</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 没获取到。创建map并赋值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回初始值。</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="initialValue-1"><a href="#initialValue-1" class="headerlink" title="initialValue()"></a>initialValue()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由子类提供实现。</span></span><br><span class="line"><span class="comment">// protected</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove()"></a>remove()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程局部变量的值删除，目的是为了减少内存占用。</span></span><br><span class="line"><span class="comment"> * 其实当线程结束后对应该线程的局部变量将自动被垃圾回收，所以无需我们调用remove，我们调用remove无非也就是加快内存回收速度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap对象，并将其移除。</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>只要捋清楚如下几个类的关系，<code>ThreadLocal</code>将变得so easy！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread&#96;、&#96;ThreadLocal&#96;、&#96;ThreadLocalMap&#96;、&#96;Entry</span><br></pre></td></tr></table></figure>

<p>一句话总结就是：<code>Thread</code>维护了<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>里维护了<code>Entry</code>，而<code>Entry</code>里存的是以<code>ThreadLocal</code>为key，传入的值为value的键值对。</p>
<h1 id="答疑（面试题）"><a href="#答疑（面试题）" class="headerlink" title="答疑（面试题）"></a>答疑（面试题）</h1><h2 id="如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"><a href="#如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？" class="headerlink" title="如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？"></a>如何实现一个线程多个ThreadLocal对象，每一个ThreadLocal对象是如何区分的呢？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一个ThreadLocal对象，都有一个final修饰的int型的threadLocalHashCode不可变属性，对于基本数据类型，可以认为它在初始化后就不可以进行修改，所以可以唯一确定一个ThreadLocal对象。<br>　　但是如何保证两个同时实例化的ThreadLocal对象有不同的threadLocalHashCode属性：在ThreadLocal类中，还包含了一个static修饰的AtomicInteger（[əˈtɒmɪk]提供原子操作的Integer类）成员变量（即类变量）和一个static final修饰的常量（作为两个相邻nextHashCode的差值）。由于nextHashCode是类变量，所以每一次调用ThreadLocal类都可以保证nextHashCode被更新到新的值，并且下一次调用ThreadLocal类这个被更新的值仍然可用，同时AtomicInteger保证了nextHashCode自增的原子性。</p>
<h3 id="为什么不直接用线程id来作为ThreadLocalMap的key？"><a href="#为什么不直接用线程id来作为ThreadLocalMap的key？" class="headerlink" title="为什么不直接用线程id来作为ThreadLocalMap的key？"></a>为什么不直接用线程id来作为ThreadLocalMap的key？</h3><p>　　这一点很容易理解，因为直接用线程id来作为ThreadLocalMap的key，无法区分放入ThreadLocalMap中的多个value。比如我们放入了两个字符串，你如何知道我要取出来的是哪一个字符串呢？<br>　　而使用ThreadLocal作为key就不一样了，由于每一个ThreadLocal对象都可以由threadLocalHashCode属性唯一区分或者说每一个ThreadLocal对象都可以由这个对象的名字唯一区分，所以可以用不同的ThreadLocal作为key，区分不同的value，方便存取。</p>
<h2 id="和Synchronized的区别"><a href="#和Synchronized的区别" class="headerlink" title="和Synchronized的区别"></a>和Synchronized的区别</h2><p>问：他和线程同步机制（如：Synchronized）提供一样的功能，这个很吊啊。</p>
<p>答：放屁！同步机制保证的是多线程同时操作共享变量并且能正确的输出结果。ThreadLocal不行啊，他把共享变量变成线程私有了，每个线程都有独立的一个变量。举个通俗易懂的案例：网站计数器，你给变量count++的时候带上synchronized即可解决。ThreadLocal的话做不到啊，他没发统计，他只能说能统计每个线程登录了多少次。</p>
<h2 id="存储在jvm的哪个区域"><a href="#存储在jvm的哪个区域" class="headerlink" title="存储在jvm的哪个区域"></a>存储在jvm的哪个区域</h2><p>问：线程私有，那么就是说ThreadLocal的实例和他的值是放到栈上咯？</p>
<p>答：不是。还是在堆的。ThreadLocal对象也是对象，对象就在堆。只是JVM通过一些技巧将其可见性变成了线程可见。</p>
<h2 id="真的只是当前线程可见吗"><a href="#真的只是当前线程可见吗" class="headerlink" title="真的只是当前线程可见吗"></a>真的只是当前线程可见吗</h2><p>问：真的只是当前线程可见吗？</p>
<p>答：貌似不是，貌似通过<code>InheritableThreadLocal</code>类可以实现多个线程访问<code>ThreadLocal</code>的值，但是我没研究过，知道这码事就行了。</p>
<h2 id="会导致内存泄漏么"><a href="#会导致内存泄漏么" class="headerlink" title="会导致内存泄漏么"></a>会导致内存泄漏么</h2><p>问：会导致内存泄漏么？</p>
<p>答：分析一下：</p>
<ul>
<li>1、<code>ThreadLocalMap.Entry</code>的key会内存泄漏吗？</li>
<li>2、<code>ThreadLocalMap.Entry</code>的value会内存泄漏吗？</li>
</ul>
<p>先看下key-value的核心源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 先看继承关系，发现是继承了弱引用，而且key直接是交给了父类处理<code>super(key)</code>，父类是个弱引用，所以key完全不存在内存泄漏问题，因为他不是强引用，它可以被GC回收的。 </p>
<div class="note info">
            <p>弱引用的特点：如果这个对象只被弱引用关联，没有任何强引用关联，那么这个对象就可以被GC回收掉。弱引用不会阻止GC回收。这是jvm知识。 </p>
          </div>

<p>看value，发现value是个强引用，但是想了下也没问题的呀，因为线程终止了，我管你强引用还是弱引用，都会被GC掉的，因为引用链断了（jvm用的可达性分析法，线程终止了，根节点就断了，下面的都会被回收）。</p>
<p>这么分析一点毛病都没有，但是忘了一个主要的角色，那就是<strong>线程池</strong>，线程池的存在核心线程是不会销毁的，只要创建出来他会反复利用，生命周期不会结束掉，但是key是弱引用会被GC回收掉，value强引用不会回收，所以形成了如下场面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-&gt;ThreadLocalMap-&gt;Entry(key为null)-&gt;value</span><br></pre></td></tr></table></figure>

<p>由于value和Thread还存在链路关系，还是可达的，所以不会被回收，这样越来越多的垃圾对象产生却无法回收，早晨内存泄漏，时间久了必定OOM。</p>
<p>解决方案<code>ThreadLocal</code>已经为我们想好了，提供了<code>remove()</code>方法，这个方法是将value移出去的。所以用完后记得<code>remove()</code>。</p>
<h2 id="为什么用Entry数组而不是Entry对象"><a href="#为什么用Entry数组而不是Entry对象" class="headerlink" title="为什么用Entry数组而不是Entry对象"></a>为什么用Entry数组而不是Entry对象</h2><p> 这个其实主要想考<code>ThreadLocalMap</code>是在<code>Thread</code>里持有的引用。 </p>
<p>：<code>ThreadLocalMap</code>内部的table为什么是数组而不是单个对象呢？</p>
<p>答：因为你业务代码能new好多个<code>ThreadLocal</code>对象，各司其职。但是在一次请求里，也就是一个线程里，<code>ThreadLocalMap</code>是同一个，而不是多个，不管你new几次<code>ThreadLocal</code>，<code>ThreadLocalMap</code>在一个线程里就一个，因为<code>ThreadLocalMap</code>的引用是在<code>Thread</code>里的，所以它里面的<code>Entry</code>数组存放的是一个线程里你new出来的多个<code>ThreadLocal</code>对象。</p>
<h2 id="你学习的开源框架哪些用到了ThreadLocal"><a href="#你学习的开源框架哪些用到了ThreadLocal" class="headerlink" title="你学习的开源框架哪些用到了ThreadLocal"></a>你学习的开源框架哪些用到了ThreadLocal</h2><p>Spring框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DateTimeContextHolder</span><br><span class="line">RequestContextHolder</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal里的对象一定是线程安全的吗"><a href="#ThreadLocal里的对象一定是线程安全的吗" class="headerlink" title="ThreadLocal里的对象一定是线程安全的吗"></a>ThreadLocal里的对象一定是线程安全的吗</h2><p>未必，如果在每个线程中<code>ThreadLocal.set()</code>进去的东西本来就是多线程共享的同一个对象，比如static对象，那么多个线程的<code>ThreadLocal.get()</code>获取的还是这个共享对象本身，还是有并发访问线程不安全问题。</p>
<h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><p>问：下面这段程序会输出什么？为什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadLocalNpe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            set();</span><br><span class="line">            System.out.println(get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 目的就是为了让子线程先运行完</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line"> at com.chentongwei.study.thread.TestThreadLocalNpe.get(TestThreadLocalNpe.java:<span class="number">16</span>)</span><br><span class="line"> at com.chentongwei.study.thread.TestThreadLocalNpe.main(TestThreadLocalNpe.java:<span class="number">26</span>)</span><br></pre></td></tr></table></figure>

<p>为什么？</p>
<p>为什么输出个1，然后空指针了？</p>
<p>首先输出1是没任何问题的，其次主线程空指针是为什么？</p>
<p>如果你这里回答</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>那我恭喜你，你连<code>ThreadLocal</code>都不知道是啥，这明显两个线程，子线程和主线程。子线程设置1，主线程肯定拿不到啊，<code>ThreadLocal</code>和线程是嘻嘻相关的。这个不多费口舌。</p>
<p>说说为什么是空指针？</p>
<p>因为你get方法用的long而不是Long，那也应该返回null啊，大哥，long是基本类型，默认值是0，没有null这一说法。<code>ThreadLocal</code>里的泛型是Long，get却是基本类型，这需要拆箱操作的，也就是会执行<code>null.longValue()</code>的操作，这绝逼空指针了。</p>
<blockquote>
<p>看似一道Javase的基础题目，实则隐藏了很多知识。</p>
</blockquote>
<h1 id="ThreadLocal工具类"><a href="#ThreadLocal工具类" class="headerlink" title="ThreadLocal工具类"></a>ThreadLocal工具类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.duoku.base.util;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.NamedThreadLocal;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TongWei.Chen 2019-09-09 18:35:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUtil</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = <span class="keyword">new</span> NamedThreadLocal(<span class="string">&quot;xxx-threadlocal&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Maps.newHashMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">getThreadLocal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        <span class="comment">// todo:copy a new one</span></span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String key,T defaultValue)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        <span class="keyword">return</span> (T)map.get(key) == <span class="keyword">null</span> ? defaultValue : (T)map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Map&lt;String, Object&gt; keyValueMap)</span> </span>&#123;</span><br><span class="line">        Map map = threadLocal.get();</span><br><span class="line">        map.putAll(keyValueMap);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h1><p> <strong>ThreadLocalMap是使用ThreadLocal的弱引用作为Key的</strong>。下图是本文介绍到的一些对象之间的引用关系图，实线表示强引用，虚线表示弱引用： </p>
<p><img src="https://pic.downk.cc/item/5f2e405c14195aa5944ad13d.png"></p>
<p>如上图，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value<br>永远无法回收，造成内存泄露。<br>　　<br>　　ThreadLocalMap设计时的对上面问题的对策：<br>ThreadLocalMap的getEntry函数的流程大概为：</p>
<ol>
<li>首先从ThreadLocal的直接索引位置(通过ThreadLocal.threadLocalHashCode &amp; (table.length-1)运算得到)获取Entry e，如果e不为null并且key相同则返回e；</li>
<li>如果e为null或者key不一致则向下一个位置查询，如果下一个位置的key和当前需要查询的key相等，则返回对应的Entry。否则，如果key值为null，则擦除该位置的Entry，并继续向下一个位置查询。在这个过程中遇到的key为null的Entry都会被擦除，那么Entry内的value也就没有强引用链，自然会被回收。仔细研究代码可以发现，set操作也有类似的思想，将key为null的这些Entry都删除，防止内存泄露。<br>　　但是光这样还是不够的，上面的设计思路依赖一个前提条件：要调用ThreadLocalMap的getEntry函数或者set函数。这当然是不可能任何情况都成立的，所以很多情况下需要使用者手动调用ThreadLocal的remove函数，手动删除不再需要的ThreadLocal，防止内存泄露。所以JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</li>
</ol>
<p>即：<br>1.使用ThreadLocal，建议用static修饰 static ThreadLocal headerLocal = new ThreadLocal();<br>2.使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</p>
<h1 id="Java中的四种引用类型（强、软、弱、虚）"><a href="#Java中的四种引用类型（强、软、弱、虚）" class="headerlink" title="Java中的四种引用类型（强、软、弱、虚）"></a><strong>Java中的四种引用类型（强、软、弱、虚）</strong></h1><p> 从Java 1.2开始，JVM开发团队发现，单一的强引用类型，无法很好的管理对象在JVM里面的生命周期，垃圾回收策略过于简单，无法适用绝大多数场景。为了更好的管理对象的内存，更好的进行垃圾回收，JVM团队扩展了引用类型，从最早的强引用类型增加到强、软、弱、虚四个引用类型。 </p>
<p>Strong Rerence为JVM内部实现。其他三类引用类型全部继承自Reference父类。如下图所示：</p>
<p><img src="http://threadlocal.cn/static/image/reference.jpg?v=f25eecc290e57663c98198e92c1ac67a" alt="img"></p>
<h5 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h5><p>Strong Rerence这个类并不存在，默认的对象都是强引用类型，因为有后来的新引用所衬托，所以才起了个名字叫”强引用”。</p>
<p>强引用使用示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String web &#x3D; &quot;www.threadlocal.cn&quot;;</span><br></pre></td></tr></table></figure>

<p>如果JVM垃圾回收器 GC 可达性分析结果为可达，表示引用类型仍然被引用着，这类对象始终不会被垃圾回收器回收，即使JVM发生OOM也不会回收。而如果 GC 的可达性分析结果为不可达，那么在GC时会被回收。</p>
<h5 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h5><p>软引用是一种比强引用生命周期稍弱的一种引用类型。在JVM内存充足的情况下，软引用并不会被垃圾回收器回收，只有在JVM内存不足的情况下，才会被垃圾回收器回收。所以软引用一般用来实现一些内存敏感的缓存，只要内存空间足够，对象就会保持不被回收掉。</p>
<p>软引用使用示例如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;String&gt; softReference &#x3D; new SoftReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;));</span><br><span class="line">String web &#x3D; softReference.get();</span><br></pre></td></tr></table></figure>

<h5 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h5><p>弱引用是一种比软引用生命周期更短的引用。它的生命周期很短，不论当前内存是否充足，都只能存活到下一次垃圾收集之前。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; weakReference &#x3D; new WeakReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;));</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">if(weakReference.get() &#x3D;&#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;weakReference已经被GC回收&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>weakReference已经被GC回收</p>
<h5 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h5><p>虚引用与前面的几种都不一样，这种引用类型不会影响对象的生命周期，所持有的引用就跟没持有一样，随时都能被GC回收。</p>
<p>需要注意的是，在使用虚引用时，必须和引用队列关联使用。在对象的垃圾回收过程中，如果GC发现一个对象还存在虚引用，则会把这个虚引用加入到与之关联的引用队列中。</p>
<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p>
<p>如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象内存被回收之前采取必要的行动防止被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; phantomReference &#x3D; new PhantomReference&lt;String&gt;(new String(&quot;www.threadlocal.cn&quot;), new ReferenceQueue&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">System.out.println(phantomReference.get());</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">libuyan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/">http://yoursite.com/2020/08/08/%E8%BD%AC%E8%BD%BD-ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Li buyan Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/ThreadLocal/">ThreadLocal</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/09/%E8%BD%AC%E8%BD%BD-%E5%B9%B6%E6%9F%A5%E9%9B%86/"><img class="prev-cover" data-lazy-src="https://backiee.com/static/wpdb/wallpapers/1000x563/029749.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">转载---并查集</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/05/Postman%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"><img class="next-cover" data-lazy-src="https://backiee.com/static/wpdb/wallpapers/1000x563/184820.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PostMan的使用方法</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Li buyan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to Li buyan Blog!</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>